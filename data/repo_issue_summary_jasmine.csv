issue_id,title,contents,authorLogin,authorAssociation,createdAt,closed,closedAt,closedDuration_days,milestone,participants_count,comments_count,firstCommentCreatedAt,firstCommentDuration_days,firstCommentAuthor,firstCommentAuthorAssociation,num_unique_comment_author_MEMBER,num_unique_comment_author_CONTRIBUTOR,num_unique_comment_author_COLLABORATOR,num_unique_comment_author_NONE,labels,label_waiting,label_feature request,label_has pr,label_Protractor,label_Karma,label_npm,label_React,label_docs,label_has Tracker story,label_ready for work,label_duplicate,label_bug,label_1.3.x,label_gem,label_help needed
1,geminstaller doesn't work,"geminstaller still points to github for gems.  I'm not sure if all these gems are on gemcutter.  I can't find jsdoc-helper.  I admittedly stopped there.  Can we get this working?  I'm going to try to build all these gems by hand, but some people on the team are not going to be keen on doing that.",adkron,NONE,2009-12-17 04:02:52+00:00,True,2009-12-24 05:31:08+00:00,7.06,,2,4,2009-12-23 15:51:18+00:00,6.49,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
2,documentation of 'not' in matchers,"Documentation incorrect:
Expectation Matchers
Jasmine has several built-in matchers.  Here are a few:
...
wrong
Every matcher's criteria can be inverted by prepending .not:
expect(x).not.toEqual(y); compares objects or primitives x and y and passes if they are not equivalent
right?
Every matcher's criteria can be inverted by inserting Not in the matcher function name after to:
expect(x).toNotEqual(y); compares objects or primitives x and y and passes if they are not equivalent",mc2,NONE,2010-03-06 19:29:02+00:00,True,2010-03-15 20:28:33+00:00,9.04,,2,1,2010-03-15 20:28:33+00:00,9.04,xian,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
3,Wrong script reference in example_runner.html  in 0.10.3-release,"There is a minor error in
examples/html/example_runner.html
<script type=""text/javascript"" src=""../../lib/jasmine-0.10.1.js""></script>
Should be
<script type=""text/javascript"" src=""../../lib/jasmine-0.10.3.js""></script>",rslijp,NONE,2010-04-11 18:32:29+00:00,True,2010-07-09 21:56:29+00:00,89.14,,3,2,2010-04-12 18:58:35+00:00,1.02,jfirebaugh,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
4,"describe(<non-string>, ...) causes cryptic errors","describe(String, function() {
  ...
});

The first argument to describe should be converted to a string in a useful way, a la rspec. In particular it would be useful to pass constructor functions and have them read as a type name.",jfirebaugh,NONE,2010-05-07 00:10:18+00:00,True,2011-06-19 03:32:37+00:00,408.14,,3,4,2010-08-07 17:39:25+00:00,92.73,,NONE,0,1,0,2,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
5,Backtrace for errors,"Hi,
when an exception is thrown (and not caught), jasmine caught it and marks the spec as failed. It's the expected behaviour, but the backtrace is lost and it can be difficult to fix the spec.",nono,NONE,2010-05-10 14:08:32+00:00,True,2011-06-19 03:33:27+00:00,404.56,,13,14,2010-05-10 14:24:47+00:00,0.01,eahanson,CONTRIBUTOR,0,3,0,10,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
6,Rhino?,"One of your stated reasons for writing jasmine was that 'some frameworks require a browser'... can jasmine be run just w/ rhino?
thanks",jaredly,NONE,2010-05-10 18:00:54+00:00,True,2010-08-08 00:42:39+00:00,89.28,,2,2,2010-08-07 17:42:24+00:00,88.99,,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
7,jasmine assumes existence of global window object,"I understand that one of the design goals of jasmine is to be host agnostic. However, evaluating it in a bare javascript interpreter yields the following error:
ReferenceError: window is not defined: jasmine-0.10.3.js:49
You may want to detect if window exists before remapping its functions.
cheers,
Charles",cowboyd,NONE,2010-06-02 12:38:54+00:00,True,2010-06-22 23:25:44+00:00,20.45,,3,2,2010-06-02 12:45:21+00:00,0.0,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
8,spec counting and reporting is inconsistent.,"describe(""The Runner"", function() {
it(""does not count a spec in the totalCount if there are no expectations (even though it does run)"", function() {
})
it(""does not have a count of skippped specs (it reports it as a pass)"")
it(""does not treat an it() statement without a body as a skip/pending (but reports a pass result)"")
xit(""does not report a result at all for skipped specs"")
})
. . .
0 examples, 0 failures.
This should read
.---
4 examples, 0 failures, 3 pending.
I think a more consistent approach is to always report a result result for a spec whether it has expectations or not, and whether it was skipped or not. It's up to the view to decide how/if it wants to render it.
Also, I think that it() without a body should call xit() and behave just like",cowboyd,NONE,2010-06-04 10:02:31+00:00,True,2011-01-26 20:41:20+00:00,236.44,,4,7,2010-08-07 17:44:55+00:00,64.32,infews,CONTRIBUTOR,0,1,0,3,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
9,Rails 3 support?,"Does jasmine currently support rails 3?  When I try and run 'rails generate jasmine' I get the error of:
Could not find generator jasmine.
Any help is greatly appreciated.",jstreb,NONE,2010-06-15 20:18:49+00:00,True,2011-01-26 20:41:54+00:00,225.02,,4,4,2010-06-16 13:34:45+00:00,0.72,ragaskar,CONTRIBUTOR,0,2,0,1,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
10,WaitsForBlock sometimes doesn't,"My tests are hanging when I use waitsFor.
Here's a failing test you can add to WaitsForBlockSpec.js, under describe(""if latchFunction returns false"":
it('spec should fail with the passed message', function () {
  spyOn(spec, 'fail');
  var block = new jasmine.WaitsForBlock(env, 100, function() {return false}, message, spec);
  block.execute(onComplete);
  waits(150)
  expect(spec.fail).toHaveBeenCalled();
  var failMessage = spec.fail.mostRecentCall.args[0].message;
  expect(failMessage).toMatch(message);
  expect(onComplete).wasNotCalled();
});",rhunter,NONE,2010-07-09 02:15:08+00:00,True,2010-07-13 03:52:08+00:00,4.07,,2,2,2010-07-09 03:04:57+00:00,0.03,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
11,toString fails in IE8 sometimes,"We have an edge case where on a failing spec there is no ""toString"" method on a property.
In order to test it feel free to pull http://github.com/mootools/mootools-core - init all submodules and open the Specs folder in IE from a local server.
Replacing the line http://github.com/pivotal/jasmine/blob/master/lib/jasmine.js#L847 with the code below fixes the issue:
  mismatchValues.push(""'"" + property + ""' was '"" + (b[property] ? jasmine.util.htmlEscape(b[property].toString ? b[property].toString() : '' + b[property]) : b[property]) + ""' in expected, but was '"" + (a[property] ? jasmine.util.htmlEscape(a[property].toString ? a[property].toString() : '' + a[property]) : a[property]) + ""' in actual."");",cpojer,NONE,2010-08-30 11:13:16+00:00,True,2011-01-26 20:45:29+00:00,149.4,,3,2,2010-08-31 22:18:56+00:00,1.46,fabiomcosta,CONTRIBUTOR,0,2,0,0,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
12,jasmine-gem: don't load json/pure,"I've added Jasmine gem to my app recently; I'm also using Resque. The problem is, Resque requires plain json, and Jasmine requires json_pure. So I've got two JSONs now in my project, which causes several warning messages and some failing tests...
Second problem is that even if I remove Resque, json_pure is still loaded twice, because ActiveSupport loads it once as require 'json' and then Jasmine loads it again as require 'json/pure'.
The solution to the second problem is to change require 'json/pure' to require 'json' in Jasmine. The json_pure gem will still be loaded because it will be in the Gemfile, but it won't be loaded twice.
A better, long term solution would be to switch to the multi_json gem in code and in gemspec (http://github.com/intridea/multi_json). If both Jasmine and Resque used that, I could choose any json backend I want and it would work with both.",mackuba,NONE,2010-09-01 12:05:40+00:00,True,2010-09-01 21:15:44+00:00,0.38,,2,3,2010-09-01 12:49:43+00:00,0.03,mackuba,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
13,jasmine gem doesn't work with rspec 2,"Error: ""no such file to load -- spec""",mackuba,NONE,2010-09-06 12:34:45+00:00,True,2010-09-30 16:48:02+00:00,24.18,,3,2,2010-09-07 00:02:01+00:00,0.48,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
15,Bug on toContains,"You should be able to expect an array-like object (like the return on getElementsByTagName) to contain something. I monkey-patched jasmine to make it work, but its clearly a bug. See here:
http://github.com/fabiomcosta/slick/blob/master/SlickSpec/assets/JSSpecHelpers.js#L39-72
Good job so far! We're using on most of mootool's  projects.",fabiomcosta,CONTRIBUTOR,2010-09-14 00:34:20+00:00,True,2013-05-26 19:09:26+00:00,985.77,,4,3,2010-09-14 01:03:41+00:00,0.02,xian,CONTRIBUTOR,0,2,0,1,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
16,jasmine-gem: Flexible path to jasmine.yml,"jasmine-gem
It would be great if jasmine.yml could be loaded using a Dir glob string (""**/jasmine.yml"") from the project root or from an environment variable (as mentioned by Rajan in the google group) so that any folder structure is supported.",,NONE,2010-09-14 18:25:58+00:00,True,2010-10-13 21:06:47+00:00,29.11,,0,1,2010-10-13 21:06:47+00:00,29.11,,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
17,this pointer is reset to window,"var TestObject = {
methodA: function() {},

methodB: function() {  this.methodA();  }
};
....
describe('....', function() {
var A = TestObject.A,B = TestObject.B;

it('....', function() {
    B();
});

});
will throw error in 'methodB: function() {  this.methodA();  }', because ""this"" is pointed to window!
looking forward to fix it quickly! thx!",lifesinger,NONE,2010-09-25 06:23:01+00:00,True,2010-09-26 08:21:02+00:00,1.08,,2,3,2010-09-25 21:07:58+00:00,0.61,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
19,this pointer is wrong,"Reopen for the accident closed #issue17
I have created a test page:
http://lifesinger.github.com/lab/2010/jasmine-issue17-test.html
Jasmine reports error:
TypeError: Object [object DOMWindow] has no method 'methodA'
If I change line25 to:
expect(TestObject.methodB()).toBe('a');
All will be ok.
But in my actual test code, I want to define methodB = TestObject.methodB to save some typing.
I expect jasmine don't change ""this"" to window, it's annoying:(
Waiting for you answer ^o^",lifesinger,NONE,2010-09-30 01:18:35+00:00,True,2010-10-01 07:16:42+00:00,1.25,,2,2,2010-10-01 00:16:42+00:00,0.96,,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
20,Strange error output,"Test:
it(""should report a strange error"", function(){
spyOn(TestMe, 'saySomething');
TestMe.saySomething('a string', {goodbye: 'world'});
expect(TestMe.saySomething).toHaveBeenCalledWith('a string', {hello: 'world'});
});
Supporting class (using jQuery):
(function($) {
TestMe = {};
TestMe.saySomething = function(aString, aHash) {
alert(aString);
};
}(jQuery));
When I run the test I get the following output:
Expected spy to have been called with [ 'a string', { hello : 'world' } ] but was called with [ [ 'a string', { goodbye : 'world' } ] ]
I would expect the failure and it is easy to see why this test fails when you have a short string of failure text...what I wouldn't expect was the ""[["" ""]]"" around the stuff that the method was actually called with.
If you have a big error message then you get caught up on the [[ ]] and lose sight that you are calling the method with the wrong arguments.
Is there a reason that when you mess up a toHaveBeenCalledWith() expectation you get the [[ ]] instead of [ ]?",mikegehard,NONE,2010-10-01 21:02:58+00:00,True,2011-06-19 03:36:40+00:00,260.27,,3,1,2010-10-01 21:32:05+00:00,0.02,,NONE,0,0,0,1,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
21,Builtin support node.js,"The project you mention on the docs site is very outdated. I published a fork with a simple example, but it would be nice to have it out of the box, and supported on the latest version.",danielribeiro,NONE,2010-10-04 00:36:04+00:00,True,2011-01-28 05:55:51+00:00,116.22,,2,1,2011-01-28 05:55:48+00:00,116.22,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
22,combine jasmine-gem into this repository,"When I first started checking out Jasmine, I grabbed the repo, and was delayed a bit when I noticed that I didn't have the gem included.  How about combining the two, just carefully leaving files that don't belong in the gem out of the gemspec? This repo already includes things that aren't part of the core, like the javascript documentation.
If part of it is that you plan to have support for other server-side languages in the future, I think having ruby at the root would still be the way to go. That way, if a python implementation got added, a rake task for running the python tasks (including tests) could be added. That way, someone who wanted to maintain consistency among the alternate implementations could easily run tests on both, and someone who's just into python could cd to that directory and build the egg. (Using this scheme, a python implementation of the server-side component could be in a separate repo using submodules, or not. Pythonistas would have to check out jasmine with the submodules to get the javascript code and documentation, and the Python build files would include references to code in the outer repo. For example, if the gem were in python/, it would copy ../src/*.js into its build directory. It would also tell users to get the outer gem if it didn't find it in the parent directory.)
Finally, something that could be done right away to make things easier: add a homepage on github to jasmine-gem (currently it's empty), so people browsing to it can go straight to the page about jasmine, without scrolling down:
http://github.com/pivotal/jasmine-gem",benatkin,NONE,2010-10-05 20:29:07+00:00,True,2011-01-26 19:43:06+00:00,112.97,,4,6,2010-10-05 22:03:51+00:00,0.07,jfirebaugh,NONE,0,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
24,right: 100% on #jasmine_content hiding doesn't work for common layout choices,"Particularly, but not exclusively in IE7 with 100% width with floats.  Just using right: 200% seems to take care of some of that.",knzconnor,NONE,2010-10-15 18:28:56+00:00,True,2011-01-27 04:40:06+00:00,103.42,,2,2,2011-01-26 20:40:06+00:00,103.09,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
27,support multiple config file,"we should be able to support different config file when initializing
Jasmine::Config.new
perhaps something like
rake jasmine CONFIG=different_config_file_rather_than_jasmine.yml
This will be very useful to test a subset of js files without having to load all the javascript files all the time.",trungpham,NONE,2010-11-02 22:13:21+00:00,True,2011-06-19 03:34:35+00:00,228.22,,2,2,2011-06-19 03:34:35+00:00,228.22,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
28,rake jasmine:ci not exiting with proper exit code,it is exiting with 0 code on failures also. which is making the CI server function incorrectly.,arusarka,NONE,2010-11-10 06:03:07+00:00,True,2010-11-10 14:42:40+00:00,0.36,,3,3,2010-11-10 06:42:40+00:00,0.03,infews,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
30,Request: JsApiReporter: Add execution time elapsed,"The TrivialReporter displays the total execution time following the test run, but so far as I can discern, this info isn't available from the JsApiReporter. It'd be great to have this for users of the jasmine-maven-plugin, who are now seeing Jasmine test reports gathered by their CI environments; this information would enable them to track execution time of Jasmine specs over time.",searls,NONE,2010-11-18 21:56:14+00:00,True,2013-05-26 19:11:35+00:00,919.89,,2,1,2013-03-06 05:31:21+00:00,838.32,infews,CONTRIBUTOR,0,1,0,0,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
31,"Private repo URL for submodule ""pages""","Is there a reason the ""pages"" subproject uses a private repo URL?  Makes it a pain to build pages when using jasmine as a submodule.",kflorence,NONE,2010-11-20 02:07:31+00:00,True,2011-01-28 13:51:36+00:00,69.49,,2,4,2010-11-20 15:42:34+00:00,0.57,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
32,Ability to spy on functions multiple times.,"Right now, Jasmine does not allow me to set up multiple spies on the same function.  For instance, given some constructor:
NavNet.Controller.LoginController = function LoginController (navNet) {
   this.loginService = navNet.getService(""loginService"");    
   this.storageService = navNet.getService(""storageService"");
};

My spy setup would looks something like this:
...

beforeEach(function() {
        framework = new NavNet();
        loginService = new NavNet.Services.LoginService();
        storageService = new NavNet.Services.StorageService();

        spyOn(framework, ""getService"").andReturn(loginService);
        spyOn(framework, ""getService"").andReturn(storageService);

        sut = new NavNet.Controllers.LoginController(framework);
    });

...

Maybe not the best example, as I actually inject the services I need, but it illustrates a point: the second spy on ""getService"" will fail as Jasmine will complain that ""getService"" is already being spied on. Fair enough. It would be nice if I was able to set up spies on multiple function calls, differentiated by parameters.  Maybe something like:
spyOn(framework, ""getService"").with(""loginService"").andReturn(loginService);

Unless, of course, there is a way I am unaware of that will accomplish this >8)",Ireney,NONE,2010-11-23 01:41:26+00:00,True,2010-11-23 21:16:39+00:00,0.82,,5,6,2010-11-23 01:48:39+00:00,0.01,infews,CONTRIBUTOR,1,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
33,"Test window jumps when I hit ""command""","I'm running Jasmine 1.0.1.1 in Chrome 8.0.552.215 on OSX.
Every time I hit the ""command"" key when the Jasmine tab has focus (e.g. in order to command-tab out of the window) the view pops out of the browser to the top-left of my screen, then returns.",jamesarosen,NONE,2010-12-03 22:48:18+00:00,True,2011-06-19 03:36:01+00:00,197.2,,2,2,2011-06-19 03:36:01+00:00,197.2,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
35,toHaveBeenCalledWith fails with multiple arguments,"First attempt:
spyOn(Foo, 'bar');
Foo.bar('baz', 'qux');
expect(Foo.bar).toHaveBeenCalledWith('baz', 'qux');

Expected spy to have been called with [ [ 'baz', 'qux' ] ] but was called with [ 'baz', 'qux' ].
Second attempt:
spyOn(Foo, 'bar');
Foo.bar('baz', 'qux');
expect(Foo.bar).toHaveBeenCalledWith(['baz', 'qux']);

Expected spy to have been called with [ [ 'baz', 'qux' ] ] but was called with [ [ 'baz', 'qux' ] ].
I believe the problem is that Jasmine is using a simple == or === comparison, rather than comparing the elements of arguments individually.",jamesarosen,NONE,2010-12-14 23:48:12+00:00,True,2010-12-14 23:56:39+00:00,0.01,,2,4,2010-12-14 23:50:35+00:00,0.0,jamesarosen,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
36,Blank page after running tests.,"Visiting the test page for a running Jasmine server displays test results briefly (for about half a second), then the entire page goes blank.",,NONE,2010-12-15 01:20:24+00:00,True,2010-12-15 12:34:34+00:00,0.47,,3,2,2010-12-15 04:34:34+00:00,0.13,infews,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
37,Add instance mocks,"I'd like to be able to mock out an object created via new. Perhaps something like
mockClass('Image');
var i = new Image();
i.src = '/some_url';
expect(Image.lastInstance().src).toEqual(""/some_url"");

or maybe
mockClass(Vehicle, 'Car');
var c = new Vehicle.Car();
c.start();
expect(Vehicle.Car.anyInstance().start).toHaveBeenCalled();

I might also imagine being able to access the original definition of the ""class"" (function) via StubbedFunction.originalDefinition.",jamesarosen,NONE,2010-12-15 21:06:05+00:00,True,2011-01-28 05:42:12+00:00,43.36,,2,1,2011-01-28 05:42:12+00:00,43.36,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
40,global spyOn does not accept / honor ignoreMethodDoesntExist,"jasmine.Spec.prototype.spyOn accepts three parameters: obj, methodName, ignoreMethodDoesntExist
global spyOn function only accepts two parameters: obj, methodName
So if one wishes to spy on a non-existent method, one may not use the global spyOn method but must instead grab and directly call jasmine.getEnv().currentSpec.spyOn",bloveridge,NONE,2010-12-28 17:41:23+00:00,True,2011-01-28 05:59:47+00:00,30.51,,2,2,2011-01-28 05:59:03+00:00,30.51,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
45,toHaveBeenCalledWith does not succeed on correct response (or error is incorrect),"Test:
echo.events.trigger(""NAME_REPLY"", {command: ""NAME_REPLY"", args: [""wr:1"",
  {""1"":{""user_id"":""1"",""mode"":{""v"":1},""attendee_id"":""67""},
   ""2"":{""user_id"":""29"",""mode"":{""v"":1},""attendee_id"":""1""}}
  ]});

expect(aRoom.listUI.add).toHaveBeenCalledWith([""1""], [""29""]);

Output:
Failed: A Room Controller loads users and their states on NAME_REPLY.
Expected spy to have been called with [ [ '1' ], [ '29' ] ] but was called with [ [ '1' ], [ '29' ] ]
in http://127.0.0.1:53446/jasmine/jasmine.js:94",plukevdh,CONTRIBUTOR,2011-01-19 16:58:18+00:00,True,2013-10-02 00:41:12+00:00,986.32,1.2,7,12,2011-01-19 17:07:54+00:00,0.01,ragaskar,CONTRIBUTOR,1,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
47,"jasmine init ""sinatra app""","hugo@hugo-desktop:~/bakedchat$ jasmine init
/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb:31:in gem_original_require': no such file to load -- padrino-core/cli/rake (LoadError) from /usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb:31:inrequire'
from /home/hugo/bakedchat/Rakefile:4
from /home/hugo/.rvm/gems/ree-1.8.7-2010.02@chat/gems/jasmine-1.0.1.1/lib/jasmine/command_line_tool.rb:48:in load' from /home/hugo/.rvm/gems/ree-1.8.7-2010.02@chat/gems/jasmine-1.0.1.1/lib/jasmine/command_line_tool.rb:48:inprocess'
from /home/hugo/.rvm/gems/ree-1.8.7-2010.02@chat/gems/jasmine-1.0.1.1/bin/jasmine:6
from /home/hugo/.rvm/gems/ree-1.8.7-2010.02@chat/bin/jasmine:19:in `load'
from /home/hugo/.rvm/gems/ree-1.8.7-2010.02@chat/bin/jasmine:19",hugoerg56,NONE,2011-01-29 04:39:59+00:00,True,2011-01-29 07:03:19+00:00,0.1,,2,1,2011-01-29 07:03:19+00:00,0.1,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
48,afterEach is called twice before an async test is run,"An example can be found in the JustKidding project. I will try to reduce the issue to a smaller test case, but for now,

clone git://github.com/jamesarosen/JustKidding.git
check out e5f894168eed8c010ddf286d5d712123a1c6f6d9
run just the group ""when there are more elements...""

Console output has to ""afterEach"" statements first, then a ""beforeEach"" statement, then an ""it"" statement.",jamesarosen,NONE,2011-01-30 17:00:07+00:00,True,2011-06-19 03:26:43+00:00,139.44,,2,3,2011-01-30 17:13:55+00:00,0.01,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
49,Code Coverage,It would be immensely helpful if Jasmine had a way to generate code coverage reports. Is anything like this planned for the future?,pigulla,NONE,2011-01-31 11:02:25+00:00,True,2011-01-31 17:02:26+00:00,0.25,,5,4,2011-01-31 17:02:26+00:00,0.25,infews,CONTRIBUTOR,0,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
50,Generated rake-Tasks should ignore missing Jasmine,"Hi there,
the generated rake task loading the Rake tasks from Jasmine should not throw an exception if it is unable to load jasmine.
In production environments you often have a ""test""-group in your Gemfile, with gems not installed. Though you still want to use rake for Cronjobs and stuff.
You should generate the File like this:
begin
require 'jasmine'
load 'jasmine/tasks/jasmine.rake'
rescue LoadError
puts ""jasmine not found""
end
Best, Tobias",tobsch,NONE,2011-02-01 11:54:37+00:00,True,2011-06-25 19:20:52+00:00,144.31,1.2,4,3,2011-03-03 14:17:26+00:00,30.1,lbadura,NONE,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
51,Jasmine does not clear scheduledFunctions between mock clock invocations,"Hi guys,
We noticed yesterday that between invocation of jasmine.Clock.useMock(), Jasmine does not reset the list of scheduledFunctions.  This was the cause of some test pollution for us, where things scheduled in previous tests were still running in later tests.
To see the bug, in useMock(), output the list of scheduledFunctions.  You'll see that functions scheduled in previous tests are still pending execution.
We worked around this by adding to our SpecHelper.js:
afterEach(function () {
// Jasmine's mock clock does not remove scheduled functions between specs,
// which allows for test pollution.
jasmine.Clock.defaultFakeTimer.reset();
});
...although the real fix is probably to ensure FakeTimer.reset gets called at each useMock.
Thanks!
Rob",rslifka,NONE,2011-02-04 16:57:39+00:00,True,2011-02-04 21:13:40+00:00,0.18,,3,3,2011-02-04 21:13:40+00:00,0.18,infews,CONTRIBUTOR,0,1,0,1,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
52,json test fails under 1.9.2,"Running tests under  rvm 1.8.7@jasmine-gem and rvm 1.9.2@jasmine-gem, with a fresh bundle install under each. All tests pass under 1.8.7, but the json_pure test fails under 1.9.2:
Failures:

Jasmine bug fixes require 'json_pure' should not happen until SeleniumDriver is initialized, which is late enough that it won't conflict with Rails
Failure/Error: json_is_defined.chomp.should == ""nil""
expected: ""nil"",
got: """" (using ==)
./spec/bug_fixes_spec.rb:19:in `block (3 levels) in <top (required)>'",claco,NONE,2011-02-06 04:07:31+00:00,True,2011-06-19 16:31:08+00:00,133.52,,3,4,2011-06-19 03:41:10+00:00,132.98,infews,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
53,Reporter resultsForSpecs reports specs as passed even when skipped,"Via the rspec runner in the gem project, it appears that when you run a specific subset set of specs via the ?spec= query string param, even though the page lists ""1 spec run, 0 failed"", the resultsForSpec/s returns all other specs marked as passed, even though they were not run at all.",claco,NONE,2011-02-06 21:39:06+00:00,True,2013-03-06 05:38:07+00:00,758.33,1.2,2,5,2011-06-19 03:45:27+00:00,132.25,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
58,"""jasmine init"" deleted my code","I had an /app with some javascript code I was starting to cover with jasmine specs.
When I wrote ""jasmine init"" in the project folder, it had deleted /app content.
Is this supposed to do so?",rodrigues,NONE,2011-02-19 17:43:01+00:00,True,2011-02-20 01:46:50+00:00,0.34,,1,1,2011-02-19 17:46:50+00:00,0.0,rodrigues,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
59,"""jasmine init"" deleted my code","I had an /app with some javascript code I was starting to cover with jasmine specs.
When I wrote ""jasmine init"" in the project folder, it had deleted /app content. And it had deleted the .git folder also...
Is this supposed to do so?",rodrigues,NONE,2011-02-19 17:49:23+00:00,True,2011-02-19 17:51:45+00:00,0.0,,1,1,2011-02-19 17:51:45+00:00,0.0,rodrigues,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
60,expect({ f: function(){} }).toEqual({ f: function(){} }) fails and it shouldn't,"Granted, I'm not certain if the function bodies should have to be identical (I could see test cases wanting it to go either way), but in this case they are and that definitely seems incorrect.",paxunix,NONE,2011-02-20 23:28:24+00:00,True,2011-02-21 13:52:11+00:00,0.6,,2,2,2011-02-21 05:52:11+00:00,0.27,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
61,"declarationError is lost; instead I get the error ""jasmine.Suite() required""","If I have my own js error inside my describe, it is lost and instead I get the error ""jasmine.Suite() required""
My simple test:
describe('my own js error', function() {
    var foo = nonExistent.obj;
    it('should throw my error', function() {
    });
});

in jasmine, it is in this block:
jasmine.Env.prototype.describe = function(description, specDefinitions) {
    var suite = new jasmine.Suite(this, description, specDefinitions, this.currentSuite);

    var parentSuite = this.currentSuite;
    if (parentSuite) {
        parentSuite.add(suite);
    } else {
        this.currentRunner_.add(suite);
    }

    this.currentSuite = suite;

    var declarationError = null;
    try {
        specDefinitions.call(suite);
    } catch(e) {
        declarationError = e;
    }

    this.currentSuite = parentSuite;

    if (declarationError) {
        this.it(""encountered a declaration exception"", function() {
            throw declarationError;
        });
    }
    return suite;
};

==> I get into the if (declarationError) block at the end of this implementation, but within there, this.it('encountered...') tries to create a new spec, which has no currentSuite, which causes the error in my subject line.",btmurrell,NONE,2011-02-23 18:41:29+00:00,True,2013-05-26 19:35:15+00:00,823.04,,5,7,2011-05-17 18:47:25+00:00,83.0,db48x,NONE,0,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
65,Conditionals for describe or it,"I'd like to see conditionals for skipping tests to be attached to the it or describe functions. The reason would be to enable testing on parameters that can't be set by JavaScript (such as navigator.locale), but requires environmental changes (outside the scope of JavaScript). One such example would be to test L10n or i18n issues.
This could be solved with letting it or describe have a builder method (such as when). Here is one example that tests with turkish 'i':
function itIsTurkishLocale() {
    return navigator.language == 'tu';
}

it('should pass the Turkish test', function() {
    var result = myObj.doIt(upperCaseDottedEye);
    expect(result).toEqual(lowerCaseDottedEye);
}).when(itIsTurkishLocale);

The function when should be able to take on either a conditional (true/false) or a function that can return a conditional. If the conditional is true, the test should run. If it is false, it should skip.",spoike,NONE,2011-02-28 13:29:10+00:00,True,2011-02-28 22:25:50+00:00,0.37,,2,6,2011-02-28 14:25:50+00:00,0.04,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
77,Stackoverflow  error,"Hi
I am getting Exceeded stack depth error while executing the maven targets (test).  I dont have any clue what is happening.  Could you please point in the right direction.
com.gargoylesoftware.htmlunit.javascript.StrictErrorReporter runtimeError
SEVERE: runtimeError: message=[Exceeded maximum stack depth] sourceName=[script
in file:/C:/oasisNew/target/jasmine/SpecRunner.html from (173, 33) to (2594, 11)
] line=[2565] lineSource=[null] lineOffset=[0]
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ------------------------------------------------------------------------
[INFO] : java.lang.RuntimeException: com.gargoylesoftware.htmlunit.ScriptExcepti
on: Exceeded maximum stack depth (script in file:/C:/oasisNew/target/jasmine/Spe
cRunner.html from (173, 33) to (2594, 11)#2565)
There was a problem executing Jasmine specs
com.gargoylesoftware.htmlunit.ScriptException: Exceeded maximum stack depth (scr
ipt in file:/C:/oasisNew/target/jasmine/SpecRunner.html from (173, 33) to (2594,
Regards",noris,NONE,2011-03-18 18:52:55+00:00,True,2013-03-06 05:49:57+00:00,718.46,,3,3,2011-04-20 15:30:32+00:00,32.86,jonnywyatt,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
79,specify a message when a custom matcher fails,"I have a immutable Value Object class:´
var Tile = function(x, y) {
    this.x = function() { return x }
    this.y = function() { return y }
}

and a matcher for it:
function toEqualToTile(expected) {
    return (this.actual.x() == expected.x()) && (this.actual.y() == expected.y())
}

If the custom matcher fails, I get this message:
Expected { x : Function, y : Function } to equal to tile { x : Function, y : Function }.
which is not very informative. Could you add a possibility to specify my own message on failure?",mgryszko,NONE,2011-03-24 11:00:02+00:00,True,2011-03-24 11:31:52+00:00,0.02,,4,4,2011-03-24 11:12:36+00:00,0.01,bostanio,NONE,0,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
80,Misleading error message for string expectation,"The test below is reporting a misleading failure:
""Expected spy to have been called with [ 'bar' ] but was called with [ [ 'baz' ] ]""
This implies that we called someFunction(['baz']) when actually we called someFunction('baz');
TEST:
it('should properly compare strings', function(){
  var test = { foo: function(){} };
  spyOn(test, 'foo');

  test.foo('baz');
  expect(test.foo).toHaveBeenCalledWith('bar'); 
});

STACK TRACE:
Error(""Expected spy to have been called with [ 'bar' ] but was called with [ [ 'baz' ] ]"")@:0 ([object Object])@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:94 (""bar"")@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1143 ()@http://localhost:8888/__spec__/javascripts/views/creatives/markup/_facebook_like_spec.js:49 ((function () {if (jasmine.Queue.LOOP_DONT_RECURSE && calledSynchronously) {completedSynchronously = true;return;}if (self.blocks[self.index].abort) {self.abort = true;}self.offset = 0;self.index++;var now = (new Date).getTime();if (self.env.updateInterval && now - self.env.lastUpdate > self.env.updateInterval) {self.env.lastUpdate = now;self.env.setTimeout(function () {self.next_();}, 0);} else {if (jasmine.Queue.LOOP_DONT_RECURSE && completedSynchronously) {goAgain = true;} else {self.next_();}}}))@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:968 ()@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1739 ((function () {spec.finish(onComplete);}))@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1692 ((function () {if (jasmine.Queue.LOOP_DONT_RECURSE && calledSynchronously) {completedSynchronously = true;return;}if (self.blocks[self.index].abort) {self.abort = true;}self.offset = 0;self.index++;var now = (new Date).getTime();if (self.env.updateInterval && now - self.env.lastUpdate > self.env.updateInterval) {self.env.lastUpdate = now;self.env.setTimeout(function () {self.next_();}, 0);} else {if (jasmine.Queue.LOOP_DONT_RECURSE && completedSynchronously) {goAgain = true;} else {self.next_();}}}))@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:2018 ()@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1739 ((function () {self.finish(onComplete);}))@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1692 ((function () {if (jasmine.Queue.LOOP_DONT_RECURSE && calledSynchronously) {completedSynchronously = true;return;}if (self.blocks[self.index].abort) {self.abort = true;}self.offset = 0;self.index++;var now = (new Date).getTime();if (self.env.updateInterval && now - self.env.lastUpdate > self.env.updateInterval) {self.env.lastUpdate = now;self.env.setTimeout(function () {self.next_();}, 0);} else {if (jasmine.Queue.LOOP_DONT_RECURSE && completedSynchronously) {goAgain = true;} else {self.next_();}}}))@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:2163 ()@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1739 ()@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1735 ((function () {if (jasmine.Queue.LOOP_DONT_RECURSE && calledSynchronously) {completedSynchronously = true;return;}if (self.blocks[self.index].abort) {self.abort = true;}self.offset = 0;self.index++;var now = (new Date).getTime();if (self.env.updateInterval && now - self.env.lastUpdate > self.env.updateInterval) {self.env.lastUpdate = now;self.env.setTimeout(function () {self.next_();}, 0);} else {if (jasmine.Queue.LOOP_DONT_RECURSE && completedSynchronously) {goAgain = true;} else {self.next_();}}}))@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:2120 ()@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:2164 ()@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1749 (49)@http://localhost:8888/__JASMINE_ROOT__/lib/jasmine.js:1729",webdev,NONE,2011-03-24 18:47:06+00:00,True,2011-06-19 03:56:21+00:00,86.38,,2,1,2011-06-19 03:56:21+00:00,86.38,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
84,Incorrect Rails dependency,"Should require 'railties' as dependency instead of 'rails', as the latter pulls in ActiveRecord, ActiveResource, and ActionMailer, none of which I need or want.",CodeMonkeySteve,NONE,2011-04-12 00:30:44+00:00,True,2011-04-15 12:09:59+00:00,3.49,,2,4,2011-04-15 01:05:37+00:00,3.02,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
85,CruiseControl build is broken but passing,"This build, for example, is broken, but passing.
http://cibuilder.pivotallabs.com:3333/builds/Jasmine/dfea6d1c716a7d7f3465a19219e0d0cfadc3bd55.1
All the builds listed seem to have broken, but still act like they are passing.  Build is returning the wrong error code, perhaps?",paulbellamy,NONE,2011-04-15 09:52:55+00:00,True,2011-04-15 12:09:31+00:00,0.09,,2,1,2011-04-15 12:09:31+00:00,0.09,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
86,CoffeeScript and Rails integration (possibly with Barista),"Hi, I was wondering if there's any way to integrate Jasmine with CoffeeScript (and, possibly with Barista, Rails CoffeeScript support gem) and write tests in CoffeeScript rather than javascript without too much of a headache? Would appreciate if you point me to the right direction.",snitko,NONE,2011-04-17 11:05:30+00:00,True,2011-04-17 14:11:55+00:00,0.13,,2,4,2011-04-17 12:28:27+00:00,0.06,netzpirat,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
87,waitsFor argument order ,"An obviously minor issue, but for consistency with it and describe, and for more fluent reading, shouldn't the argument order of waitsFor be:
waitsFor('async operation to finish', function () {
  // code
}, 1000);",dvtng,NONE,2011-04-18 04:43:20+00:00,True,2011-06-19 03:59:15+00:00,61.97,,2,1,2011-06-19 03:59:15+00:00,61.97,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
88,Spy.andCallThrough should be default behaviour,"I don't see the point in having to explicitly state that a spy should call the wrapped method. I stepped into this trap by assuming it was the default behaviour - which it is not. In my opinion, having a spy on a method should not change the program flow by default, but just cache arguments etc. as it already does.",maenu,NONE,2011-04-20 19:37:04+00:00,True,2013-03-06 05:51:35+00:00,685.43,2.0,17,19,2011-04-25 19:48:17+00:00,5.01,fabiomcosta,CONTRIBUTOR,0,2,0,15,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
89,Add the function properties to the spy object,"Jasmine should add the properties from the function being spied to the spy object.
Example:
// my code

obj = {};
obj.method = function(){
  console.log('im gonna be spied');
};
obj.method.property = true;

// inside an it

spyOn(obj, 'method');
expect(obj.method.property).not.toBeUndefined();
Currently this property is being undefined, but it should be true, as i set.
I've made the fix, but its not on my fork.
Will work on creating the fix and specs for this.",fabiomcosta,CONTRIBUTOR,2011-04-20 22:34:33+00:00,True,2011-06-19 04:02:43+00:00,59.23,1.2,2,1,2011-06-19 04:02:43+00:00,59.23,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
91,Documentation bug,"There is a typo in example in the documentation on spy
http://pivotal.github.com/jasmine/jsdoc/symbols/jasmine.Spy.html
andCallFake(fakeFunc)
Calls an alternate implementation when a spy is called.
var baz = function() {
// do some stuff, return something
}
// defining a spy from scratch: foo() calls the function baz
var foo = jasmine.createSpy('spy on foo').andCall(baz);
// defining a spy on an existing property: foo.bar() calls an anonymnous function
spyOn(foo, 'bar').andCall(function() { return 'baz';} );
The example uses '.andCall' it should be '.andCallFake' instead",georges,NONE,2011-04-27 16:47:43+00:00,True,2011-06-19 04:04:14+00:00,52.47,1.2,2,1,2011-06-19 04:04:14+00:00,52.47,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
92,Allow disabling of error catching (useful for bad stacktrace browsers),"It would be nice to be able to conditionally turn off error catching while trying to debug errors - for instance when trying to figure out an error in anything other than FireFox. ;)
https://github.com/pivotal/jasmine/blob/master/lib/jasmine.js#L979",knzconnor,NONE,2011-04-27 19:27:47+00:00,True,2011-06-19 15:29:07+00:00,52.83,,5,9,2011-06-02 05:10:17+00:00,35.4,infews,CONTRIBUTOR,0,1,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
94,"spyOn(obj, ""method"").withArgs(""a"", ""b"").andReturn(""c"")","RSpec stubs let you specify return values for specific invocations.  It would be nice if spyOn could do the same thing.  The current workaround is to use andCallFake with a big conditional:
spyOn(obj, ""method"").andCallFake(function(a, b) {
  if (a == ""a"" && b == ""b"") {
    return ""c"";
  } else {
    throw ""Unexpected arguments for method()""
  }
}

which is a lot of boilerplate once you use it a few times.",Peeja,NONE,2011-05-15 16:45:16+00:00,True,2011-06-19 04:06:57+00:00,34.47,,9,9,2011-05-15 17:49:58+00:00,0.04,infews,CONTRIBUTOR,1,1,0,6,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
95,createSpyObj should not require a list of spys,"Sometimes I need to create a test double which doesn't have any stubs or mocks.  I'd like to use the same interface for those.  It would be nice if jasmine.createSpyObj(""Article"") would not raise an error, and simply give me a unique test double.
Since the object isn't spying on anything, it might also be a good idea to change the name to jasmine.double() to match RSpec.",Peeja,NONE,2011-05-15 17:02:53+00:00,True,2011-05-15 17:35:38+00:00,0.02,,2,2,2011-05-15 17:35:38+00:00,0.02,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
97,Jasmine website bugs,"hi
on the http://pivotal.github.com/jasmine/ page, there is a link to
Node.js, but it has a 'e' on http:// so the link obviously doesn't
work because there is no such thing as httpe://
httpe://nodejs.org
it should be http://
also the ""fork me on github"" doesn't work",diegoviola,NONE,2011-05-28 03:47:31+00:00,True,2011-06-19 03:21:14+00:00,21.98,,2,1,2011-06-19 03:21:14+00:00,21.98,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
99,Online API docs' _global_ section link broken,"API docs => click global (http://pivotal.github.com/jasmine/jsdoc/symbols/_global_.html) => ""Page does not exist!""",ekantola,NONE,2011-06-15 12:31:12+00:00,True,2013-03-27 06:11:32+00:00,650.74,1.2,7,7,2011-06-20 06:00:08+00:00,4.73,infews,CONTRIBUTOR,0,1,0,5,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
103,"Missed test results when using ""wait"" and ""runs""","I am using jasmine 1.0.2 combined with jsTestDriver.
I have a test case which looks a bit like:
describe('My unit test', function() {
    beforeEach(function() {
        // Initialize environment
    });

    describe('Tests', function() {

        it('can do test 1', function() {
            doSomething();
            wait(100);
            runs(function() {
                expect(myTest).toBeTruthy();
            });
        });

        it('can do test 2', function() {
            doSomething();
            wait(100);
            runs(function() {
                expect(myTest).toBeTruthy();
            });
        });
   });
});
What happens now are 2 problems. As soon as 'can do test 1' has called 'runs()', then the test ends, the beforeEach() is called for 'can do test 2'. However, the expect for 'can do test 1' has not been executed yet, and actually fails because the beforeEach reinitializes the environment. So apparently using an expect() call in 'runs()' will not work correctly.
The second problem, makes things even worse. Namely, the expect() call in 'can do test 1' fails (because of the enviroment which has changed). But this is only reported in the Browser console (as Uncaught AssertError), but not in the test results which are reported from jsTestDriver, so when you have a lot of tests it is quite easy to fail to see the unit tests were actually failing because of problem 1.",,NONE,2011-06-23 07:58:40+00:00,True,2013-03-06 06:02:04+00:00,621.92,,2,3,2011-07-19 08:23:32+00:00,26.02,,NONE,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
105,Node.js compatibility,"Please make Jasmine Node.js compatible.
I know there are some 3rd party libraries for this, but it would be better if it was built into the official release.
Thanks.",,NONE,2011-07-07 06:58:25+00:00,True,2011-07-08 02:25:17+00:00,0.81,,3,3,2011-07-08 00:04:31+00:00,0.71,timoxley,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
106,toHaveBeenCalledWith feature,"Hey guys,
I want to add a feature to allow a more javascript like behaviour on asserting the arguments on spy calls but I can't seem to settle on the name of this new expectation.
var foo = { bar: function (a, b, c) {} };

spyOn(foo, ""bar"");

foo.bar(1, 2, 3);

expect(foo.bar).toHaveBeenCalledWith(1, 2 ,3);  //will pass
expect(foo.bar).toHaveBeenCalledWith(1);        //will fail (would love if this passed)

It would be awesome if we could do something like:
expect(foo.bar).toHaveBeenCalledWithExactly(1);  // will fail
expect(foo.bar).toHaveBeenCalledWith(1);         // will pass

But that breaks the current functionality and would cause general chaos in existing tests.  So that leaves us the requirement of needing a new expectation name.  While I code this feature I was hoping some people would help me out with naming it.  Here are some ideas I have had quickly:
expect(foo.bar).toHaveBeenCalledLike(1);
expect(foo.bar).toHaveBeenCalled(1);     //allow arguments on toHaveBeenCalled?
expect(foo.bar).toHaveBeenCalledWithAtLeast(1, 2);",gtanner,NONE,2011-07-14 18:44:18+00:00,True,2011-07-23 20:11:06+00:00,9.06,,2,1,2011-07-23 20:11:06+00:00,9.06,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
107,Code Coverage,"Jasmine is a great JS test framework but it yields to not-so-great ones like jsTestDriver, Expresso because it is missing code coverage, which is a must have for any large project. Are there any plans to work on CC?
P.S. Iasked the same question in a post which (as I noticed later) was closed",vaustymenko,NONE,2011-07-15 17:37:40+00:00,True,2013-03-06 06:11:46+00:00,599.52,,4,3,2011-07-23 20:08:09+00:00,8.1,ragaskar,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
108,Jasmine and rails 3.1 asset pipeline,Jasmine 1.1.0rc3 still use the public/javascripts and not assets/javascripts,nguyenchiencong,NONE,2011-07-16 16:54:49+00:00,True,2011-07-16 17:00:35+00:00,0.0,,3,3,2011-07-16 19:36:28+00:00,0.11,infews,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
109,empty ul in the README,There's an empty ul in the README under What's Here?. I found it distracting.,benatkin,NONE,2011-07-18 04:06:57+00:00,True,2013-03-06 06:02:57+00:00,597.08,,2,1,2013-03-06 06:02:57+00:00,597.08,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
110,Jasmine ruby gem uses deprecated Gem.available?,"I just did a ""jamine init"" with Ruby 1.8.7, Gem 1.8.5 and Jamine Gem 1.0.2.1 with this result:
$ jasmine init
NOTE: Gem.available? is deprecated, use Specification::find_by_name. It will be removed on or after 2011-11-01.
Gem.available? called from /Users/ssc/.rvm/gems/ruby-1.8.7-p352/gems/jasmine-1.0.2.1/lib/jasmine/base.rb:64.
Jasmine has been installed with example specs.
...
Just as an info for you...
Keep up the great work!
Kind Regards
Stefan",stefanscheidt,NONE,2011-07-20 12:57:32+00:00,True,2011-07-20 13:11:38+00:00,0.01,,2,1,2011-07-20 13:11:38+00:00,0.01,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
113,Feature: init() and destroy(),"I need a way to init() things inside a describe for all the tests. Then when all the tests are run inside describe run destroy().
That would be very useful. YUITest has this kind of setup:
init()
destroy()
setUp() is equivalent to Jasmine's beforeEach()
tearDown is equivalent to Jasmine's afterEach()",,NONE,2011-07-26 10:02:41+00:00,True,2012-01-30 21:24:36+00:00,188.47,,3,4,2011-07-26 10:59:12+00:00,0.04,arian,NONE,0,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
114,Type matching array/object bug,"Hi there, I love Jasmine it makes testing wonderful!
I've found a bug with Jasmine's type matching. Arrays match as objects, for example the following expectation passes:
expect({}).toEqual([]);

After digging into the source code I would like to propose an addition at line 932 of jasmine/lib/jasmine-core/jasmine.js:
if ((jasmine.isArray_(a) && !jasmine.isArray_(b)) || (!jasmine.isArray_(a) && jasmine.isArray_(b))) {
  return false;
}",peterjwest,NONE,2011-07-26 23:02:36+00:00,True,2013-05-26 19:57:32+00:00,669.87,,2,1,2013-05-26 19:57:28+00:00,669.87,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
115,Jasmine cannot handle scripts with a canvas,"I am trying to use jasmine to test events bound to an html5 canvas.
My scripts are visible here https://gist.github.com/1114683
presentation.js breaks at line 44 with the error that canvas is undefined.  When I run the application outside jasmine I get no issues.
I also have a better explanation of the problem at stack overflow here
http://stackoverflow.com/questions/6878887/js-breaks-with-jasmine
So, I have been looking into this and what I can tell is beforeEach runs after other scripts and the dom is loaded.  This causes errors with things like $.get()",austinbv,NONE,2011-07-29 20:55:12+00:00,True,2013-03-06 06:05:00+00:00,585.38,,2,1,2013-03-06 06:05:00+00:00,585.38,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
116,jasmine-gem raise conflicts,"yanoo@kelemen ~ $ jasmine init
/usr/local/lib/site_ruby/1.9.1/rubygems/specification.rb:1615:in `raise_if_conflicts': Unable to activate actionpack-3.0.9, because rack-1.3.2 conflicts with rack (~> 1.2.1) (Gem::LoadError)
    from /usr/local/lib/site_ruby/1.9.1/rubygems/specification.rb:738:in `activate'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/specification.rb:764:in `block in activate_dependencies'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/specification.rb:758:in `each'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/specification.rb:758:in `activate_dependencies'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/specification.rb:742:in `activate'
    from /usr/local/lib/site_ruby/1.9.1/rubygems.rb:209:in `rescue in try_activate'
    from /usr/local/lib/site_ruby/1.9.1/rubygems.rb:206:in `try_activate'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/custom_require.rb:58:in `rescue in require'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/custom_require.rb:35:in `require'
    from /usr/lib/ruby/gems/1.9.1/gems/jasmine-1.1.0.rc3/lib/jasmine/railtie.rb:1:in `<top (required)>'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/custom_require.rb:36:in `require'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/custom_require.rb:36:in `require'
    from /usr/lib/ruby/gems/1.9.1/gems/jasmine-1.1.0.rc3/lib/jasmine.rb:12:in `<top (required)>'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require'
    from /usr/local/lib/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require'
    from /usr/lib/ruby/gems/1.9.1/gems/jasmine-1.1.0.rc3/bin/jasmine:4:in `<top (required)>'
    from /usr/bin/jasmine:19:in `load'

Debian, ruby1.9.2, rubygems 1.8.6",jandudulski,NONE,2011-08-03 11:45:16+00:00,True,2011-08-03 11:52:16+00:00,0.0,,1,1,2011-08-03 11:52:16+00:00,0.0,jandudulski,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
118,Bug when no tests run,"When no tests run (i,.e. total === 0) then the status bar is still GREEN. should be RED to indicate no tests have passed, because none exist.
When running a test plan in IE the first time, some obscure syntax error prevented any tests from running, but the status bar fooled me into thinking everything was ok.
Ideally one would be able to express how many tests are expected and have the test plan verify that number.",bcowgill,NONE,2011-08-09 10:56:03+00:00,True,2013-07-21 17:41:10+00:00,712.28,,4,4,2011-08-10 17:31:16+00:00,1.27,ragaskar,CONTRIBUTOR,0,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
119,Allow toThrow to take an exception class,"and pass if the thrown exception is an instance of that class.
Many other Testing frameworks do it like this, and I find it very usefull if I want to specify the type of the exception thrown, but don't care about it's message etc.",dwt,NONE,2011-08-17 05:56:44+00:00,True,2011-08-17 06:12:47+00:00,0.01,,1,1,2011-08-17 06:12:47+00:00,0.01,dwt,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
121,Is it feasible for tests to run in a blank context?,"I'm rather tired of having to declare variables at particular scope levels, as such:
describe 'foo', ->
  # bar has to be declared here even though we can't assign anything to it yet
  bar = null
  beforeEach ->
    runs ->
      # async stuff...
      bar = $('td tr table p body').text()
  it 'should you betcha', ->
    expect(bar).toEqual(""TANGO!"")
I believe the RSpecky way to do it would be using member variables, i.e. @foo. This technically works in jasmine, but the context that the tests run in is the jasmine spec object itself, which has a number of properties that could accidentally be overridden (in fact my team started out using jasmine this way and did end up overriding something accidentally).
So I'm wondering if it's feasible to instead run the tests in the context of a blank object ({}), so that arbitrary variables could be defined and used without worrying about scoping. I assume the only reason this couldn't be done is that some methods are expected (needed?) to be on the context, e.g. addMatchers.
If this kind of change would be accepted, I'd be happy to try to code it myself. Just looking for comments.",gfredericks,NONE,2011-08-19 21:31:44+00:00,True,2011-08-19 22:12:06+00:00,0.03,,2,1,2011-08-19 22:12:06+00:00,0.03,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
122,global functions reference 404ing,"on the API reference, global functions are linked to be at http://pivotal.github.com/jasmine/jsdoc/symbols/_global_.html but that currently 404s",wyattdanger,NONE,2011-08-21 20:42:19+00:00,True,2011-08-22 01:32:21+00:00,0.2,,2,2,2011-08-22 01:32:21+00:00,0.2,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
124,`rake jasmine` doesn't work with 1.9,"I just added Jasmine to a Rails engine and tried to run rake jasmine, but I got the following error:
""rake aborted! no such file to load -- spec/javascripts/support/jasmine_config.rb""
However, I did have that file. I'm using Ruby 1.9.2.
To solve this, my coworker figured out that we could add the following to the Rakefile, just above require 'jasmine':
# Push the current dir onto the load path
$:.unshift('.')
This is because Ruby 1.9 does not automatically include the directory of the current file in the load path.
See http://stackoverflow.com/questions/2900370/why-does-ruby-1-9-2-remove-from-load-path-and-whats-the-alternative",nathanl,NONE,2011-08-25 18:04:20+00:00,True,2011-08-25 19:42:30+00:00,0.07,,1,1,2011-08-25 19:42:30+00:00,0.07,nathanl,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
125,Jasmine server calls String#each - not available in Ruby 1.9,"Jasmine server blows up when running my tests in Ruby 1.9 because it is calling String#each. In 1.9, that should be String#each_line.",nathanl,NONE,2011-08-25 18:56:30+00:00,True,2011-08-25 19:42:17+00:00,0.03,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
126,jasmine_tags extension,"Hello,
just wanted to let you know that I wrote a little extension which lets you annotate jasmine spec with tags. You can then choose to run only specs with certain tags or exclude (for example slow) specs from run.
If you are interested, take a look at tf/jasmine_tags.
Best,
Tim",tf,NONE,2011-08-25 20:41:39+00:00,True,2011-09-10 00:35:30+00:00,15.16,,3,3,2011-09-10 00:35:30+00:00,15.16,ragaskar,CONTRIBUTOR,0,1,0,1,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
127,TAP output for Jasmine?,"I've just started learning about BDD -- I'm a JavaScript programmer working with node.js and browsers, so Jasmine is a natural point of focus for me to learn about and experiment with this style of development and testing.  Previously, I've mainly focused on ""classic"" unit testing, with the help of various tools.
I'm also aware of a recent surge of interest within the node.js community in TAP-compliant unit testing and harnesses, for use in ""machine-to-machine"" continuous integration systems:
http://testanything.org/wiki/index.php/Main_Page
https://github.com/isaacs/node-tap
I'm curious whether the BDD/jasmine folks feel that TAP and BDD can go together (e.g. could jasmine be modified or wrapped to serve as a TAP producer/consumer?); or whether perhaps they're incompatible approaches.
Thanks for your feedback, and I've enjoyed my experience with jasmine so far.",michaelsbradleyjr,NONE,2011-09-01 18:36:27+00:00,True,2011-09-10 00:33:01+00:00,8.25,,2,1,2011-09-10 00:33:01+00:00,8.25,ragaskar,CONTRIBUTOR,0,1,0,0,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
128,support for .with() modifier for spies,"RSpec supports a mocking syntax that allows the developer to define expected parameters, in Jasmine I would expect this to be written as:
spyOn(foo, 'bar').with('bat').andReturn('baz');
spyOn(foo, 'bar').with('baz').andReturn('bat');
This allows me to avoid writing a andCallFake() with a switch statement in it for functions that call helper functions multiple times with different parameters.
It would be an failure if foo.bar() was never called with the expected argument
If there was not a spyOn without a with modifier it would be an failure to call the function with any other argument than those specified
This avoids needing to use .toHaveBeenCalledWith() in many circumstances.",davidwkeith,NONE,2011-09-07 18:57:52+00:00,True,2013-05-29 17:06:46+00:00,629.92,,4,3,2011-09-10 00:28:20+00:00,2.23,ragaskar,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
129,Support for .toHaveBeenCalled().exactly(x).times() assertions on spies,"A syntax like:
expect(MySpy.foo).toHaveBeenCalled()exactly(5).times();
expect(MySpy.foo).toHaveBeenCalledWith('bar').exactly(3).times();
expect(MySpy.foo).toHaveBeenCalledWith('bat').exactly(2).times();
// Helpers
expect(MySpy.foo).toHaveBeenCalled().once();
expect(MySpy.foo).toHaveBeenCalled().twice();
would only pass if MySpy.foo was called the specified number of times.",davidwkeith,NONE,2011-09-07 19:02:37+00:00,True,2013-10-02 21:20:07+00:00,756.1,,11,14,2011-09-07 19:03:38+00:00,0.0,davidwkeith,NONE,1,2,0,8,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
130,Can't run standalone jasmine in Node,"Not using the 3rd party jasmine-node project, how do I run jasmine in node? Here's what I have:
//use same jasmine file in browser or node
var jasmine = jasmine || require('./lib/jasmine-1.1.0.rc1/jasmine').jasmine;
//TrivialReporter works in the browser, is undefined in node.
jasmine.getEnv().addReporter(new jasmine.TrivialReporter());
jasmine.getEnv().execute();
What am I missing?",geddski,NONE,2011-09-08 23:34:37+00:00,True,2011-09-10 00:31:05+00:00,1.04,,5,7,2011-09-10 00:31:05+00:00,1.04,ragaskar,CONTRIBUTOR,0,1,0,4,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
131,"1.1.0 not working with bundle exec rake jasmine, 1.0.2.0 fine","We're using Jasmine to test the javascript in a non-Ruby application, and RVM with a Gemfile to ensure the team members' environments are consistent. Using ruby-1.9.2-p290 with bundler 1.0.18 and only rake and jasmine in the Gemfile, I get the following error when trying to run the Jasmine tests:
mallan@reav008411m:~/work/cloud-stats(master)$ bundle exec rake jasmine
Jasmine is not available. In order to run jasmine, you must: (sudo) gem install jasmine

Downgrading to jasmine-1.0.2.0 fixes the issue.
Adding --trace to the bundle exec command doesn't add any useful information and I'm not sure how to investigate this further. Please let me know if there's anything you'd like me to do to help troubleshoot the issue.
Console session:
mallan@reav008411m:~/work/cloud-stats(master)$ cat .rvmrc 
rvm --create use 1.9.2@cloud-stats > /dev/null
mallan@reav008411m:~/work/cloud-stats(master)$ which ruby
/Users/mallan/.rvm/rubies/ruby-1.9.2-p290/bin/ruby
mallan@reav008411m:~/work/cloud-stats(master)$ cat Gemfile
source ""http://rubygems.org""

gem ""rake""
gem ""jasmine""
mallan@reav008411m:~/work/cloud-stats(master)$ rm Gemfile.lock 
mallan@reav008411m:~/work/cloud-stats(master)$ bundle install
Fetching source index for http://rubygems.org/
Using rake (0.9.2) 
Using ffi (1.0.9) 
Using childprocess (0.2.2) 
Using diff-lcs (1.1.3) 
Using jasmine-core (1.1.0) 
Using rack (1.3.2) 
Using rspec-core (2.6.4) 
Using rspec-expectations (2.6.0) 
Using rspec-mocks (2.6.0) 
Using rspec (2.6.0) 
Using json_pure (1.6.0) 
Using rubyzip (0.9.4) 
Using selenium-webdriver (2.5.0) 
Using jasmine (1.1.0) 
Using bundler (1.0.18) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
mallan@reav008411m:~/work/cloud-stats(master)$ bundle exec rake jasmine
Jasmine is not available. In order to run jasmine, you must: (sudo) gem install jasmine
mallan@reav008411m:~/work/cloud-stats(master)$ rm Gemfile.lock 
mallan@reav008411m:~/work/cloud-stats(master)$ cat Gemfile
source ""http://rubygems.org""

gem ""rake""
gem ""jasmine"", ""1.0.2.0"" # problem with jasmine-1.1.0
mallan@reav008411m:~/work/cloud-stats(master)$ bundle install
Fetching source index for http://rubygems.org/
Using rake (0.9.2) 
Using ffi (1.0.9) 
Using childprocess (0.2.2) 
Using diff-lcs (1.1.3) 
Using json_pure (1.6.0) 
Using rack (1.3.2) 
Using rspec-core (2.6.4) 
Using rspec-expectations (2.6.0) 
Using rspec-mocks (2.6.0) 
Using rspec (2.6.0) 
Using rubyzip (0.9.4) 
Using selenium-webdriver (2.5.0) 
Using jasmine (1.0.2.0) 
Using bundler (1.0.18) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
mallan@reav008411m:~/work/cloud-stats(master)$ bundle exec rake jasmine
NOTE: Gem.available? is deprecated, use Specification::find_by_name. It will be removed on or after 2011-11-01.
Gem.available? called from /Users/mallan/.rvm/gems/ruby-1.9.2-p290@cloud-stats/gems/jasmine-1.0.2.0/lib/jasmine.rb:8.
NOTE: Gem.available? is deprecated, use Specification::find_by_name. It will be removed on or after 2011-11-01.
Gem.available? called from /Users/mallan/.rvm/gems/ruby-1.9.2-p290@cloud-stats/gems/jasmine-1.0.2.0/lib/jasmine/base.rb:64.
your tests are here:
  http://localhost:8888/
[2011-09-13 16:05:31] INFO  WEBrick 1.3.1
[2011-09-13 16:05:31] INFO  ruby 1.9.2 (2011-07-09) [x86_64-darwin10.8.0]
[2011-09-13 16:05:31] INFO  WEBrick::HTTPServer#start: pid=46847 port=8888",growlybear,NONE,2011-09-13 06:43:38+00:00,True,2013-05-26 20:00:47+00:00,621.55,,2,2,2012-02-11 07:27:55+00:00,151.03,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
132,"Alternative asynchronous matching with ""eventually"" ","Hello,
as a proof of concept, I have implemented a jasmine extension which introduces an eventually property on the matchers object, allowing for asynchronous specs with less function nesting:
it('allows to match asynchronously with implicit polling', function() {
  var spy = jasmine.createSpy();

  setTimeout(function() {
    spy();
  }, 100);

  expect(spy).eventually.toHaveBeenCalled();
});
See jasmine_eventually.
Cheers
Tim",tf,NONE,2011-09-21 10:27:52+00:00,True,2013-05-26 20:03:44+00:00,613.4,,2,1,2013-05-26 20:03:40+00:00,613.4,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
133,"jasmine.ExpectationResult should not keep a reference to ""expected"" and ""actual""","When you have a test suite that contains thousands expectations, and for each test case you create an environment that includes many complex data structures, keeping references to these internals in practice disables all garbage collection.
We are currently using a patched jasmine script in order to make it practical to execute our test suite. There is simply not enough memory  to complete our tests when it keeps thousands of redundant data structures in memory.",ropez,NONE,2011-09-25 19:04:05+00:00,True,2013-05-26 20:09:29+00:00,609.05,,2,2,2011-09-25 19:10:15+00:00,0.0,ropez,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
134,Standalone Jasmine 1.1.0 only contains lib/ folder ,"Well... title says it all...
http://pivotal.github.com/jasmine/downloads/jasmine-standalone-1.1.0.zip
The User guide says open ""SpecRunner.html"". So I guess, that makes 1.1.0 not working out of the box.
As a solution you can:

download any previous release,
unpack it,
unpack 1.1.0,
copy lib from 1.1.0 into previous release (merge lib/ folder)
adjust paths in SpecRunner.html",TEHEK,NONE,2011-09-26 18:10:59+00:00,True,2013-10-04 19:36:02+00:00,739.06,,7,7,2011-11-04 21:26:45+00:00,39.14,mcaprari,NONE,1,1,0,5,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
139,waitsFor() should work if you pass it a spy (and optional timeout),"In that case it should simply wait for that spy to be called within the timeout.
I find myself doing this quite a bit in tests for async code:
var onSuccess = jasmine.createSpy();
doMyThing(onSuccess);
waitsFor(function() {return onSuccess.wasCalled; }, ""waiting on spy"", 2000);
It seems like I should be able to just write:
waitsFor(onSuccess, 2000);
Bonus points for making its return work like a matcher:
waitsFor(onSuccess, 2000).toHaveBeenCalledWith(42);",paxunix,NONE,2011-10-03 05:57:25+00:00,True,2013-05-26 20:26:04+00:00,601.6,,4,3,2012-05-19 00:31:13+00:00,228.77,balefrost,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
140,Problem in rspec2? method,"Hi I just upgrade to jasmine 1.1.0 and the jasmine:ci rake take is blowing up:
rake aborted!
Could not find rspec (>= 2.0) amongst [rake-0.9.2, Saikuro-1.1.0, .... yajl-ruby-1.0.0]
/usr/local/rvm/rubies/ruby-1.9.2-p290/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:247:in to_specs' /usr/local/rvm/rubies/ruby-1.9.2-p290/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:256:into_spec'
/usr/local/rvm/rubies/ruby-1.9.2-p290/lib/ruby/site_ruby/1.9.1/rubygems/specification.rb:434:in find_by_name' /usr/local/rvm/gems/ruby-1.9.2-p290@trunk_gems/gems/jasmine-1.1.0/lib/jasmine/base.rb:43:inrspec2?'
Ruby 1.9.2-p290
Rubygems 1.8.10",aselder,NONE,2011-10-03 19:15:04+00:00,True,2011-10-03 19:17:18+00:00,0.0,,1,1,2011-10-03 19:17:18+00:00,0.0,aselder,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
141,spyOn doesn't see functions being called,"Created this gist that shows it failing:
https://gist.github.com/1260389
You can see that it's calling the function and the output is being displayed, but toHaveBeenCalled() is failing to correctly detect it.
I originally misfiled here:  mhevery/jasmine-node#80  against jasmine-node. He suggested jsdom or jasmine, but it doesn't look like jsdom since the code seems to be working with its console.log() call. Somehow Jasmine is just missing the call to hello(). Forgot to mention before which versions of stuff I'm using:  jasmine-node@1.0.8 which appears to bundle jasmine@1.0.1. Also pulled down jasmine@1.1.0 from here:
http://pivotal.github.com/jasmine/download.html
and swapped it into place with jasmine-node@1.0.8 and still seeing the same issue.",mich-cook,NONE,2011-10-03 22:27:18+00:00,True,2011-10-18 03:36:43+00:00,14.21,,3,2,2011-10-07 20:40:18+00:00,3.93,shwoodard,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
143,Jasmine requires Rails?,"I just installed Jasmine into an empty gemset,
tried to run 'jasmine init', and got an error stating:
""Could not find rails (>= 3.0)"".
Is this a known issue?",nfiniteset,NONE,2011-10-12 00:11:33+00:00,True,2011-10-17 20:50:31+00:00,5.86,,3,3,2011-10-12 14:39:28+00:00,0.6,nfiniteset,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
144,How am I supposed to debug my code if all exceptions and errors are caught by Jasmine??,It's impossible to find bugs in my code when Jasmine catches all exceptions and errors and leaves me with nothing but a static stack trace. Can this be disabled somehow??,timmolendijk,NONE,2011-10-13 00:30:20+00:00,True,2013-05-26 20:29:05+00:00,591.83,,8,11,2011-10-17 20:46:07+00:00,4.84,ragaskar,CONTRIBUTOR,0,2,0,6,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
145,UI (jasmine-html.js?) issues/annoyences,"There are some issues in the UI that bug the heck out of me:

Checking 'passed' or 'skipped' does not persist -- whenever you rerun some tests you are back to unchecked.
Clicking on a block of tests (on its underlined heading to be precise) is supposed to result in rerunning just those tests, yet any failing tests outside of this block will still run (resulting in weird summary statements such as ""1 spec, 3 failures in ...s"")! So you still get all the errors from the various failing tests at the same time, making it needlessly hard to debug.
And then we have my main problem (confusion?) with Jasmine; why oh why does it catch and hide all exceptions and errors for me, leaving me with nothing but a static stack trace?!? That's taking debugging back to 1995! See also here.

I'm running 1.1.0 (final).",timmolendijk,NONE,2011-10-13 00:47:07+00:00,True,2013-05-27 00:10:46+00:00,591.97,,3,4,2011-10-21 10:21:20+00:00,8.4,KrofDrakula,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
147,Jasmine 1.1.1 breaks Rails (3.1.1),"Since Jasmine 1.1.1, Rails 3.1.1 (WebBrick, Rake, Cucumber, etc) fails with:
rake aborted!
uninitialized constant Jasmine
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/jasmine-1.1.1/lib/jasmine.rb:4:in `<top (required)>'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/bundler-1.0.21/lib/bundler/runtime.rb:68:in `require'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/bundler-1.0.21/lib/bundler/runtime.rb:68:in `block (2 levels) in require'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/bundler-1.0.21/lib/bundler/runtime.rb:66:in `each'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/bundler-1.0.21/lib/bundler/runtime.rb:66:in `block in require'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/bundler-1.0.21/lib/bundler/runtime.rb:55:in `each'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/bundler-1.0.21/lib/bundler/runtime.rb:55:in `require'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@rails311/gems/bundler-1.0.21/lib/bundler.rb:122:in `require'
/Users/pascal/Projecten/RoR/bizplay/config/application.rb:7:in `<top (required)>'
/Users/pascal/.rvm/rubies/ruby-1.9.2-p290/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:36:in `require'
/Users/pascal/.rvm/rubies/ruby-1.9.2-p290/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:36:in `require'
/Users/pascal/Projecten/RoR/bizplay/Rakefile:4:in `<top (required)>'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/rake_module.rb:25:in `load'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/rake_module.rb:25:in `load_rakefile'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/application.rb:495:in `raw_load_rakefile'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/application.rb:78:in `block in load_rakefile'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/application.rb:129:in `standard_exception_handling'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/application.rb:77:in `load_rakefile'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/application.rb:61:in `block in run'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/application.rb:129:in `standard_exception_handling'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/lib/rake/application.rb:59:in `run'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/gems/rake-0.9.2/bin/rake:32:in `<top (required)>'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/bin/rake:19:in `load'
/Users/pascal/.rvm/gems/ruby-1.9.2-p290@global/bin/rake:19:in `<main>'

Reverting to Jasmine 1.1.0 solves the problem.",plindelauf,NONE,2011-10-18 08:11:07+00:00,True,2013-05-27 00:12:03+00:00,586.67,,9,11,2011-10-18 14:37:10+00:00,0.27,lightscalar,NONE,0,1,0,8,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
150,Coverage tools,"Just mentioning this here too, but it'd be awesome to have coverage tools that integrate with jasmine/evergreen. Main ticket is at abepetrillo/evergreen#32",plukevdh,CONTRIBUTOR,2011-10-24 18:42:28+00:00,True,2013-05-27 00:20:24+00:00,580.23,,2,1,2013-05-27 00:20:18+00:00,580.23,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
151,Getting Sprockets::CircularDependencyError in 1.2.0.rc1,"I seem to be getting these errors a lot in my compiled JavaScript files from CoffeeScript
throw Error(""Sprockets::CircularDependencyError: .../foobar.js.coffee has already been required"")
and every time I get them, I have to shutdown jasmine and restart. I haven't really pinpointed the source of this error but it seems to happen whenever there are errors when compiling from CoffeeScript to JavaScript such as bad syntax, etc.",axsuul,NONE,2011-10-25 09:01:27+00:00,True,2011-12-10 04:25:43+00:00,45.81,,2,2,2011-11-16 17:29:57+00:00,22.35,ruprict,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
153,Implement aroundEach,"It'd be nice to have an aroundEach function, particularly for situations where something needs to be set up and unwound, and you'd like those two things to sit right next to each other in the code.
Here's the example I just wanted to write:
aroundEach(function(spec){
  Timecop.travel(new Date(2011, 10, 28, 11, 45));
  spec.run();
  Timecop. returnToPresent();
});

Not something I'd use everyday, but it can be handy once in a while. (Referenced lib is Timecop.js)",searls,NONE,2011-10-28 12:46:30+00:00,True,2013-05-27 00:21:08+00:00,576.48,,5,8,2011-10-28 16:07:15+00:00,0.14,ragaskar,CONTRIBUTOR,0,3,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
154,Combine matchers,"It would be great if it was possible to combine together matchers using boolean ""and"" and ""or"". For example, sometimes the object I'm testing is ok if it's in either of two states, and it would be great to be able to say:
expect(num).toEqual(NaN).or.toEqual(null)

There's some subtlety here surrounding not, for example I'd imagine that in:
expect(num).not.toEqual(NaN).or.toEqual(null)

not would bind more tightly than or.
Sorry I haven't contributed any code to achieve this! If I get time I might have a go
Thanks!",iainbeeston,NONE,2011-11-01 11:40:36+00:00,True,2011-11-03 14:53:58+00:00,2.13,,2,1,2011-11-03 14:53:58+00:00,2.13,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
155,'jasmine' npm package name now available,"Hey all,
Not too sure if this was noticed or intentional, but I noticed that jasmine is now open on npm as a potential package name. (http://search.npmjs.org/). I noticed an (old) pull request with a package.json in it, but it seems all that is really needed (now) is a ""main"": ""lib/jasmine-core/jasmine.js"" line to get npm install jasmine working.
As an aside, I was initially thinking of creating another CLI package (something like node-jshint) and calling it a different name when I came across the fact that jasmine was available, but I thought I would post here first instead of possibly taking it.
Cheers,",brentlintner,NONE,2011-11-10 22:25:08+00:00,True,2013-05-27 00:22:22+00:00,563.08,,2,1,2013-05-27 00:22:18+00:00,563.08,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
160,Allow spies to be overriden,"Right now if you spy on a method more than once, Jasmine will complain. I would like it so that Jasmine did not do this. The use case is that I would like set up a default spy in my beforeEach block (as most tests in the test group depend on this) and then override this spy for individual tests where behavior differs from the default. Like so:
describe '#method', ->
  beforeEach ->
    spyOn(http, 'request').andCallFake (fn) -> fn()

  it 'should do something on success', ->
    # some test here
    foo.method()

  it 'should do something else assuming success', ->
    # some test here
    foo.method()

  it 'should do yet another thing assuming success', ->
    # some test here
    foo.method()

  it 'should do a different thing on error', ->
    error = new Error('oh noes')
    spyOn(http, 'request').andCallFake (fn) -> fn(error)
    fn = jasmine.createSpy()
    foo.method(fn)
    expect(fn).toHaveBeenCalledWith(error)
This is obviously a contrived example; a better example would be if the method is more complicated and I am setting up more things in my beforeEach (and have more tests). You can see how this might be useful.
WDYT?",mcmire,NONE,2011-11-18 19:23:49+00:00,True,2011-12-05 23:14:34+00:00,17.16,,2,3,2011-11-18 21:24:02+00:00,0.08,mcmire,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
161,Quick start documentation out of date,"From https://github.com/pivotal/jasmine/wiki/User-Guide


Get the latest standalone release from the downloads page.
Open SpecRunner.html in your favorite browser.


But I can't find any SpecRunner.html file in the jasmine-standalone-1.1.0.zip package.",rdingwall,NONE,2011-11-21 21:03:14+00:00,True,2012-02-14 21:30:21+00:00,85.02,,3,2,2011-11-22 16:09:34+00:00,0.8,jedahan,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
162,Support remote assets,"I am getting my css from a cdn, and would like to also use the same in jasmine, but this results in:
<link rel=""stylesheet"" href=""/http://code.jquery.com/mobile/1.0/jquery.mobile-1.0.min.css"" type=""text/css"" media=""screen""/>

so something like asset =~ /^https?:/"" ? asset : ""/"" + asset would be nice",grosser,CONTRIBUTOR,2011-11-25 19:01:43+00:00,True,2013-05-27 00:23:56+00:00,548.22,,2,4,2012-02-11 07:13:40+00:00,77.51,infews,CONTRIBUTOR,0,2,0,0,"['bug', 'feature request', 'gem']",False,True,False,False,False,False,False,False,False,False,False,True,False,True,False
164,Spies should collect return values,"We have http://pivotal.github.com/jasmine/jsdoc/symbols/jasmine.Spy.html#argsForCall so we can check how a method was called.
I'd like to check that the method was not only called, but that it returned the expected result.",ExtAnimal,NONE,2011-11-29 08:33:02+00:00,True,2011-11-29 21:58:04+00:00,0.56,,5,12,2011-11-29 21:58:04+00:00,0.56,ragaskar,CONTRIBUTOR,0,3,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
167,Creating a matcher for equals-method,"I don't know if you do this, but I build my ValueObjects with an equals-method. So I can define my own conditions to the equality of two objects. These are to be compared by

obj1.equals(obj2)

As the standard matcher from jasmine doesn't check for this method, I wrote my own matcher:
toBeEqualTo: function(expected) {
    return this.acutal.equals(expected);
}

TypeError: Cannot call method 'equals' of undefined

Really? I was quite sure about the rest of the code, so I reversed it:
toBeEqualTo: function(expected) {
    return expected.equals(this.acutal);
}

Error: Expected { method :  Function, equals : Function, ... } to be equal to  { method :  Function, equals : Function, ... } at ... bla

Huh? So now I'm confused. Are these objects undefined or equal but not equal?
Also, my objects have a toString/toJSON method, I like those to be used if I see them printed out.",Phoscur,NONE,2011-12-29 17:47:05+00:00,True,2013-05-27 00:30:22+00:00,514.28,,3,2,2012-02-14 21:22:16+00:00,47.15,ragaskar,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
171,Add support for running specs in a random order,Randomizing the test order can help reveal inter-spec dependencies (like stepping on globals without cleaning up).,jamesarosen,NONE,2012-01-04 23:54:37+00:00,True,2013-05-27 00:36:30+00:00,508.03,,7,12,2012-02-11 07:11:44+00:00,37.3,infews,CONTRIBUTOR,0,1,0,6,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
173,Make adding new matchers easy,"Hello, right now the proposed way for adding new matchers is this:
beforeEach(function() {
  this.addMatchers({
    toBeLessThan: function(expected) {
      return this.actual < expected;
    }
  });
});
It's not very convenient, because usually You define special matchers in a standalone helper file (not in spec file) and reuse it among many spec files.
But right now it's not easy to define matchers without the beforeEach block, for example code below wouldn't work:
jasmine.Matchers.prototype.toBeLessThan = function(expected) {
  return this.actual < expected;
};
You has also to do some extra magic, like this:
jasmine.Matchers.prototype.toBeLessThan = function(expected) {
  return this.actual < expected;
};
jasmine.Matchers.prototype.toBeLessThan = jasmine.Matchers.matcherFn_(
  'toBeLessThan', 
  jasmine.Matchers.prototype.toBeLessThan
);
So, maybe it's worth to somehow simplify this, add some helper method for example?, like jasmine.Mathcers.addMatchers that will do all this behind the scene?
Thanks.",alexeypetrushin,NONE,2012-01-07 17:40:21+00:00,True,2013-05-27 00:41:52+00:00,505.29,,3,3,2012-02-14 21:15:51+00:00,38.15,ragaskar,CONTRIBUTOR,0,2,0,0,"['bug', 'feature request']",False,True,False,False,False,False,False,False,False,False,False,True,False,False,False
174,Valid unit tests always fail when run through phantomjs on Ubuntu or Debian,"Please see the following discussion:
https://github.com/elemoine/jasmine/commit/760a61a65f34921f1a1e9742cef75704ab53355b#commitcomment-847068
More info
http://groups.google.com/group/jasmine-js/browse_thread/thread/4712b34f2099f05e
There is a suggested fix with jasmine.js to make it work.
Any ideas on if this is a jasmine bug that can be fixed?",,NONE,2012-01-08 07:44:21+00:00,True,2013-05-27 00:45:49+00:00,504.71,,6,10,2012-01-08 22:13:26+00:00,0.6,,NONE,0,2,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
175,Can you use multiple expect() calls within one test?,"It's not clear from the documentation at all. I've used multiple expect()'s within some it() ' s in my tests and it works fine, but for the sake of clarity it would help to add something like ""each test can contain several expect() calls"" as no example I can see within the documentation demonstrates this.",wheresrhys,NONE,2012-01-11 01:04:06+00:00,True,2012-02-11 06:57:00+00:00,31.25,,3,2,2012-01-11 01:19:09+00:00,0.01,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
176,Add an onComplete event to the test runner,"At the moment I'm testing a plugin against multiple versions of jQuery usnig iFrames. As the tests make extensive use of waits() I need the tests in one iframe to complete before starting the next set of tests in a new iframe (the timings get thrown way out when I run all the iframes at once)
In order to achieve this it'd be useful to add an onComplete event that is triggered at the ned of  .reportRunnerResults()",wheresrhys,NONE,2012-01-11 13:02:40+00:00,True,2013-05-27 00:50:00+00:00,501.49,,6,10,2012-01-30 09:53:41+00:00,18.87,vaeroon,NONE,0,2,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
178,API Suggestion: Use an explicit callback argument for completion of async specs,"Reading through the mocha.js docs: http://visionmedia.github.com/mocha/
One awesome feature stands out.  Spec blocks can accept an argument, which is a function that can be called to signify the end of an async spec.
describe('User', function(){
  describe('#save()', function(){
    it('should save without error', function(done){
      var user = new User('Luna');
      user.save(function(err){
        if (err) throw err;
        done();
      });
    })
  })
})

To do the same in Jasmine, it might look like this:
describe('User', function(){
  describe('#save()', function(){
    it('should save without error', function(){
      var user, error;

      runs(function() {
        user = new User('Luna');
        user.save(function(err){
          error = err;
        });
      });

      waits(100);

      runs(function {
        expect(error).toBeFalsy();
      });

    })
  })
})

I suppose you could setup a spy, and waitsFor() that spy to be called form the callback as well.  But the point is this: you have to set all that up.  Using the provided callback instead, cleans up the test greatly.
I assume this works by checking the specFunction.length and if that is one, then we assume it's an async spec and refuse to move on until that callback is called (or spec times out of course).  And if it's zero the spec runs synchronously, or can use waits/runs queues as normal.
I've had to train a few people on Jasmine and the waits() and runs() dance is always a sticking point of conceptual understanding.  But an explicit, ""done with everything in this spec"" callback is a far easier API to grasp, and requires far less setup in the spec itself. In my opinion it's easier to learn, write, read and maintain.",Squeegy,NONE,2012-01-16 23:03:13+00:00,True,2013-05-06 14:43:21+00:00,475.65,,9,14,2012-02-11 07:06:50+00:00,25.34,infews,CONTRIBUTOR,0,1,0,8,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
180,"setTimeout, setInterval, clearTimeout, clearInterval functions does not work with JavaScriptCore framework in iPhone","I have integrated Jasmine with iPhone project. I am running Jasmine using JavaScriptCore framework for iPhone. But JavaScriptCore is unable to interpret setTimeout and all that  function.
I have statically defined those as below
this.setTimeout    = function() {};
this.clearTimeout  = function() {};
this.setInterval   = function() {};
this.clearInterval = function() {};
I found that these functions are not part of JavaScriptCore. What could be solution to this...?? Is there any other alternative to these function??",shahdhiren,NONE,2012-01-23 05:23:57+00:00,True,2013-05-27 00:54:24+00:00,489.81,,3,4,2012-01-27 10:06:30+00:00,4.2,filipposarzana,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
182,Tests on extended ascii charsets fail with jasmin-maven-plugin,"Hello,
The following test :
describe('Test fonction htmlEncode',function()
{
it('Test encode characters',function()
{
input = 'ÜÄ';
expected = 'ÜÄ';
input = input.replace(/Ü/g,'Ü');
result = input.replace(/Ä/g,'Ä');
expect(result).toBe(expected);
    result = 'Ü'.replace(/Ü/g,'&Uuml;');
    expect(result).toBe('&Uuml;');

    result = 'Ä'.replace(/Ä/g,'&Auml;');
    expect(result).toBe('&Auml;');

    input = 'ÜÄ';
    input = input.replace(/Ü/g,'&Uuml;');
    expect(input).toBe('&Uuml;Ä');

    input = input.replace(/Ä/g,'&Auml;');
    expect(input).toBe(expected);

    input = 'Üabcdef';
    input = input.replace(/Ü/g,'&Uuml;');
    expect(input).toBe('&Uuml;abcdef');
});

});
fails while executing from Eclipse with the jasmin-maven-plugin :
1.) Test fonction htmlEncode it Test encode characters <<< FAILURE!

Expected 'ÜÜ' to be 'ÜÄ'.
Passed.
Passed.
Expected 'ÜÜ' to be 'Ü?'.
Expected 'ÜÜ' to be 'ÜÄ'.
Passed.

Executed from a browser in SpecRunner.html, it returns no error.
Is there a way to configure the encoding ?",Hilberty,NONE,2012-01-23 14:12:19+00:00,True,2012-01-24 11:27:29+00:00,0.89,,1,1,2012-01-24 11:28:35+00:00,0.89,Hilberty,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
183,lib/jasmine-core /example/SpecRunner.html still uses TrivialReporter,"…even though it's declared deprecated. looks like HTMLReporter is the way now to run tests in the browser.
Is TrivialReporter used on purpose in SpecRunner.html, or is that something overlooked?",ikr,NONE,2012-01-24 10:29:20+00:00,True,2012-04-01 17:53:14+00:00,68.31,,2,3,2012-02-11 06:51:43+00:00,17.85,infews,CONTRIBUTOR,0,1,0,0,"['bug', 'feature request']",False,True,False,False,False,False,False,False,False,False,False,True,False,False,False
184,Jasmine Clock mocking and JQuery effect 'complete' function does not go along well,"I have found a problem testing JQuery animations. The problem is that during jasmine.Clock.useMock() mode JQuery does not call complete function after effect execution.
I am not sure whether it is jasmine ot jquery problem. The complete ticket is here:
http://stackoverflow.com/questions/9141800/jasmine-clock-mocking-and-jquery-effect-complete-function-does-not-go-along-we",vkovalskiy,NONE,2012-02-05 08:07:24+00:00,True,2012-02-11 06:49:00+00:00,5.95,,4,4,2012-02-11 06:49:00+00:00,5.95,infews,CONTRIBUTOR,0,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
185,Jasmine raise_if_conflicts with ruby 1.9.3,"/Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/specification.rb:1625:in raise_if_conflicts': Unable to activate actionpack-3.1.0, because rack-1.4.1 conflicts with rack (~> 1.3.2) (Gem::LoadError) from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/specification.rb:740:inactivate'
from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/specification.rb:774:in block in activate_dependencies' from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/specification.rb:760:ineach'
from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/specification.rb:760:in activate_dependencies' from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/specification.rb:744:inactivate'
from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems.rb:209:in rescue in try_activate' from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems.rb:206:intry_activate'
from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:58:in rescue in require' from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:35:inrequire'
from /Users/cyrusinnovation/.rvm/gems/ruby-1.9.3-p0@timeofftracker/gems/jasmine-1.1.2/lib/jasmine/railtie.rb:1:in <top (required)>' from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:inrequire'
from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in require' from /Users/cyrusinnovation/.rvm/gems/ruby-1.9.3-p0@timeofftracker/gems/jasmine-1.1.2/lib/jasmine.rb:13:in<top (required)>'
from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in require' from /Users/cyrusinnovation/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:inrequire'
from /Users/cyrusinnovation/.rvm/gems/ruby-1.9.3-p0@timeofftracker/gems/jasmine-1.1.2/bin/jasmine:4:in <top (required)>' from /Users/cyrusinnovation/.rvm/gems/ruby-1.9.3-p0@timeofftracker/bin/jasmine:19:inload'
from /Users/cyrusinnovation/.rvm/gems/ruby-1.9.3-p0@timeofftracker/bin/jasmine:19:in `'
Gemfile:
gem 'guard'
gem 'guard-coffeescript'
gem 'jasmine'
gem 'bundler'",pnikonowicz,NONE,2012-02-10 19:33:36+00:00,True,2012-02-27 14:40:09+00:00,16.8,,4,4,2012-02-14 20:42:02+00:00,4.05,ragaskar,CONTRIBUTOR,0,2,0,2,"['bug', 'feature request']",False,True,False,False,False,False,False,False,False,False,False,True,False,False,False
187,PrettyPrinter emits very long string,"I'm using Jasmine to test the existence of a Backbone Model instance, expecting it to be falsy.
expect(model).toBeFalsy();

In one case model was truthy, and Jasmine wanted to present a nicely formatted string of the model, causing the page to hang because the object graph was too big and the string concatenation is inefficient  (this.string += value)
I think it would be better to

stop formatting after the string has ~100 chars
use an array to collect the values and yield the string via this.values.join("""")",OttoAllmendinger,NONE,2012-02-21 15:05:17+00:00,True,2012-05-15 09:23:09+00:00,83.76,,2,2,2012-05-14 21:13:02+00:00,83.26,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
188,"add evergreen and coffeescript tmbundle to ""Related Projects""","Please add the evergreen project (https://github.com/jnicklas/evergreen) to the Jasmine extensions list. It seems it's the best way to integrate Jasmine with Rails app at the moment, and I was completely unaware that it existed until yesterday, because it's not listed there.
And while we're at it, please add the Jasmine coffeescript Textmate bundle too (https://github.com/groupme/jasmine-coffeescript-tmbundle).",mackuba,NONE,2012-02-22 09:51:19+00:00,True,2012-02-24 21:23:16+00:00,2.48,,3,4,2012-02-24 21:23:16+00:00,2.48,infews,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
191,sync. for more than one suits,"i am new in jasmine world... this is lovely js  for testing purpose......
i suffer from one problem ....
i have more than 1 suit & at run time it will not run sync. because of that it will break up my code...
so i just want to know that , this bug is from my side or it is something else.
pls give me some hint.....",suyogs,NONE,2012-02-28 11:11:57+00:00,True,2013-05-27 01:17:52+00:00,453.59,,2,1,2013-05-27 01:17:49+00:00,453.59,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
192,s,,joeljunstrom,NONE,2012-02-28 12:35:56+00:00,True,2012-02-29 05:59:58+00:00,0.73,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
199,Problem with toContain and regular expressions,"With an array of regular expression, it seems that toContain is always true.
This test case fails:
it(""is crazy"", function()
{
    var array = [];
    var p1 = /1/i;
    var p2 = /2/i;
    array.push(p1);
    array.push(p2);
    array.splice(0,1);
    expect(array).toContain(p2);
    expect(array).not.toContain(p1);
    expect(array.length).toBe(1);
});

The error message says Error: Expected [ /2/i ] not to contain /1/i.. If .not is removed, the test case pass.",alightgoesout,NONE,2012-03-06 21:24:41+00:00,True,2012-10-30 19:57:38+00:00,237.94,,3,3,2012-06-03 20:50:22+00:00,88.98,yopefonic,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
200,How about async events testing?,"Hi guys!
I'm newbie in using Jasmine and I have some trouble with async tests.
For example I have a constructor, which has link to some HTML element. And when I click on this element I want to execute some method of this constructor.
function MyConstrustor(element) {
    this.element = element;
    this.element.addEventListener('mousedown', this, false);
    this.element.addEventListener('mousemove', this, false);
    this.element.addEventListener('mouseup', this, false);
}
MyConstructor.prototype.handleEvent = function (event) {
    switch (event.type) {
        case 'mousedown':
            this.mouseDown(event);
            break;
        case 'mousemove':
            this.mouseMove(event);
            break;
        case 'mouseup':
            this.mouseUp(event);
            break;
    }
};
MyConstructor.prototype.mouseDown = function (event) {
    //some code goes here...
};
MyConstructor.prototype.mouseMove = function (event) {
    //...and here
};
MyConstructor.prototype.mouseUp = function (event) {
    //..and here
};
So, I want to spy some method in my object.

I create an element
I create an event
I create an object which should be instance of MyConstructor
I spyOn(myObject, 'someMethod')
I dispatch created event to element in my object

But, when I execute myObject.element.dispatchEvent(event) I have async code. Can anyone help me with this test? Thanks.",Alexey-Raspopov,NONE,2012-03-09 22:25:23+00:00,True,2013-05-27 15:27:37+00:00,443.71,,3,3,2012-03-11 22:33:38+00:00,2.01,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
204,Compatibility with jQuery Mobile,"I'm just in the middle of implementing some Jasmine tests for a jQuery mobile application I'm working on, I've run into an error that I managed to track down to adding the jQuery mobile library, the error is as follows:
Jasmine.js:1769 TypeError: Cannot read property 'abort' of undefined.
As soon as I remove the jQM dependency, the error goes away.
This is my code:
<!DOCTYPE html><html><head>    <title>HTML5/Common/Tests</title>    <!-- LOAD STYLES FIRST -->    <link type=""text/css"" rel=""stylesheet"" href=""libs/jasmine.css"" media=""screen"">    <link type=""text/css"" rel=""stylesheet"" href=""../../Common/libs/jquery.mobile-1.0.1.css"" />    <!-- LOAD JASMINE LIBRARIES -->    <script type=""text/javascript"" src=""libs/jasmine.js""></script>    <script type=""text/javascript"" src=""libs/jasmine-html.js""></script>    <!-- LOAD DEPENDENCIES -->    <script type=""text/javascript"" src=""../../Common/libs/jquery-1.7.1.min.js""></script>    <script type=""text/javascript"" src=""../../Common/libs/jquery.mobile-1.0.1.min.js""></script>    <!-- LOAD CODE TO TEST -->    <script type=""text/javascript"" src=""../../Common/libs/myLib.js""></script>    <!-- LOAD ACTUAL TESTS -->    <script type=""text/javascript"">       describe(""Suite 1"", function() {            it(""Should be that 1 equals 0"", function() {                  expect(1).toEqual(0);            });       });    </script></head><body>    <script type=""text/javascript"">     jasmine.getEnv().addReporter(new jasmine.TrivialReporter());     jasmine.getEnv().execute();    </script></body></html>
I'd prefer to use Jasmine for this application instead of qUnit as I think its more flexible and easier to implement in CI and explain to the BA's and PM's.. however after tinkering with this problem for a couple of hours and some futile searches on google I still havent been able to solve it so I'm starting to consider moving on.
Here is the stack-overflow URL in case there is a workaround come up from the discussion or whoever solves it wants to claim brownie points there:
http://stackoverflow.com/questions/9784504/jasmine-throwing-up-an-error-with-jquery-mobile
Thanks and Regards.",sdesalas,NONE,2012-03-20 10:26:01+00:00,True,2013-10-02 22:30:29+00:00,561.5,,4,4,2012-03-20 17:06:44+00:00,0.28,ragaskar,CONTRIBUTOR,1,2,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
206,Packaging for custom matchers?,Has there been any discussion on how to package custom matchers? Right now it seems like we're just supposed to call this.addMatchers within a beforeEach block.,rehanift,NONE,2012-03-24 23:46:40+00:00,True,2013-05-27 01:27:05+00:00,428.07,,3,2,2012-05-02 18:43:02+00:00,38.79,ragaskar,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
211,waitsFor timeout error throws inscrutable TypeError,"There appears to be a bug in Jasmine v1.1.0, where if a waitsFor block times out, jasmine.WaitsForBlock#execute() calls the following:
this.spec.fail({
  name: 'timeout',
  message: message
});
(See WaitsForBlock.js line 40)
Unfortunately, jasmine.Spec#fail() requires that its argument is a proper error -- specifically, an object with a stack property. (See Spec.js line 124).
This results in the following error if you call a waitsFor that times out: Uncaught TypeError: Cannot read property 'stack' of undefined.",nickstenning,NONE,2012-04-03 16:43:10+00:00,True,2013-05-27 15:54:31+00:00,418.97,,3,2,2012-05-02 18:11:35+00:00,29.06,ragaskar,CONTRIBUTOR,0,2,0,0,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
212,"When calling a function that wraps a describe, this.views is undefined","I'm trying to wrap a describe in a function to DRY up my tests.  However, when I do this I get ""this.views is undefined"" on line 205 of jasmine-html.js.  Adding a check for ""typeof this.views !== 'undefined'"" before this fixes the issue but I'm not confident this is the best place to address the bug.",bmayen,NONE,2012-04-06 20:22:12+00:00,True,2013-05-27 15:56:29+00:00,415.82,,3,3,2012-04-06 22:19:49+00:00,0.08,ragaskar,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
213,roadmap for spying on jQuery deferred/when/done,"With the later versions of jQuery, there has been a significant implementation and api change when it comes to ajax and other tasks that need to be asynchronous. Spying on these and keeping a track of the various deferred and promises objects (and numerous ""when"" invocation params) is a major pain.
Is there something planned in the roadmap for addressing this?",vaeroon,NONE,2012-04-09 08:44:13+00:00,True,2012-04-09 23:23:24+00:00,0.61,,3,2,2012-04-09 15:00:55+00:00,0.26,rdy,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
215,"Startup reports ""Address already in use - bind(2)"" on Ubuntu","When using Jasmine on Ubuntu within a new Rails app, a warning arises indicating the Address is already in use.  This occurs no matter which port is specified, though does not appear to affect functionality.
rake jasmine
your tests are here:
http://localhost:8888/
[2012-04-10 19:35:13] INFO  WEBrick 1.3.1
[2012-04-10 19:35:13] INFO  ruby 1.9.2 (2011-07-09) [i686-linux]
[2012-04-10 19:35:13] WARN  TCPServer Error: Address already in use - bind(2)
[2012-04-10 19:35:13] INFO  WEBrick::HTTPServer#start: pid=2850 port=8888
rake jasmine JASMINE_PORT=12345
your tests are here:
http://localhost:12345/
[2012-04-10 19:54:22] INFO  WEBrick 1.3.1
[2012-04-10 19:54:22] INFO  ruby 1.9.2 (2011-07-09) [i686-linux]
[2012-04-10 19:54:22] WARN  TCPServer Error: Address already in use - bind(2)
[2012-04-10 19:54:22] INFO  WEBrick::HTTPServer#start: pid=3459 port=12345",darksheik,NONE,2012-04-10 23:58:33+00:00,True,2013-07-21 17:38:44+00:00,466.74,,4,7,2012-04-11 03:41:12+00:00,0.15,mark-rushakoff,CONTRIBUTOR,0,2,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
216,Bogus SyntaxError centered around the JavaScript eval() method.,"I say it is a bogus syntax error because when I run my test using the 'clean jasmine bdd' maven command, my test pass when I open up the browser. However, when I run my test using the 'clean test' maven command, my test fails with the following error message below. So I wonder why it work using bdd via the web browser and not from the command line. Please confirm bug. Thank you.
Here is the code I am testing...
Tester.js file:
function Tester(){
this.getInstance = function(classRef){
// get the functions as a string
var classAsString = classRef.toString();
    // To expose the private functions, we create
    // a new function that goes trough the functions string
    // we could have done all string parsing in this class and
    // only associate the functions directly with string
    // manipulation here and not inside the new class,
    // but then we would have to expose the functions as string
    // in the code, which could lead to problems in the eval since
    // string might have semicolons, line breaks etc.
    var funcString = """";
    funcString += ""new ("";
    funcString += classAsString.substring(0, classAsString.length - 3);
    funcString += "";\n\tthis._privates = {};\n"";
    funcString += ""\tthis._initPrivates = function(f){\n"";
        funcString += ""\t\tvar fs = f.toString();\n"";
        funcString += ""\t\tvar pf = fs.match(/function\\s*?(\\w.*?)\\(/g);\n"";
        funcString += ""\t\tthis._privates = {};\n"";
        funcString += ""\t\tfor (var i = 0, ii = pf.length; i < ii; i++){\n"";
        funcString += ""\t\t\tvar fn = pf[i].replace(/function\\s+/, '').replace('(', '');\n"";
        funcString += ""\t\t\tif('""+classRef.name+""' != fn){\n"";
        funcString += ""\t\t\t\tthis._privates[fn] = eval(fn);\n"";
        funcString += ""\t\t\t}\n"";
        funcString += ""\t\t}\n"";

        funcString += ""\t\tpf = fs.match(/var\\s*\\w.*?\\s+/g);\n"";
        funcString += ""\t\tfor(var i = 0, ii = pf.length; i < ii; i++){\n"";
        funcString += ""\t\t\tvar fn = pf[i].replace(/var\\s*/, '').replace(' ', '');\n"";
        funcString += ""\t\t\t\tthis._privates[fn] = eval(fn);\n"";
        funcString += ""\t\t}\n"";

    funcString += ""\t};\n"";
    funcString += ""})();"";

    var instance = eval(funcString);
    instance._initPrivates(classAsString);

    // delete the initiation functions
    delete instance._initPrivates;

    return instance;
};

}
function TestClass(){
this.getName = function(){
return ""TestClass"";
};
this.getName2 = function(){
    return ""TestClass"";
};

var getType = function(){
    return ""JavaScript"";
};

function doTest(){
    return ""doing test"";
};

}
TesterSpec.js file:
describe(""Tester"", function(){
it('should be able to call private methods', function () {
var tester = (new Tester()).getInstance(TestClass);
expect(tester).toBeDefined();
expect(tester._privates).toBeDefined();
expect(tester._privates[""doTest""]).toBeDefined();
expect(tester._privates.doTest()).toEqual(""doing test"");
expect(tester._privates[""getType""]).toBeDefined();
expect(tester._privates.getType()).toEqual(""JavaScript"");
});
});
And finally, here is the error message:
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.594s
[INFO] Finished at: Tue Apr 10 22:52:09 CDT 2012
[INFO] Final Memory: 14M/81M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal com.github.searls:jasmine-maven-plugin:1.1.0:test (default) on project my-calendar-gui: The jasmine-maven-plugin encountered an exception:
[ERROR] java.lang.RuntimeException: org.openqa.selenium.WebDriverException: com.gargoylesoftware.htmlunit.ScriptException: SyntaxError: syntax error (file:/Users/pouncilt/git/projects/my-calendar-gui/target/jasmine/spec/Tester.js#38(eval)#31)
[ERROR] Build info: version: '2.11.0', revision: '14435', time: '2011-10-28 18:01:56'
[ERROR] System info: os.name: 'Mac OS X', os.arch: 'x86_64', os.version: '10.6.8', java.version: '1.6.0_31'
[ERROR] Driver info: driver.version: HtmlUnitDriver
[ERROR] at com.github.searls.jasmine.runner.SpecRunnerExecutor.execute(SpecRunnerExecutor.java:40)
[ERROR] at com.github.searls.jasmine.TestMojo.executeSpecs(TestMojo.java:57)
[ERROR] at com.github.searls.jasmine.TestMojo.run(TestMojo.java:35)
[ERROR] at com.github.searls.jasmine.AbstractJasmineMojo.execute(AbstractJasmineMojo.java:233)
[ERROR] at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:107)
[ERROR] at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
[ERROR] at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
[ERROR] at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
[ERROR] at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
[ERROR] at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
[ERROR] at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
[ERROR] at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
[ERROR] at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:319)
[ERROR] at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
[ERROR] at org.apache.maven.cli.MavenCli.execute(MavenCli.java:534)
[ERROR] at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
[ERROR] at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
[ERROR] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[ERROR] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[ERROR] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
[ERROR] at java.lang.reflect.Method.invoke(Method.java:597)
[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
[ERROR] Caused by: org.openqa.selenium.WebDriverException: com.gargoylesoftware.htmlunit.ScriptException: SyntaxError: syntax error (file:/Users/pouncilt/git/projects/my-calendar-gui/target/jasmine/spec/Tester.js#38(eval)#31)
[ERROR] Build info: version: '2.11.0', revision: '14435', time: '2011-10-28 18:01:56'
[ERROR] System info: os.name: 'Mac OS X', os.arch: 'x86_64', os.version: '10.6.8', java.version: '1.6.0_31'",pouncilt,NONE,2012-04-11 04:07:22+00:00,True,2013-05-27 16:19:28+00:00,411.51,,3,2,2013-05-27 16:08:02+00:00,411.5,infews,CONTRIBUTOR,0,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
219,ConsoleReporter not showing stack trace on failed result,"When running a spec like this:
it(""should show an error"", function() {
    expect(0).toEqual(1);
});
Using ConsoleReporter, Jasmine (standalone, using phantomjs) reports the spec as failed, even shows the description, but it doesn't show the nice stack trace with trace message I've seen in jasmine-node.
This function in ConsoleReporter seems points to a stack property to save it in the failed results:
function eachSpecFailure(suiteResults, callback) {
    for (var i = 0; i < suiteResults.length; i++) {
      var suiteResult = suiteResults[i];
      for (var j = 0; j < suiteResult.failedSpecResults.length; j++) {
        var failedSpecResult = suiteResult.failedSpecResults[j];
        var stackTraces = [];
        // THIS LINE,
        for (var k = 0; k < failedSpecResult.items_.length; k++) stackTraces.push(failedSpecResult.items_[k].trace.stack);
        callback(suiteResult.description, failedSpecResult.description, stackTraces);
      }
    }
  }
But if I stringify that whole object, I only see this { ..., trace: { message: ""Expected 0 to be 1"" } }
It seems that line in the function above, should be storing the message too so it can print it out later. Also, why is there no stack? Should there be?",renier,NONE,2012-04-13 18:47:20+00:00,True,2013-05-27 01:28:58+00:00,408.28,,2,1,2013-05-27 01:28:53+00:00,408.28,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
222,toContain causes a stack overflow with circular references,"In some situations when calling toContain on a set of items that contain circular references, Jasmine ends up going into an infinite loop and causing a stack overflow.
Fairly minimal test case:
var a = {}, b = {}, c = {};
c.ref = a; a.ref = b; b.first = a; b.ref = c;
expect([a]).toContain(b);
This is a fairly simple circular reference between a/b/c, but with an added property on b which also references back to a.
When executing the above it fails with ""RangeError: Maximum call stack size exceeded""",csmith,NONE,2012-04-18 12:06:50+00:00,True,2013-05-27 16:11:17+00:00,404.17,,3,2,2012-04-20 18:08:43+00:00,2.25,ragaskar,CONTRIBUTOR,0,2,0,0,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
223,Implement a Subject Test spec in Jasmine,"To encourage people to write only one expectation per it block, how about having something similar to RSpecs Subject Keyword, ie :-
describe(""Demo"",function(){
  It(""Should have expected attributes"", function(){
     myDemo = new demo();
     expect(myDemo.name).toExist();
     expect(myDemo.gender).toExist();
     expect(myDemo.age).toExist();
  });
});

could become with subject
describe(""Demo"", function(){
  beforeEach(function(){
    var myDemo = new Demo;
  });
  subject(myDemo, function(){
    expect(myDemo.name).toExist();
    expect(myDemo.gender).toExist();
    expect(myDemo.age).toExist();
  });
});",miker169,NONE,2012-04-21 09:55:55+00:00,True,2012-04-21 22:10:53+00:00,0.51,,2,1,2012-04-21 22:10:53+00:00,0.51,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
224,Feature request: support test includes,"It would be good to be able to include other tests within tests, something like
@include myNestedJasmineTest.js
that way it would be possible to test nested depneded classes with jasmine.",AAverin,NONE,2012-04-23 06:59:02+00:00,True,2012-05-02 16:51:50+00:00,9.41,,2,3,2012-04-24 03:27:43+00:00,0.85,,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
226,beforeEach and afterEach not called in nested suites,"When you have nested suites, the beforeEach and afterEach functions are not called in the child suites.
e.g.
describe 'Foo', ->
  beforeEach ->
    @foo = new Foo()

  describe 'when bar is called', ->
    beforeEach -> @foo.bar()

    it 'should have something', ->
      expect(@foo.something).toBeDefined()

When that executes, @foo is undefined in the nested suite because the beforeEach of the parent is not executed.",jaysoo,NONE,2012-05-11 16:02:21+00:00,True,2012-05-16 15:54:27+00:00,4.99,,1,1,2012-05-16 15:54:27+00:00,4.99,jaysoo,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
227,toThrow ignores error type,"toThrow only checks an error's message. The following tests all pass:
describe 'Jasmine', ->
  it 'fails to ensure that errors are of the specified type', ->
    message = ""Cannot read property 'x' of null""
    expect(-> null.x).toThrow message
    expect(-> null.x).toThrow new TypeError message
    expect(-> null.x).toThrow new URIError message # ?!
While it is possible to check the error's type manually…
error = try null.x catch error then error
(error instanceof TypeError).should_be true
error.name.should_be 'TypeError'
error.message.should_be ""Cannot read property 'x' of null""
… couldn't Jasmine do this for me? There may be a good reason for comparing error messages only, but I can't think of one.",davidchambers,NONE,2012-05-13 22:50:49+00:00,True,2013-05-27 16:13:05+00:00,378.72,,5,6,2012-05-14 19:39:14+00:00,0.87,ragaskar,CONTRIBUTOR,0,2,0,3,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
228,toHaveBeenCalledWith works not with multiple calls,"expect($.fn.get).toHaveBeenCalledWith(0,0);
Expected spy get to have been called with [ 0, 0 ] but was called with [ [ 0 ], [ 0 ] ]
expect($.fn.get).toHaveBeenCalledWith([0],[0]);
Expected spy get to have been called with [ [ 0 ], [ 0 ] ] but was called with [ [ 0 ], [ 0 ] ]
expect($.fn.get).toHaveBeenCalledWith([ [0],[0] ]);
Expected spy get to have been called with [ [ [ 0 ], [ 0 ] ] ] but was called with [ [ 0 ], [ 0 ] ]
How do I work this?  Am I missing something?
$(selector).get(0); is called twice in the function I'm testing.  I know I can check the args directly with argsForCall but I think toHaveBeenCalledWith reads better and is  more appropriate.",Sequoia,NONE,2012-05-16 16:12:21+00:00,True,2012-05-16 17:00:42+00:00,0.03,,7,8,2012-05-16 17:00:42+00:00,0.03,ragaskar,CONTRIBUTOR,1,1,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
229,"AMD, define problem in nodejs","Using jasmine in nodejs and requirejs as module loader, I had problem because of exports not defined. the problem is that the test is typeof window !== ""undefined"". In nodejs this, test is always true. But when using requirejs adapter exports is neither defined so jasmine cannot be used.
I would suggest to use a header like this :
(function () {
""use strict""; //strict mode is better for strong error reporting

var 
jasmine      = {},

// get the global object in strict mode
Fn          = Function,
global      = (new Fn(""return this"")).call(null),

// feature sniffing
hasAMD      = typeof define !== ""undefined"",
hasCommonJS = typeof exports !== ""undefined"",

//generic export function
export_     = function export_(name, value) {
    // export as jasmine property
    if (value !== jasmine) {
      jasmine[name] = value;
    }

    if (hasCommonJS) {
      // commonjs export
      exports[name] = value;
    } else {
      // export as global
      global[name] = value;
    }
    return value;
};

jasmine.export_ = export_;

export_(""jasmine"", jasmine);//generic export
and footer :
// asynchronous definition of 'jasmine' module
if  (hasAMD) {
  define(""jasmine"", [], function () { return jasmine; });
}

}());//end block",jpolo,NONE,2012-05-21 08:31:11+00:00,True,2013-03-06 07:11:37+00:00,288.94,,2,1,2013-03-06 07:11:37+00:00,288.94,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
230,Asset caching,"It seems that sometimes chrome is overly aggressive with caching static resources like script files. It would be nice is jasmine added a unique per run identifier similar to what rails does in production.
e.g.
<script src=""/assets/foo-somethingunique1234.js"" type=""text/javascript""></script>",pivotal-medici,NONE,2012-05-22 14:18:50+00:00,True,2013-10-02 21:06:40+00:00,498.28,,5,7,2012-05-23 00:57:18+00:00,0.44,ragaskar,CONTRIBUTOR,1,3,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
231,Destructor,"I'm trying to do some quick in-browser window testing by pulling in jasmine.js with all the test 'js' files using
$.getScript( {path-to-wireup} )
Problem is that if I execute that again while the current env is executing,  i'll get maximum call-stack exception.
Is there a way to either:

Clean up current jasmine env so that a new one can be set w/ out any problems.
or
Stop current testing env, clean out all previous specs so that new ones can be registered w/ out dupicates and testing restarted.

My Wireup file looks like this.
files =[
jasmine,
console-reporter,
test-file1,
test-file2
]
function ready() {

get-script from 'files' one-by-one until all have been imported.
return $.deferred that resolves when all files have been imported.
}

$.when( ready() ).done( function() {

init jasmine env
set reporter
execute
})",yevgeniy,NONE,2012-05-24 00:59:46+00:00,True,2012-07-07 17:54:01+00:00,44.7,,2,1,2012-07-07 17:54:01+00:00,44.7,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
232,Typos: Project site's main page (introduction.js),"The following sections of the Jasmine project's web page have the typos bolded below:

Mocking the JavaScript Clock

The Jasmine Mock Clock is available for a test suites that__z__ need ...


The Runner and Reporter

Jasmine is built in JavaScript [and] must be included into a JS ...
This file is written in JavaS__s__cript and is compiled into HTML via ...",iskitz,NONE,2012-05-26 08:15:13+00:00,True,2012-05-27 16:43:13+00:00,1.35,,3,3,2012-05-26 09:20:38+00:00,0.05,madtrick,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
233,"Spying constructor and calling ""class level"" functions","Hi,
Given this code
class A
  constructor : ->
    #do something

A.something = ->
  new A()
and this test
spyOn(window, ""A"").andCallThrough()
A.something()
expect(window.A).toHaveBeenCalled()
I get this error:
TypeError: Object function () { spyObj.wasCalled = true; spyObj.callCount++; var args = jasmine.util.argsToArray(arguments); spyObj.mostRecentCall.object = this; spyObj.mostRecentCall.args = args; spyObj.argsForCall.push(args); spyObj.calls.push({object: this, args: args}); return spyObj.plan.apply(this, arguments); }
 has no method 'something'
So the question is: Can I spy on the constructor while at the same time call ""class level"" functions?",madtrick,NONE,2012-05-29 16:07:41+00:00,True,2012-07-07 17:56:56+00:00,39.08,,2,1,2012-07-07 17:56:56+00:00,39.08,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
235,runs inside describe issues with IE9,"Since Jasmine doesn't support beforeAll and afterAll, I was using something like this:
beforeAll()
it('example 1', ...)
it('example n', ...)
runs(afterAll)
Although not documented anywhere, this has worked fine for me in all browsers until I figured out today that it doesn't in IE9.
I don't want to add a ""it('afterAll', afterAll)"" to the output. Maybe ""it"" could support a single argument and don't show up in the report in that case?",rosenfeld,NONE,2012-06-06 13:35:11+00:00,True,2013-05-27 16:25:04+00:00,355.12,,2,3,2012-06-06 13:38:43+00:00,0.0,rosenfeld,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
236,Spy Restore(),"This idea comes from sinon.js where you can setup a spy then later on restore it back to the original method in the case you no longer need or want the spy.
This works well when having a spy setup that is used in most cases but in the rare case it isn't, it's more useful to set one up then for the special case remove it.
Note: this does not clean up after itself for removeAllSpies but doesn't have any bad side effects.
jasmine.Spy.prototype.restore = function() {
  this.baseObj[this.methodName] = this.originalValue;
};
describe('Spies', function() {
  it('should restore spied function', function() {
    var originalFunctionWasCalled = false;
    var TestCase = {
      someFunction: function() {
        originalFunctionWasCalled = true;
        return 'return value from original function';
      };
    };
    this.spyOn(TestClass, 'someFunction');

    TestClass.someFunction.restore();
    expect(TestClass.someFunction()).toEqual('return value from original function');
    expect(originalFunctionWasCalled).toEqual(true);
  });
});",vizjerai,NONE,2012-06-06 18:38:26+00:00,True,2015-02-27 22:41:18+00:00,996.17,,26,44,2012-06-06 18:44:53+00:00,0.0,ragaskar,CONTRIBUTOR,1,5,0,20,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
238,The link to BDD is broken,The link to BDD in the Grouping Related Specs with describe section is broken.,tundal45,NONE,2012-06-07 12:04:56+00:00,True,2012-07-07 17:50:40+00:00,30.24,,2,1,2012-07-07 17:50:40+00:00,30.24,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
239,"Homepage typo, #included_Matchers","http://pivotal.github.com/jasmine/#section-Included_Matchers
Jasmine as a rich set
Jasmine Has a rich set",gnoireaux,NONE,2012-06-11 10:45:09+00:00,True,2012-07-07 17:48:42+00:00,26.29,,2,1,2012-07-07 17:48:41+00:00,26.29,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
240,Diff-ing objects that fail to match,"Currently, if one object is expected toEqual to another, but actually doesn't, jasmine simply dumps the JSON for both, telling they're different. Instead, would be nice to pretty-print and diff them, showing which properties aren't equal.",ikr,NONE,2012-06-13 10:11:44+00:00,True,2013-05-27 16:28:23+00:00,348.26,,4,3,2012-09-21 17:36:12+00:00,100.31,eventualbuddha,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
243,Compare string parameter with toHaveBeenCalledWith(regexp),"Hi!
I couldn't find a way to check a string that was passed to a function with toHaveBeenCalledWith, using a regexp.
In particular, I'm  passing URL with timestamp, and I'd like to validate it with something like
In code I have:
GET('/post?' + (new Date()).getTime())

In test want to do something like:
expect(GET).toHaveBeenCalledWith(/\/post?\d+/)

Is there any way to do this or, at least, check a string argument with regexp?",brabadu,NONE,2012-06-18 08:27:42+00:00,True,2013-10-02 21:44:26+00:00,471.55,,4,5,2013-02-12 20:04:55+00:00,239.48,zealoushacker,NONE,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
244,Match dom elements from full list with related dom element in failing list,"The full list of specs and the list of failures don't have any ties to one another. I've built a scrapper using PhantomJS and would like to build command line output that is tiered like the full list of specs, but still also show the error messages from the failures list. Maybe if the matching elements had some data- attribute that could just be a sequential number so there was some way to tie them together.",joeytrapp,NONE,2012-06-21 04:13:48+00:00,True,2013-05-27 16:39:37+00:00,340.52,,2,1,2013-05-27 16:39:33+00:00,340.52,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
245,Jasmine.Clock doesn't work when passing strings to setTimeout,"When passing a String to setTimeout Jasmine.Clock fails, cause it doesn't check if the passed argument is an function or an string:
dummy_method = function(callback) {
  fire_callback = function() {
    callback();
  }
  setTimeout(""fire_callback()"", 1000);
}

describe ""jQuery.fn.countdown"", ->
  beforeEach () ->
    jasmine.Clock.useMock()
  it 'should fireup the callback', ->
    countdown_callback = jasmine.createSpy('countdown_callback');

    dummy_method(countdown_callback)
    jasmine.Clock.tick(1001)
    expect(countdown_callback).toHaveBeenCalled()

This test failed. I am aware that passing a string instead of a function is bad style but its valid and so the test should pass.",eskimoblood,NONE,2012-06-23 15:07:56+00:00,True,2013-05-27 16:41:03+00:00,338.06,,2,1,2013-05-27 16:40:59+00:00,338.06,infews,CONTRIBUTOR,0,1,0,0,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
247,Jasmine goes into infinite loop if loaded twice,"If loaded more than once, jasmine.Clock.real will no longer contain the real methods, and any call to say setTimeout will call itself and goes into an infinite loop.
This happens in Safari, and maybe IE as well.
(We are using js-test-driver + code coverage, which leads to Jasmine getting loaded twice, we have no control over it...)",coli,NONE,2012-07-05 17:14:09+00:00,True,2012-10-30 19:58:39+00:00,117.11,,3,4,2012-07-05 20:52:50+00:00,0.15,coli,NONE,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
248,WinJS support,"Are you planning to add support to WinJS library to test Windows8 JavaScript applications?
Thank you.",vgaltes,NONE,2012-07-05 19:49:53+00:00,True,2012-07-07 17:47:57+00:00,1.92,,2,1,2012-07-07 17:47:56+00:00,1.92,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
250,Jasmine:ci rake target broken with rspec 2.11.0,"A new version of rspec was released yesterday and it seems to be breaking this rake target. The backtrace is as follows:
$ bundle exec rake jasmine:ci
/home/justin/.rvm/rubies/ruby-1.9.3-p194/bin/ruby -S rspec /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/jasmine-1.2.0/lib/jasmine/runner.rb --colour --format progress
[2012-07-08 22:30:01] INFO  WEBrick 1.3.1
[2012-07-08 22:30:01] INFO  ruby 1.9.3 (2012-04-20) [x86_64-linux]
[2012-07-08 22:30:01] WARN  TCPServer Error: Address already in use - bind(2)
[2012-07-08 22:30:01] INFO  WEBrick::HTTPServer#start: pid=7143 port=36189
Waiting for jasmine server on 36189...
jasmine server started.
Waiting for suite to finish in browser ...
/home/justin/.rvm/gems/ruby-1.9.3-p194/gems/jasmine-1.2.0/lib/jasmine/spec_builder.rb:93:in `declare_suite': undefined method `describe' for #    <Jasmine::SpecBuilder:0x00000002f05e68> (NoMethodError)
from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/jasmine-1.2.0/lib/jasmine/spec_builder.rb:87:in `block in declare_suites'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/jasmine-1.2.0/lib/jasmine/spec_builder.rb:86:in `each'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/jasmine-1.2.0/lib/jasmine/spec_builder.rb:86:in `declare_suites'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/jasmine-1.2.0/lib/jasmine/runner.rb:32:in `<top (required)>'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/rspec-core-2.11.0/lib/rspec/core/configuration.rb:780:in `load'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/rspec-core-2.11.0/lib/rspec/core/configuration.rb:780:in `block in load_spec_files'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/rspec-core-2.11.0/lib/rspec/core/configuration.rb:780:in `map'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/rspec-core-2.11.0/lib/rspec/core/configuration.rb:780:in `load_spec_files'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/rspec-core-2.11.0/lib/rspec/core/command_line.rb:22:in `run'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/rspec-core-2.11.0/lib/rspec/core/runner.rb:69:in `run'
 from /home/justin/.rvm/gems/ruby-1.9.3-p194/gems/rspec-core-2.11.0/lib/rspec/core/runner.rb:8:in `block in autorun'

If I lock the rspec version to 2.10.0 the error does not occur, so I believe this may be a new bug. This was generated from a fresh project using 'bundle exec jasmine init', running Ruby 1.9.3-194. I'm by no means proficient with Ruby yet so if I'm missing any details please let me know.
Edit: I also tried running against the HEAD revision of jasmine, same problem.
Edit2: I just noticed this should really be on the 'jasmine-gem' project - I don't want to make duplicate issues and I can't see how I can delete and move it, so I'll leave myself to the mercy of the admins!",justinberry,NONE,2012-07-08 12:57:26+00:00,True,2012-08-14 20:31:56+00:00,37.32,,4,3,2012-07-18 14:13:33+00:00,10.05,ryanpagel,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
252,Uncaught exception in beforeEach allows test block to run,"We would expect that if an exception is thrown in a beforeEach block then any dependent test blocks should not run. Currently it captures the exception in both the beforeEach and the it block and outputs them to the runner.
e.g.
describe(""Before each exceptions"", function() {
   beforeEach(function() {
      console.log(""In the before each"");
      throw 'Before each exception';
   });

   it('should not run', function() {
      console.log(""You should never see me"");
      throw 'This exception should not be logged in the jasmine runner';
   });
});",pivotal-medici,NONE,2012-07-11 18:16:30+00:00,True,2012-07-11 19:10:45+00:00,0.04,,2,2,2012-07-11 19:10:45+00:00,0.04,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
255,update jsdoc for jasmine.Spy.html,"The documentation for jasmine.Spy.html for the andCallFake() method contains examples using andCall(), which can't be resolved.  andCallFake() appears to work.  I can't locate the document in the repo to update, if you can point me to it I can pull.",mdineen,NONE,2012-07-16 18:35:45+00:00,True,2013-05-27 16:45:28+00:00,314.92,,2,1,2013-05-27 16:45:22+00:00,314.92,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
256,waits() missing in documentation on http://pivotal.github.com/jasmine/,"Hi,
I think waits() is missing in the documentation on http://pivotal.github.com/jasmine/. Maybe you can add it (add a test ;)).
Kind regards
Marc",mdix,NONE,2012-07-17 13:45:14+00:00,True,2012-07-17 14:24:56+00:00,0.03,,2,1,2012-07-17 14:24:55+00:00,0.03,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
259,toEqual returns wrong results for RegExps,"This should not pass, but does:
expect(/a/gi).toEqual(/a/);

This should not pass, but does:
expect(/a/).toEqual(/b/);

This should pass, but does not:
var regexp = /a/;
regexp.x = true;
expect(regexp).toEqual(/a/);
The reason it should pass is that, IMO, toEqual for regexes should compare only source, global, ignoreCase, multiline, and sticky properties, since those are the only properties that are generally relevant for regex objects. For comparison, that's how QUnit's deepEqual works for regex objects. Also, copying a regex using new RegExp(regexp) does not preserve other properties.
Accepting pull request #234 should fix all of these cases, but I figured my first two examples here, at least, needed their own issue. Even if #234 isn't accepted, expect(/a/).toEqual(/b/) obviously should not pass. This is causing a significant number of my tests to break.",slevithan,NONE,2012-07-21 22:03:45+00:00,True,2013-05-26 19:27:10+00:00,308.89,,4,4,2012-08-12 16:40:41+00:00,21.78,infews,CONTRIBUTOR,0,2,0,1,"['bug', 'has Tracker story']",False,False,False,False,False,False,False,False,True,False,False,True,False,False,False
261,Accidental delete on wiki,"Oops.
I accidentally deleted the 'Asyncronous specs' wiki page due to an itchy trigger finger and not really paying attention to what I was doing.
I readded the text, but have no idea of what the Markup was so I hope you can revert that change since I can't.
SORRY!!!!!",jamespwright,NONE,2012-07-25 18:36:54+00:00,True,2012-08-12 16:32:03+00:00,17.91,,2,1,2012-08-12 16:32:03+00:00,17.91,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
262,jquery 1.7.1 and 1.7.2 breaks jasmine tests,"We are using jquery_ujs (https://github.com/rails/jquery-ujs) for handling our ajax requests, when we've upgraded jquery from 1.6.4 to 1.7.1 it broke our tests. Specifically with regards to the binding of live events on jquery_ujs library.
e.g. $('a[data-confirm], a[data-method], a[data-remote]').live('click.rails', function() {
//handle ajax request
});
Since live method is deprecated in 1.7.1 we've upgraded the jquery_ujs library to it's latest which is now using delegate method for binding of events which calls our ajax requests.
e.g. $(document).delegate('a[data-remote]', 'click.rails', function(e) {
//handle ajax request
});
I've found out this issue when I reverted our upgrade from 1.7.2 to 1.6.4, sames goes with 1.7.1. Does anyone knows how to fix this issue or has it already been fixed or is there a patch for this? I'm pretty sure the sequence of my js files are correct. I just don't know why all my event bindings got unbind when running the tests.
Thanks",marcagas,NONE,2012-07-27 03:28:32+00:00,True,2012-08-10 20:09:15+00:00,14.69,,3,4,2012-07-27 04:20:23+00:00,0.04,,NONE,0,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
263,Incorrect handling of empty pages/suites,"A page with a test-suite with no test specs throws exception and does not produce HTML report:
Uncaught TypeError: Cannot call method 'suiteComplete' of undefined jasmine-html.js:91
Sample code:
describe('Empty test suite', function () {
});
Empty test page with no suites at all fails too:
Uncaught Error: NOT_FOUND_ERR: DOM Exception 8 jasmine-html.js:285
I am using Jasmine 1.2.0 with HTML reporter and runner as described in documentation.",bajtos,NONE,2012-07-29 08:25:15+00:00,True,2013-10-02 22:35:24+00:00,430.59,,4,4,2012-08-12 16:28:20+00:00,14.34,infews,CONTRIBUTOR,1,1,0,1,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
265,More Clarity in Tests,"I am using multiple expect() in an it() block.
But the problem is if I have similar expect's, then when an expect fails, it doesn't tell me which expect() failed actually. That information would be quite helpful.
It does gives the JS line number, but I am using CoffeeScript to generate my Specs, so line numbers mis-match.
Any idea on this ? Maybe there are better ways ? Would like to know more!",gitbase,NONE,2012-08-09 06:36:14+00:00,True,2013-05-27 16:49:47+00:00,291.43,,2,2,2012-08-11 17:32:30+00:00,2.46,,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
266,Object comparison is broken for wrapped native and frozen objects,"The jasmine.Env.prototype.compareObjects_ function temporarily adds __Jasmine_been_here_before__ to both objects being compared.  This fails silently for ES5 frozen objects, causing the method to recurse infinitely for cyclic objects, and fails by throwing an NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN for all WrappedNative objects in XULRunner applications (such as Firefox/Thunderbird extensions).  Please consider replacing the implementation with one that does not modify the objects under comparison (e.g. a stack-based cycle detection algorithm such as the Underscore.js equals implementation).",kevinoid,CONTRIBUTOR,2012-08-09 19:30:26+00:00,True,2013-05-29 19:40:28+00:00,293.01,,3,15,2012-08-12 16:19:36+00:00,2.87,infews,CONTRIBUTOR,0,2,0,1,"['bug', 'has Tracker story', 'waiting']",True,False,False,False,False,False,False,False,True,False,False,True,False,False,False
267,Jasmine does not reset spy after each test suite,"I have the following spec.
describe(""SN.ExitHistory"", function() {

var exitHistory;

beforeEach(function() {

SN.Utils = jasmine.createSpy(""utils"").andCallFake(function() {
function readSNCookie(cookieName, key) {
return ""google.com"";
}

function isUndefinedOrNull(param) {
return (param == null) || (param === ""null"");
}

function createSNCookie(snCookieName, key, value, lifeTime) {

}

var me = {
readSNCookie : readSNCookie,
isUndefinedOrNull : isUndefinedOrNull,
createSNCookie : createSNCookie
};
return me;

})();
exitHistory = SN.ExitHistory();

});

it(""return last exit link"", function() {
expect(exitHistory.getLastExitLink()).toEqual(""google.com"");
});

});

exitHistory.getLastExitLink internally uses SN.Utils.
After the test is done Jasmine does not remove the spy object utils. In next test suite also I can see the same utils present. Is there any way to reset the spy object after each test is done?
Instead of creating spy, if I create a new object for utils, behavior is same. Then what is the difference between a spy and actual object in this scenario.
Correct me if I am wrong.",sourabhchaki,NONE,2012-08-10 09:02:07+00:00,True,2012-08-14 20:35:55+00:00,4.48,,3,2,2012-08-10 14:05:25+00:00,0.21,lukeasrodgers,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
268,"Usage of reserved word, `for`","You are currently using the reserved word, for, on this line. This attribute should be quoted to allow it to work in older browsers that are less lenient. Here is how I have adapted the line to get it to work.
self.createDom('label', { className: 'label', 'for': 'no_try_catch' }, 'No try/catch'),",Olical,CONTRIBUTOR,2012-08-14 22:42:33+00:00,True,2012-08-15 21:28:45+00:00,0.95,,2,3,2012-08-15 19:46:06+00:00,0.88,Olical,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
271,Jasmine runs again and again,"Hi guys,
I'm using Jasmine in a RoR application through the jasminerice gem. I've implemented 32 examples without problems. Now,  when I describe a new example and I go to the page http://localhost:3000/jasmine it runs again and again showing the error about the spec don't implemented.
Can anybody help me?, please",emadridm,NONE,2012-08-15 20:17:05+00:00,True,2012-08-16 14:36:23+00:00,0.76,,1,2,2012-08-16 03:59:26+00:00,0.32,,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
273,"toThrow assertion is too limited, system exception are not equals between browsers","The following method is too limited http://pivotal.github.com/jasmine/jsdoc/symbols/jasmine.Matchers.html#toThrow
For example we have mismatch like:
[Cannot read property 'address1' of undefined] , but it threw [Cannot read property ""address1"" from undefined]
We need an assert like: toThrowContainsInMessage('undefined', 'address1')",SebTardif,NONE,2012-08-24 15:12:12+00:00,True,2012-09-03 00:33:26+00:00,9.39,,2,1,2012-09-03 00:33:26+00:00,9.39,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
274,Include skipped specs in report?,I would like for specs and suites which are skipped (either with xit() or perhaps some other way) to be present in the results object to make it possible to display them. I believe Rspec does this. I'd like to be able to use pending tests as a sort of todo list.,gregsabo,NONE,2012-08-24 16:02:43+00:00,True,2013-03-27 06:08:59+00:00,214.59,,8,16,2012-09-06 06:08:09+00:00,12.59,infews,CONTRIBUTOR,1,1,0,6,['has Tracker story'],False,False,False,False,False,False,False,False,True,False,False,False,False,False,False
275,Infinitive loop,"I'm working with phantomjs and with certain conditions (don't know yet how to reproduce it), jasmine gets into a infinitive loop.
RangeError: Maximum call stack size exceeded.
http://localhost/jasmine.js:1685
http://localhost/jasmine.js:1685
http://localhost/jasmine.js:1685
http://localhost/jasmine.js:1685",plusgut,NONE,2012-08-28 08:34:09+00:00,True,2012-12-07 17:04:43+00:00,101.35,,5,7,2012-09-02 23:26:55+00:00,5.62,infews,CONTRIBUTOR,0,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
276,Standalone release: wrong order of the comments in SpecRunner.html,"Comments (and following includes) should be vice versa.
  
  <script type=""text/javascript"" src=""spec/SpecHelper.js""></script>
  <script type=""text/javascript"" src=""spec/PlayerSpec.js""></script>
  
  <script type=""text/javascript"" src=""src/Player.js""></script>
  <script type=""text/javascript"" src=""src/Song.js""></script>",steffenlohaus,NONE,2012-08-30 11:24:28+00:00,True,2013-03-06 06:59:37+00:00,187.82,,2,1,2013-03-06 06:59:37+00:00,187.82,infews,CONTRIBUTOR,0,1,0,0,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
277,Weird failures in linux,"Hi when running my test suite in linux I get weird errors like this:
  Failed: questions.js can add options to select should be able to add options.
    Expected 3 to equal 3.
    in :

  Failed: questions.js can add options to select should be able to remove existing options.
    Expected 2 to equal 2.

When I run this on my computer instead of the CI server tests pass.",EnriqueVidal,NONE,2012-09-01 21:52:04+00:00,True,2013-03-06 17:26:27+00:00,185.82,,2,3,2012-09-01 22:09:52+00:00,0.01,infews,CONTRIBUTOR,0,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
278,"Renaming the ""it"" function","Hi,
In my code base, there is a global ""it"" object that is used throughout the JavaScript. Is it possible to rename Jasmine's ""it"" function to something else so I can test my code before making big refactoring changes, and where would I do that?
Any help would be most appreciated. Thanks!
Tariq",tariqislam,NONE,2012-09-04 16:36:53+00:00,True,2012-09-06 06:00:08+00:00,1.56,,2,1,2012-09-06 06:00:08+00:00,1.56,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
279,"Allow spies to be easily-extended, w/o modifying Jasmine code, like Matchers do","It is a feature request.
I think it would be very nice if we'd have an ability to extend spies functionality without modifying basic Jasmine code, in the similar way we do with matchers using addMatcher.
I see users want a lot of rare or commonly used features from spies (like checking if one spy was called before another or even check the order of the spies calls (which for sure may be uncomfortly achieved with a sequences of call-next-then-reset)).
Currently, createSpy returns a function that is extended with some properties, this function (spyObj) is inside of a closure, so it is not accessible at all, and to substitute it we need to create somewhat like a proxy object to the actual spy.",shamansir,NONE,2012-09-10 12:45:14+00:00,True,2012-10-06 00:15:22+00:00,25.48,,2,2,2012-09-10 13:06:05+00:00,0.01,shamansir,NONE,0,1,0,1,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
282,CSS error exposed by htmlunit,"in jasmine.css, line 12:
#HTMLReporter .symbolSummary { overflow: hidden; *zoom: 1; margin: 14px 0; }

notice the ""*zoom"", which should just be ""zoom"".
htmlunit reports the warning as well:
Aug 17, 2012 1:12:32 AM com.gargoylesoftware.htmlunit.DefaultCssErrorHandler error
WARNING: CSS error: [12:52] Error in style rule. Invalid token ""*"". Was expecting one of: , ""}"", "";"", .
Aug 17, 2012 1:12:32 AM com.gargoylesoftware.htmlunit.DefaultCssErrorHandler warning
WARNING: CSS warning: [12:52] Ignoring the following declarations in this rule.",simoami,NONE,2012-10-01 16:13:15+00:00,True,2012-10-06 00:10:22+00:00,4.33,,3,4,2012-10-06 00:10:22+00:00,4.33,ragaskar,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
284,Unit tests are failing in IE8,,abersager,NONE,2012-10-03 13:10:08+00:00,True,2012-10-03 15:53:55+00:00,0.11,,2,2,2012-10-03 15:54:20+00:00,0.11,abersager,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
285,Ability to differentiate between errors and failures,"Can Jasmine differentiate between them? A Failure is simply a failing test expectation whereas an Error is an execution that ends up running a ""catch"" block unexpectedly.
One instance where this is needed is when exporting Jasmine results as JUnit XML reports.
<testsuite time=""0.0010"" tests=""3"" skipped=""0"" failures=""0"" errors=""0"" name=""moving around two divs"">
    <testcase time=""0.0050"" name=""initially sees that div1 is above div2"" classname=""elementMoverSpec.js""/>
</testsuite>",simoami,NONE,2012-10-04 16:49:16+00:00,True,2012-10-06 00:07:57+00:00,1.3,,2,1,2012-10-06 00:07:57+00:00,1.3,ragaskar,CONTRIBUTOR,0,1,0,0,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
286,The report bar displays nested describe blocks in the wrong order,nested describe blocks are added last to the quick report display bar:,tenedor,NONE,2012-10-11 09:17:27+00:00,True,2013-10-02 23:14:18+00:00,356.58,,3,2,2013-05-27 17:12:40+00:00,228.33,infews,CONTRIBUTOR,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
287,Hard to copy the title of a failing spec,"It is currently styled in a way so that the entire red backdrop of it's title is clickeable.
While this is fine it actually makes it really hard to select the title to copy it and search for it in you $EDITOR.
This is my workflow when I find a broken test:

Click on it in jasmine to execute just it
Select its title
hit command-e (to get it into the search clipboard)
switch to $EDITOR
hit command-shift-f and enter to search it in the entire project

Voilla now I'm at the test and can start fixing it.
BUT: since the entire area is clickeable now, I can't start a selection anywhere over the link. Thus I have to start slightly below it, which means the ending newline and dot is also included in the copied text.
Then I have to remove that cruft after switching to my editors find in project feature.
And this is the problem.
My suggestion:

Remove the trailing dot - it serves no purpose
Change the markup / css so that only the text itself is clickeable and the area to the right of it can be used to start a selection.",dwt,NONE,2012-10-11 12:29:36+00:00,True,2013-05-27 17:27:07+00:00,228.21,,2,1,2013-05-27 17:26:57+00:00,228.21,infews,CONTRIBUTOR,0,1,0,0,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
289,jasmine.Clock.tick( 0 ) should not greedily call callbacks that get added while processing the call,"jasmine.Clock.tick(0) calls all callbacks that have previously been registered using setTimeout(). So far so good, but it also calls any callbacks which are added by the inital set of callbacks. This is not so good since it now is impossible to test that multiple callbacks are delayed in the JavaScript event loop instead of calling each other immediately.
I have code that must not call the callbacks immediately (since calling the callback immediately breaks a guarantee of the code; effectively the callback must not change any variables in the same event cycle). Therefore, the code uses setTimeout(callback1, 0) in order to defer the execution of the callback. The callback may use similar code with similar guarantees. Therefore, it also uses setTimeout(callback2, 0). Unluckily, Jasmine behaves differently for the first callback and for the second.
The problem is that in file mock-timeout.js in function jasmine.FakeTimer.prototype.runFunctionsWithinRange
the (next to) last line reads
jasmine.FakeTimer.prototype.runFunctionsWithinRange = function(oldMillis, nowMillies) {
    // ...

        this.runFunctionsWithinRange(oldMillis, nowMillis);
    }
}
This line runs any newly added functions. In my opinion, this is simply wrong. At least, there should be an option (e.g. to jasmine.Clock.tick()) to disable this behavior.
This spec triggers the problem:
describe( ""Jasmine should"", function() {
    var callback1, callback2;

    beforeEach( function() {
        jasmine.Clock.useMock();

        callback1 = jasmine.createSpy( ""callback1"" ).andCallFake( function() {
            setTimeout( callback2, 0 );
        });

        callback2 = jasmine.createSpy( ""callback2"" );
    });

    it( ""not call a scheduled function without calling Clock.tick() again"", function() {
        setTimeout( callback1, 0 );
        expect( callback1 ).not.toHaveBeenCalled();
        expect( callback2 ).not.toHaveBeenCalled();
        jasmine.Clock.tick( 0 );
        expect( callback1 ).toHaveBeenCalled();
        expect( callback2 ).not.toHaveBeenCalled();
        jasmine.Clock.tick( 0 );
        expect( callback1 ).toHaveBeenCalled();
        expect( callback2 ).toHaveBeenCalled();
   });
});",thaustein,NONE,2012-10-21 20:39:26+00:00,True,2012-10-22 19:34:21+00:00,0.95,,2,1,2012-10-22 19:34:20+00:00,0.95,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
293,waitsFor does not support an optional timeout value of 0,"The code that checks for the presence of an optional timeout uses a simple falsey guard operator. Consequently 0 fails and the default value is used instead.
I believe the code could read something like
if (value === null) : default : value;
(pseudo-code)
Thanks,",oatkiller,NONE,2012-11-05 15:15:46+00:00,True,2013-05-27 17:20:10+00:00,203.09,,2,1,2013-05-27 17:20:06+00:00,203.09,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
294,An error occurs if all `if`s are `xif`s.,"The error is like this:
Uncaught TypeError: Cannot call method 'suiteComplete' of undefined
Best,
Robert",oatkiller,NONE,2012-11-05 15:16:53+00:00,True,2013-05-27 17:21:56+00:00,203.09,,2,1,2013-05-27 17:21:52+00:00,203.09,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
296,Whitespace should be preserved in test output,"Several times now, I have been mislead by the test output because multiple consecutive whitespace characters are displayed as single spaces by the browser, and they even copy to the clipboard that way. For example, ...
Expected [ '1 2', '11 22', '111, 222' ] to equal [ '1 2', '11 22', '111, 222' ].

Perhaps, output should be wrapped in ""pre"" tags or something?",stevecj,NONE,2012-11-13 17:19:03+00:00,True,2013-03-04 06:27:57+00:00,110.55,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
297,Testrunner should not show 'success' if no specs have been executed,"This fools me annoyingly often when I filter down to one specific spec and then happen to change it's name to make it more descriptive.
And then suddenly my testsuite running in the background tells me that its green - o happiness.
Just to discover a millisecond later that I've fallen victim to this trap again. :-(
But more generall: executing no specs should not be seen as a success. It only verifies that the spec runnier is loaded correctly - not that the specs are found / configured, not that they compile/ interpret cleanly, not that your filter matches anything....
I think the sensible thing to do would be to show a first time message (yeah your testuite loads, thats great, now go add tests and this link descirbes how to do that).
Even better would be to not show this as green, but as kind of a failure in itself (here's hope you do that, but....)",dwt,NONE,2012-11-15 09:42:38+00:00,True,2013-10-02 22:52:53+00:00,321.55,,4,3,2013-03-24 11:03:56+00:00,129.06,wyuenho,NONE,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
299,Can't spyOn sessionStorage or localStorage methods in Firefox,"It's not possible to spyOn sessionStorage or localStorage methods in Firefox.  This works correctly in Chrome.
I have tried several methods.
Examples:

spyOn(window.sessionStorage, 'setItem');
window.sessionStorage.setItem('test', 'test2');
expect(window.sessionStorage.setItem).toHaveBeenCalledWith('test', 'test2');

This passes on Chrome but in Firefox the error is 'window.sessionStorage.setItem is not a function'.  On closer expection the typeof window.sessionStorage.setItem is 'string' after spying.

window.sessionStorage.setItem = jasmine.createSpy();
window.sessionStorage.setItem('test', 'test2');
expect(window.sessionStorage.setItem).toHaveBeenCalledWith('test', 'test2');

This passes on Chrome but again Firefox has the same error.

window.sessionStorage = {
setItem: jasmine.createSpy()
}
window.sessionStorage.setItem('test', 'test2');
expect(window.sessionStorage.setItem).toHaveBeenCalledWith('test', 'test2');

This fails in all browsers, as expected.
Does anyone have any information/help on a fix for this?",tomcooksey,NONE,2012-11-22 12:05:00+00:00,True,2012-11-22 20:59:07+00:00,0.37,,15,23,2012-11-22 12:24:42+00:00,0.01,keithamus,NONE,0,1,0,14,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
300,Release notes are out of date,https://github.com/pivotal/jasmine/wiki/Release-Notes,blalor,NONE,2012-11-22 12:50:53+00:00,True,2013-05-27 18:56:57+00:00,186.25,,2,1,2013-05-27 18:56:50+00:00,186.25,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
302,getLocation error when redirecting trivialReporter output,"Hi,
I just played around with redirecting the trivial Reporter output into a separate div to allow the regular webpage to render in the background and I ran into a problem because getLocation was not defined.
I think the error is due to the getLocation function in the trivial reporter where it should be
jasmine.TrivialReporter.prototype.getLocation = function() {
return document.location;
};
instead of the current
jasmine.TrivialReporter.prototype.getLocation = function() {
return this.document.location;
};
which of course also works fine as long as this.document == document.
Best
Tim",TimHarder,NONE,2012-11-26 11:56:27+00:00,True,2013-03-04 05:43:39+00:00,97.74,,2,1,2013-03-04 05:43:39+00:00,97.74,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
303,1.3.0 Nothing in IE7/8,"Updated jasmine from 1.2 to 1.3. So. Tests wan't run. In 1.2.0 all OK.
See line 157:57. for - our hero.",akaspin,NONE,2012-11-29 00:57:12+00:00,True,2012-12-03 18:06:21+00:00,4.71,,2,4,2012-12-03 00:43:22+00:00,3.99,akaspin,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
304,Chinese Support Issue on Jasmine / PhantomJS,"I have wrote a simple test in Jasmine:
--test--
describe(""Hello world"", function() {
it(""中文测试"", function() {
expect(helloWorld()).toEqual(""大家好!"");
});
});
-- code --
function helloWorld() {
return ""大家好!"";
}
I run it usig testacular, but this test passed in FireFox but failed in PhantomJS
C:\node.js>testacular start
error (reporter): Reporter ""coverage"" does not exist!
PhantomJS 1.7 (Windows): Executed 0 of 1 DISCONNECTED (0.062 secs / 0 secs)
PhantomJS 1.7 (Windows): Executed 0 of 1 DISCONNECTED (0.062 secs / 0 secs)
Firefox 7.0 (Windows): Executed 1 of 1 SUCCESS (0.109 secs / 0.011 secs)
However, it I changed the it session to English only like this
describe(""Hello world"", function() {
it(""HelloWorldTest"", function() {
expect(helloWorld()).toEqual(""大家好!"");
});
});
all test will pass
C:\node.js>testacular start
error (reporter): Reporter ""coverage"" does not exist!
PhantomJS 1.7 (Windows): Executed 1 of 1 SUCCESS (0.031 secs / 0.002 secs)
Firefox 7.0 (Windows): Executed 1 of 1 SUCCESS (0.11 secs / 0.008 secs)
TOTAL: 2 SUCCESS
I am not sure this is a Jasmine issue or a PhantomJS issue",adwu73,NONE,2012-12-02 03:03:16+00:00,True,2013-03-04 06:22:47+00:00,92.14,,2,1,2013-03-04 06:22:47+00:00,92.14,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
306,introduction.js typo,"On http://pivotal.github.com/jasmine/#section-Grouping_Related_Specs_with_describe
Replace the word ""contatenated"" with ""concatenated"".
Is there a way to edit this file from within the repo?
I couldn't find where it's located.",Ore4444,NONE,2012-12-03 22:24:44+00:00,True,2013-03-26 21:01:37+00:00,112.94,,2,1,2013-03-26 20:27:01+00:00,112.92,dguzzo,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
308,jasmine 1.3.1 crashes - uninitialized constant Jasmine::Config,"On a recent project, I upgraded to jasmine 1.3.1 and rake started failing with uninitialized constant Jasmine::Config.  Downgrading to jasmine 1.3.0 fixes things.  But since you just released, I thought it might be worth mentioning.
#Gemfile (trimmed)
gem 'rails', '3.2.8'
...
group :development, :test do
  gem 'rspec'
  gem 'rspec-rails'
  gem 'jasmine'                                                                     
  gem 'jasmine-rails'
  gem 'jasmine-headless-webkit'
  ... 
end

Here's the versions from the Gemfile.lock
 jasmine (1.3.1)                                                                 
   jasmine-core (~> 1.3.1)
   rack (~> 1.0)
   rspec (>= 1.3.1)
   selenium-webdriver (>= 0.1.3)
   jasmine-core (1.3.1)

And the failure
$ be rake --trace
** Invoke default (first_time)
** Invoke spec (first_time)
** Invoke db:test:prepare (first_time)
** Invoke db:abort_if_pending_migrations (first_time)
**  Invoke environment (first_time)
** Execute environment
rake aborted!
uninitialized constant Jasmine::Config
/Users/jon/.rbenv/versions/1.9.3-p327/lib/ruby/gems/1.9.1/gems/jasmine-rails-0.2.2/config/initializers/sprockets.rb:6:in `<top (required)>'
/Users/jon/.rbenv/versions/1.9.3-p327/lib/ruby/gems/1.9.1/gems/railties-3.2.8/lib/rails/engine.rb:588:in `block (2 levels) in <class:Engine>'
/Users/jon/.rbenv/versions/1.9.3-p327/lib/ruby/gems/1.9.1/gems/railties-
...

This is running under ruby-1.9.3-p327.",bunnymatic,NONE,2012-12-05 00:02:55+00:00,True,2012-12-05 00:12:12+00:00,0.01,,2,3,2012-12-05 00:12:12+00:00,0.01,bunnymatic,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
310,Global leak detection support,"Would be nice if Jasmine has something like this builtin:
http://tobyho.com/2011/10/14/checking-for-global-leaks-in-unit-tests/",wyuenho,NONE,2012-12-13 17:33:55+00:00,True,2012-12-13 21:47:00+00:00,0.18,,3,5,2012-12-13 21:47:00+00:00,0.18,ragaskar,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
311,With Squire.js Tests Run Always Positive No Matter What. ,"I'm using Require.js to use AMD in my project. I use it in my project and in my Jasmine tests with no problems.
I'm using Squire.js to mock my DAO classes in my Services. When I expect the test to fail in a simple as a true to be false the test should fail but it does not fail. Even expect 2 to be 3 runs positive and green but only inside the require space like so:
define(
[
""Squire"",
""DAO/MockUserDAO""
],
function(Squire,MockUserDAO){
describe(""UserService"",function(){
        it(""should return an array of  4 users on getAll()"",function(){

            var squire = new Squire();

            squire.mock([""DAO/UserDAO""],MockUserDAO)
                .require([""services/UserService""], function(UserService){
                            var userCount = UserService.getAll().length;
                            expect(2).toBe(1);  // DOES NOT FAIL!
                        }); 

        });

        it(""should return true"",function(){
            expect(true).toBe(false);  // FAILS as expected.
        });


    }); 

}

);",Millad,NONE,2012-12-20 02:12:39+00:00,True,2012-12-20 12:37:05+00:00,0.43,,1,1,2012-12-20 12:37:19+00:00,0.43,Millad,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
314,The error message is the wrong way around,"If you have the below test, the error result from Jasmine comes back as Expected undefined to be 'fred'. but it should actually be Expected 'fred' to be undefined.
function returnSecondArg(firstArg, secondArg) {
   return secondArg;
 }

expect(returnSecondArg(""only give first arg"")).toBe(""fred"");",jchannon,NONE,2013-01-08 12:13:13+00:00,True,2013-01-08 15:24:51+00:00,0.13,,3,5,2013-01-08 14:11:22+00:00,0.08,joshuacc,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
315,Compiled Assets not compiling unless body=false,"So my company's test suite, when we upgraded from Jasmine 1.2.0 to the current 1.3.1, various javascript files were not being compiled into the asset pipeline, and the .erb files were being loaded, instead of the compiled js files, and we saw that certain files were not being loaded from the //= loads.
We fixed the issue by adding body=false in the jasmine.yml file, ie, assets/application.js?body=false.
I'm not sure if this behavior is correct or not, but I wanted to point it out, since in the previous version this behavior was not occurring.",wchenvr,NONE,2013-01-09 20:38:58+00:00,True,2013-10-02 21:05:05+00:00,266.02,,4,4,2013-01-09 21:39:42+00:00,0.04,ragaskar,CONTRIBUTOR,1,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
320,HtmlReporter: getting error in RequireJS environment: Cannot read property 'suites' of undefined,"Using Jasmine with RequireJS, I am occasionally seeing the following error:

I am unsure whether RequireJS is the cause here, but I suspect it is.
I found that modifying this line in the current source from:
this.views.specs[spec.id] = new jasmine.HtmlReporter.SpecView(spec, dom);
to:
this.views.specs[spec.id] = new jasmine.HtmlReporter.SpecView(spec, dom, this.views);
solved the issue. Is there a reason why this.views is not currently being passed in on specComplete?",fiznool,NONE,2013-01-23 12:51:25+00:00,True,2013-01-23 13:20:27+00:00,0.02,,5,6,2013-01-23 13:20:27+00:00,0.02,fiznool,NONE,0,0,0,5,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
322,extra properties in arrays are compared but not displayed,"Arrays are compared as objects and thus extra properties in the array are compared. But the error output doesn't display these extra properties.
You can verify this as follows:
var a = [1,2,3];
a.extra = 4;
expect(a).toEqual(a.slice(0));

This outputs:
Error: Expected [ 1, 2, 3 ] to equal [ 1, 2, 3 ].

In my case, I had a test like expect(a).toEqual([1,2,3]); which was failing, but it took me a while to figure out that the extra properties were the problem because they weren't in the output. Now I have it working like this expect(a.slice()).toEqual([1,2,3]);.
I think that if both values are arrays, they should be compared as arrays only. But if that's not acceptable, at least the output should be changed to include the extra properties.",mbest,NONE,2013-01-24 20:55:24+00:00,True,2013-05-27 19:36:45+00:00,122.95,,2,2,2013-05-27 19:35:39+00:00,122.94,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
325,favicon not found,"Does the framework zip file supposed to have a favicon included? It is linked on SpecRunner.html but not present in the package.
Here's the tag:",lquixada,NONE,2013-01-30 18:24:50+00:00,True,2013-03-04 05:17:12+00:00,32.45,,2,1,2013-03-04 05:17:12+00:00,32.45,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
326,Force Jasmine run to fail if any uncaught errors occur,"I think the test run should fail if any uncaught errors occur on the page.
We had a nasty situation where a compilation error in a Jasmine spec file caused the test run to pass as if nothing had gone wrong. The syntax error prevented the examples from being registered and it was as if the spec hadn't even existed. I can see how one syntax error could cause a whole spec to fall into decay if it isn't regularly touched.
I tried to hack in a fix as suggested at https://gist.github.com/mattyod/3911612 but the problem with this is getting that spec to load first before any of the others are evaluated. The hacky workaround is the name this file beginning with 'aaa' or something so it loads first.
Here's the Gist:  https://gist.github.com/brentsnook/4721960",brentsnook,NONE,2013-02-06 11:15:13+00:00,True,2014-06-23 03:09:55+00:00,501.66,,9,11,2013-02-06 15:05:44+00:00,0.16,ragaskar,CONTRIBUTOR,2,2,0,5,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
327,Browser / Jenkins CI / TestSwarm / Code coverage support,"We wrote all our tests using Mocha to find out it's not supported in IE6/7 (which is still a majority of users on some of our products, sadly)...
I'm looking around the interwebs trying to figure out the best testing framework for our company.
Supporting all browsers is CRUCIAL.  Ideally, we'd like to run our tests on CI and have the following things met:

 Supporting browsers as old as IE6.
 Can run on Jenkins CI
 Has code coverage
 Can run on TestSwarm

So, I'm sorry to bloat your issues!  I can close this shortly -- I just couldn't find anything regarding the above questions. 😢",j,NONE,2013-02-08 05:56:11+00:00,True,2013-10-02 22:58:19+00:00,236.71,,4,2,2013-02-08 15:18:32+00:00,0.39,ragaskar,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
328,Throw an error if user tries to register spec after execution,"// registering tests
describe('x', function() {...});

var jasmineEnv = jasmine.getEnv();

jasmineEnv.addReporter(new SomeReporter());
jasmineEnv.execute();


// this should throw an exception,
// as it won't get executed
describe('y', function() {...});
This can easily happen with async loading (eg. using require.js) and it's tricky to debug. I don't see any use case for registering specs after execution, as the there is a single global instance of jasmine env.
If there's interest in this feature, I'm happy to send a PR.",vojtajina,NONE,2013-02-11 18:34:22+00:00,True,2013-05-27 19:11:05+00:00,105.03,,2,3,2013-03-04 05:15:48+00:00,20.45,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
330,gh-pages `jasmine` symlink can cause build fail,"If you recursively clone submodules, and jasmine is one of your submodules, then a build step that attempts to copy files into a dist can choke on the jasmine symlink in this branch. The pages submodule gets cloned and seems to contain the problem.",necolas,NONE,2013-02-26 01:16:35+00:00,True,2013-05-27 18:37:33+00:00,90.72,,3,3,2013-03-18 15:49:41+00:00,20.61,tbrd,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
334,RangeError: Maximum call stack size exceeded when adding bootstrap.js,"I am using jasmine to run a bunch of unit tests against our angularJS app. There are a lot of supporting scripts and the issue seems to occur when the amount of script jasmine is looking at gets too high.
My steps for believing this:

We have 65 tests which run normally when bootstrap.js is not in our specrunner.htm.
I added <script type=""text/javascript"" src=""/scripts/bootstrap.min.js""></script> near the top of specrunner.htm.
Refresh the page and all 65 tests are failing with this message: ""RangeError: Maximum call stack size exceeded""
Further investigation by removing jquery and refreshing shows 14 tests failing, which are the tests that are trying to use jquery

This may not be a correct assessment though, because adding a few other heavy scripts to the page, such as microsoftAjax.js, doesn't seem to cause any issue. Maybe there is an issue with bootstrap?
specrunner.htm head section is below:

<script type=""text/javascript"" src=""/scripts/shared/jasmine/lib/jasmine-1.3.1/jasmine.js""></script>
<script type=""text/javascript"" src=""/scripts/shared/jasmine/lib/jasmine-1.3.1/jasmine-html.js""></script>

<script type=""text/javascript"" src=""/scripts/jquery-1.8.2.js""></script>
<script type=""text/javascript"" src=""/scripts/bootstrap.min.js""></script>

<script type=""text/javascript"" src=""/scripts/angular.js""></script>
<script type=""text/javascript"" src=""/scripts/angular-resource.js""></script>
<script type=""text/javascript"" src=""/scripts/angular-mocks.js""></script>
<script type=""text/javascript"" src=""/scripts/angular-ui.js""></script>
<script type=""text/javascript"" src=""/scripts/angular-ui-ieshiv.js""></script>
<script type=""text/javascript"" src=""/scripts/jquery.cookie.js""></script>
<script type=""text/javascript"" src=""/scripts/shared/jquery.formatcurrency-1.4.0.min.js""></script>
<script type=""text/javascript"" src=""/scripts/jquery.maskedinput.js""></script>

<script type=""text/javascript"" src=""/scripts/filters.js""></script>
<script type=""text/javascript"" src=""/scripts/directives.js""></script>
<script type=""text/javascript"" src=""/scripts/services.js""></script>
<script type=""text/javascript"" src=""/scripts/app.js""></script>
<script type=""text/javascript"" src=""/scripts/controllers.js""></script>


<script type=""text/javascript"" src=""../../tests/filters.spec.js""></script>
<script type=""text/javascript"" src=""../../tests/controllers.spec.js""></script>
<script type=""text/javascript"" src=""../../tests/functional.spec.js""></script>
<script type=""text/javascript"" src=""../../tests/services.spec.js""></script>
<script type=""text/javascript"" src=""../../tests/directives.spec.js""></script>

<script type=""text/javascript"">
    (function () {
        var jasmineEnv = jasmine.getEnv();
        jasmineEnv.updateInterval = 1000;

        var htmlReporter = new jasmine.HtmlReporter();

        jasmineEnv.addReporter(htmlReporter);

        jasmineEnv.specFilter = function (spec) {
            return htmlReporter.specFilter(spec);
        };

        var currentWindowOnload = window.onload;

        window.onload = function () {
            if (currentWindowOnload) {
                currentWindowOnload();
            }
            execJasmine();
        };

        function execJasmine() {
            jasmineEnv.execute();
        }

    })();

  </script>",wgwine,NONE,2013-02-27 21:54:55+00:00,True,2013-02-28 15:53:45+00:00,0.75,,3,6,2013-02-27 22:57:05+00:00,0.04,ragaskar,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
335,Typo in jasmine.util.inherit's documentation,"commit 3f911075bd86aa138aa46a00e7a960e9be5db769
Author: Johannes Laire <johannes@laire.fi>
Date:   Fri Mar 1 12:17:57 2013 +0200

    Grammar nazi

diff --git a/src/core/util.js b/src/core/util.js
index fa9dd21..cedc71b 100644
--- a/src/core/util.js
+++ b/src/core/util.js
@@ -4,7 +4,7 @@
 jasmine.util = {};

 /**
- * Declare that a child class inherit it's prototype from the parent class.
+ * Declare that a child class inherit its prototype from the parent class.
  *
  * @private
  * @param {Function} childClass",jlaire,NONE,2013-03-01 10:22:51+00:00,True,2013-03-04 05:12:07+00:00,2.78,,2,1,2013-03-04 05:12:07+00:00,2.78,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
337,toHaveBeenCalled fails when method is called from inside,"I have the following class:
var MyClass = function() {
    var method1 = function() {
        console.log('method1 called!');
    };

    var method2 = function() {
        method1();
    };

    return {
        method1 : function() {
            method1();
        },
        method2 : function() {
            method2();
        }
    };
}();
And in my test, i will call ""method2"" and i want to know if ""method1"" is called.
So i do:
describe('test myclass methods', function() {
    it('method2 should call method1', function() {
        spyOn(MyClass, 'method1').andCallThrough();
        MyClass.method2();
        expect(MyClass.method1).toHaveBeenCalled();
    });
});
The spec will fail with the following message:
""Expected spy method1 to have been called""
But if i change my implementation of ""method2"" to:
var method2 = function() {
    MyClass.method1()
};
The spec will pass!
It is a bug? If yes, where should i look to fix?
I tested this possible issue at tryjasmine.com
][`s,",renatodex,NONE,2013-03-08 14:08:30+00:00,True,2013-03-09 07:07:35+00:00,0.71,,4,3,2013-03-09 01:12:03+00:00,0.46,leoasis,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
338,Docs link pointing to 404,"See http://pivotal.github.com/jasmine/jsdoc/symbols/jasmine.Spy.html
Under jasmine.Spy, find the ""see:"" and click on spyOn. Watch the octo404.",pvdz,CONTRIBUTOR,2013-03-11 10:25:35+00:00,True,2013-03-27 06:11:31+00:00,15.82,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
339,Spy discard original arguments count,"I have some methods that make use of reflection to determine method arguments and decide what to do with them based on the arguments count, i.e.:
function fn(a, b, c, d) {}
if (fn.length) {
  ...
}
The matter is that I also need to spy on this method, and when I do so, the Spy overrides and remove all arguments from the original method.
Is that possible to spy on some method but still preserve its original arguments count (fn.length)? Shouldn't it be able?",caiotoon,CONTRIBUTOR,2013-03-12 03:43:41+00:00,True,2013-05-27 19:45:02+00:00,76.67,,2,1,2013-05-27 19:44:58+00:00,76.67,infews,CONTRIBUTOR,0,1,0,0,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
341,New jasmine-html.js documentation please?,"I'm trying to use the jasmine-html.js here https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/jasmine-html.js but I am getting errors.

Seems like new jasmine.HtmlReporter() now needs to be passed an object for options, which was not the case in 1.3.
If I pass an empty object, it complains later that createElement is undefined https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/jasmine-html.js#L204
I'm not sure what it expects for createElement, so I wrote a function that wraps document.createElement:

htmlReporter = new jasmine.HtmlReporter({
   createElement: function(type){
      return document.createElement(type);
   }
})
Now it loads but it's saying describe is undefined when my spec runs.
I am surprised that for a project this large, the documentation is so thin for the current release.  I would greatly appreciate any tips on getting this to work.",,NONE,2013-03-15 03:53:32+00:00,True,2013-03-17 19:44:07+00:00,2.66,,1,2,2013-03-17 19:12:35+00:00,2.64,ohaibbq,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
343,Allow toThrow() matcher to match a regular expression,"It would be very useful to be able to match the error message of the Error to a regular expression. Ex:
expect( function() {
    throw new Error( ""Invalid: xyz"" );
} ).toThrow( /Invalid/ );
Probably a fairly simply change. Would just run RegExp.test() on the Error's message.",gregjacobs,NONE,2013-03-16 17:26:36+00:00,True,2013-05-27 17:37:51+00:00,72.01,,5,8,2013-03-16 19:35:10+00:00,0.09,infews,CONTRIBUTOR,0,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
344,Using Matchers inside Custom Matchers,"Is it seriously this difficult to use matchers inside of custom matchers?
Jasmine doesn't explode when I do this -- it just seems to forget that there was an outer matcher that it was doing, as there is no mention of that matcher when it delivers the FAILED message.  Is that ok?  Is it ok to use matchers inside of matchers?  The docs don't say anything about this one way or the other.
It might be nice if a test author could get more control over this, by catching exceptions thrown by matchers.  Perhaps a test author wants to try something else if one matcher failed.",nickretallack,NONE,2013-03-18 21:58:17+00:00,True,2013-05-26 15:05:28+00:00,68.71,,1,1,2013-05-26 15:05:27+00:00,68.71,,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
346,Reference full path not working in specs,"I cannot set full path to *.js file in .
I can set the path of the folder containing only current project.",v-avdeev,NONE,2013-03-27 07:25:13+00:00,True,2013-03-28 17:38:45+00:00,1.43,,2,8,2013-03-27 16:23:55+00:00,0.37,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
348,"Why in Jasmine, we cannot put the expect in an outside function?","http://stackoverflow.com/questions/15893168/why-in-jasmine-we-cannot-put-the-expect-in-an-outside-function
If using Jasmine 1.3.1, I use
describe(""TryTry"", function() {

    var i;

    function checkForSituation(a) {
        // say, if this is made into a function because 
        //   there are a lot of processing

        console.log(""THERE"", a); 
        expect(foo(3, a)).toEqual( 3 + a );
    }

    for (i = 0; i < 5; i++) {
        console.log(""HERE"", i); 

        it(""should add for "" + i, function() {

            checkForSituation(i);

        });

    }

});

and foo is just:
function foo(a, b) {
    return a + b;
}

I would expect it to check for 0 to 4, and print out
HERE 0
THERE 0
HERE 1
THERE 1
  ...

but instead, it just print in Chrome's console as: HERE 0, HERE 1, ... and then THERE 5 five times.  Does somebody know why an expect cannot be put in an outside function like that and what to do in Jasmine if I need to put many steps into a function?
As a side note, sometimes in JavaScript, I feel like a whole new language is developed and what you can usually do won't work -- and wonder what can be done to prevent this type of things from happening, something without knowing that it would happen.
If you'd like to try it out, it is on https://github.com/jianlin/jasmine-looping-an-it-calling-function-that-does-expect",jianlin,NONE,2013-04-09 04:26:31+00:00,True,2013-07-25 05:15:02+00:00,107.03,,3,5,2013-04-15 04:11:18+00:00,5.99,sheelc,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
352,Install - phpstorm + windows 7,"Hi!
I'm trying to install jasmine, and run it from phpstorm on windows 7, but no success yet. :S
I found a jasmine js test driver adapter, but I think it works on linux only (I found only .sh files in that). Is there any way to run jasmine tests from the IDE, and not from browser?",inf3rno,NONE,2013-04-22 23:28:35+00:00,True,2013-04-23 05:27:58+00:00,0.25,,2,2,2013-04-22 23:34:08+00:00,0.0,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
354,"Add new spy matcher that checks this it's been called with, together with arguments","like
expect(spy).toHaveBeenCalledOn(expectedThis).with(expectedArguments);

toHaveBeenCalledWith should have been supported this.",yaroslav-ulanovych,NONE,2013-04-26 14:35:50+00:00,True,2013-05-30 09:47:11+00:00,33.8,,2,2,2013-05-29 17:20:40+00:00,33.11,infews,CONTRIBUTOR,0,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
355,Spy on classes,"I think the current spyOn function and the current createSpyObj function is not the best way to mock objects. I usually use classes and instantiate them....
This example code works with jasmine-node:
jasmine.createStub = function (cls, methods, args) {
    if (!(cls instanceof Function))
        throw new TypeError(""Invalid class param."");

    var mockClass = function () {
        this.constructor.apply(this, args || []);
    };

    mockClass.prototype = Object.create(cls.prototype);
    mockClass.prototype.constructor = cls;

    var wrap = function (method) {
        if (!mockClass.prototype[method] instanceof Function)
            throw new TypeError(""Cannot mock "" + method + "" it's not a function."");
        jasmine.getEnv().currentSpec.spyOn(mockClass.prototype, method);
    };

    if (methods) {
        if (!(methods instanceof Array))
            methods = [methods];
        if (methods.length == 1 && methods[0] == ""*"")
            for (var property in mockClass.prototype) {
                if (mockClass.prototype[property] instanceof Function)
                    wrap(property);
            }
        else
            for (var i = 0; i < methods.length; ++i) {
                var method = methods[i];
                wrap(method);
            }
    }

    return new mockClass();
};

Jasmine-node did not have the spyOn method in it's interface somehow... I found that getEnv().currentSpec.spyOn works too...
Example usage:
var MyClass = function () {
    console.log(""construct"");
};
MyClass.prototype.method= function () {
    console.log(""mock method"");
};

var mock1 = jasmine.createStub(MyClass, [""method""]);
// console: construct
mock.method.andCallThrough();
mock.method(); 
// console: mock method
expect(mock.method).toHaveBeenCalled();

var mock2 = jasmine.createStub(MyClass, [""constructor"",""method""]);
expect(mock2.constructor).toHaveBeenCalled();
expect(mock2.method).not.toHaveBeenCalled();

var mock3 = jasmine.createStub(MyClass, [*]);
expect(mock3.constructor).toHaveBeenCalled();
expect(mock3.method).not.toHaveBeenCalled();


var mock4 = jasmine.createStub(MyClass, [*]);
expect(mock4.constructor).toHaveBeenCalled();
mock4.method.andCallThrough();
mock4.method();
//console: mock method
expect(mock4.method).toHaveBeenCalled();

If this code is good enough for you, please add to the lib... If you already have a better way to create stubs, please tell me, because I did not find anything in your documentation...",inf3rno,NONE,2013-04-27 06:58:14+00:00,True,2013-05-29 20:08:36+00:00,32.55,,2,4,2013-05-27 17:33:00+00:00,30.44,infews,CONTRIBUTOR,0,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
359,Jasmine tests auto-restart if an exception is thrown,"One of my specs purposefully has bad code in a try/catch statement. However, anytime any spec in Jasmine has Javascript errors, Jasmine seems to reload the page at the end of the tests.
Is there a way to disable this ""feature""?",EvHaus,NONE,2013-05-01 16:27:41+00:00,True,2013-05-27 19:05:32+00:00,26.11,,2,1,2013-05-15 00:46:17+00:00,13.35,EvHaus,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
360,Spying on javascript internals,"I have a regression that I would like to test for, where Array.forEach() is assumed to exist (IE8 doesn't support it).
I have this spyOn(Array.prototype, 'forEach')... but unfortunately it's being called elsewhere in the execution cycle, possibly in some dependencies.  Is there any way to restrict the context in which the spy operates? I saw there was a jasmine-stealth library that adds some helpers but I am unsure of the best way to go about this.",c0bra,NONE,2013-05-06 17:26:47+00:00,True,2013-05-06 17:44:27+00:00,0.01,,1,1,2013-05-06 17:44:27+00:00,0.01,c0bra,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
361,jasmine.Clock.useMock doesn't mock Date,"It would be useful if jasmine.Clock.useMock mocked Date such that jasmine.Clock.tick incremented the times returned by Date after jasmine.Clock.useMock is called.  This would make it compatible with _.throttle, the implementation of which changed in jashkenas/underscore#820.",cwarden,NONE,2013-05-09 23:15:14+00:00,True,2014-02-27 19:58:18+00:00,293.86,,7,9,2013-05-10 00:40:56+00:00,0.06,infews,CONTRIBUTOR,0,1,0,5,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
362,Closure compilation error,"When I try to precompile assets with the closure compiler, I get the following error.
/Users/me/.rvm/rubies/ruby-1.9.3-p392/bin/ruby /Users/me/.rvm/gems/ruby-1.9.3-p392@global/bin/rake assets:precompile:all RAILS_ENV=staging RAILS_GROUPS=assets
/var/folders/zh/gs7k8cj16jb1tdhxjw7snrf00001_h/T/closure_compiler20130509-81279-zi7txr:86: ERROR - Invalid flags to RegExp constructor: STRING y 86 [source_file: /var/folders/zh/gs7k8cj16jb1tdhxjw7snrf00001_h/T/closure_compiler20130509-81279-zi7txr]
      var sticky_regexp = new RegExp(""[abc]"", ""y"");
                                              ^

1 error(s), 0 warning(s)
We are using closure like so
config.assets.js_compressor = :closure
With these versions in our Gemfile.lock
jasmine-core (1.3.1)
closure-compiler (= 1.1.6)",jesseshieh,NONE,2013-05-10 03:28:37+00:00,True,2013-10-02 18:50:09+00:00,145.64,,4,3,2013-05-10 13:44:19+00:00,0.43,lukeasrodgers,NONE,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
364,The markup in SpecRunner.html does not get torn down / redone between each test run,"I'm not sure if I've missed something but couldn't see it in documentation / an example anywhere but when I use SpecRunner.html the markup I provide does not seem to be 'refreshed' between each test.
Should I be putting my markup in the page in a div with a special id, or injecting it with some other mechanism?  Currently I've had to include a long string of markup and just insert that before each test - not ideal as html is not as easy to work with when in a js file!
(I also tried using jasmine-jquery to use fixtures, but there is a cross site issue in Chrome when running locally and I cannot expect other users to start Chrome up in a special way to overcome this each time)
Did I miss something or is this not a feature jasmine supports?",geek-caroline,NONE,2013-05-13 11:20:28+00:00,True,2013-05-15 16:23:25+00:00,2.21,,3,4,2013-05-14 17:22:21+00:00,1.25,joelmccracken,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
365,Have HtmlRunner support more ways to filter tests (e.g. by regular expression),"Hello! I currently do this with the following code:
class_mixer = ttm.require('lib/class_mixer')

class RegexpSpecFilter
  initialize: (@regexp)->
  forSpec: (spec)->
    spec.getFullName().toLowerCase().match @regexp

class_mixer RegexpSpecFilter

override_spec_filter_with = RegexpSpecFilter.build(/calc/)

if override_spec_filter_with
  env = jasmine.getEnv()
  env.specFilter = (spec)->
    override_spec_filter_with.forSpec spec
It would be very nice if something like this was supported natively by jasmine, though. Thoughts?",joelmccracken,NONE,2013-05-14 17:26:26+00:00,True,2014-06-23 04:10:30+00:00,404.45,,2,5,2013-06-24 17:22:44+00:00,41.0,joelmccracken,NONE,0,1,0,1,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
366,Move maximumSpecCallbackDepth as a constant on top,"I found it very unfortunate that this ""constant"" is tucked into the middle of the code in version 2.0-alpha, and I was looking for two days why I can't run more than 25 specs in a single run.
Could you move it up to the other ""constants"" on top?
Thank you.",mtomov,NONE,2013-05-15 07:32:18+00:00,True,2016-10-14 16:38:48+00:00,1248.38,,8,8,2013-10-31 21:23:59+00:00,169.58,sheelc,CONTRIBUTOR,1,1,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
367,expect( [] ).toEqual( {} ) passes: it should fail,"The reverse also passes, but should fail:  expect( {} ).toEqual( [] )
Using jasmine 1.3.1.",mattmoss,NONE,2013-05-16 01:03:26+00:00,True,2013-05-27 19:04:59+00:00,11.75,,2,1,2013-05-27 19:04:53+00:00,11.75,infews,CONTRIBUTOR,0,1,0,0,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
368,[Feature Request] UI to select which specs to run,"I'd like to have the ability to select which specs to run once I load Jasmine in the browser. Our application has tons of tests setup and we don't always want to run everything. Sometimes we're only interested in testing a specific component.
Although we could easily build this UI on our end, I believe this is something that should be built into Jasmine's UI. A simple select field that allows you to select which ""spec"" files to execute based on the list of available items. As well as an ""All"" option.
Thanks.",EvHaus,NONE,2013-05-22 02:40:52+00:00,True,2013-05-23 03:39:43+00:00,1.04,,2,3,2013-05-22 03:46:30+00:00,0.05,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
371,toThrow does not catch falsy exceptions,"it(""should detect falsy exceptions as thrown"", function() {
        expect(function() { throw undefined}).toThrow();
        expect(function() { throw ''}).toThrow();
    });
Currently yields:
Expected function to throw an exception.",rbu,NONE,2013-05-27 11:46:30+00:00,True,2013-05-27 17:34:11+00:00,0.24,,2,1,2013-05-27 15:19:29+00:00,0.15,infews,CONTRIBUTOR,0,1,0,0,['has Tracker story'],False,False,False,False,False,False,False,False,True,False,False,False,False,False,False
372,Spy.andThrow should throw default error,"it(""should throw a default error if no message is provided"", function() {
        var spy = jasmine.createSpy().andThrow()
        var exception;
        try {
            spy() 
        } catch (e) {
            exception = e
        }
        expect(exception).not.toBe(undefined);
        expect(exception).toBeInstanceOf(Error);
    });
Instead of throwing undefined by default, Jasmine could throw new Error()",rbu,NONE,2013-05-27 11:50:52+00:00,True,2013-05-27 15:26:15+00:00,0.15,,2,1,2013-05-27 15:26:10+00:00,0.15,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
373,Jasmine runs into infinite loop trying to stringify complex objects,"I'm running into an infinite loop in a Jasmine test that crashes the browser. The crash happens when I run a comparison and it fails; Jasmine's StringPrettyPrinter gets trapped in a circular reference.
I have a naïve fix (linked below) that simply bails out of the pretty printer if the stringified object becomes really long (>1000000 characters). I've found it hard to reproduce the problem in a simpler environment than the code I'm working on, but I can reliably crash the test runner with that code, and I can to send it to you privately.",futuraprime,NONE,2013-05-31 15:53:23+00:00,True,2013-05-31 22:13:02+00:00,0.26,,4,3,2013-05-31 22:13:02+00:00,0.26,infews,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
375,toEqual is failing tests that should pass,"Consider the following test:
describe('toEqual', function () {
  it('should coerce strings into a number when appropriate', function () {
    expect('30').toEqual(30);
    expect(30).toEqual('30');
  });
});
If we run:
console.log('30' == 30);
console.log(30 == '30');
They both return true. Since dynamic typing is considered one of the features of the Javascript language, I would expect the toEqual() function to respect this behavior. If the observed behavior is intentional, can someone explain the reasoning?",snapfractalpop,NONE,2013-05-31 18:25:54+00:00,True,2013-05-31 18:34:01+00:00,0.01,,2,3,2013-05-31 18:34:01+00:00,0.01,,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
376,Spy calls - keep the timetoo,"I encountered a problem, I needed to test the specific order in which some callbacks are called (each of them had spies), the simplest way was to modify the jasmine library to store the time in ms when each call was made and compare the values.
spyObj.calls.push({object: this, args: args});

to
spyObj.calls.push({object: this, args: args, time: new Date().getTime()});
Maybe this will help others or can be added to the library (or an alternative).
Thanks and keep up the good job.",bgadrian,NONE,2013-06-02 15:23:14+00:00,True,2013-10-02 21:28:20+00:00,122.25,,2,1,2013-10-02 21:28:20+00:00,122.25,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
380,Wrong message string at ObjectContaining matcher,"Line 1567: jasmine.Matchers.ObjectContaining.prototype.jasmineMatches method.
mismatchValues variable contains wrong message ""actual"" and ""expected"" must be swapped.
Wrong message looks like ''c' was '1' in expected, but was '[object Object]' in actual.' but it should be ''c' was '1' in actual, but was '[object Object]' in expected.'",albertandrejev,CONTRIBUTOR,2013-06-07 09:03:45+00:00,True,2013-07-28 06:39:23+00:00,50.9,,2,1,2013-07-27 17:35:11+00:00,50.36,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
382,JS some native objects equality acting strangely,"Is this intended behavior?
expect(new Date(1,2,3)).toEqual({}); // ok
expect(new Number(3)).toEqual({}); // ok
expect(new Boolean(true)).toEqual({}); // ok
expect(/regexp/).toEqual({}); // ok",katsgeorgeek,NONE,2013-06-07 14:27:06+00:00,True,2013-06-07 16:02:31+00:00,0.07,,2,4,2013-06-07 15:04:20+00:00,0.03,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
385,andReturn() value not clearing after .reset(),"In some of my classes, I use a cookieManger class that wraps basic interactions with document.cookies.  For testing, I have a simple spy created like so:
cookieManager = jasmine.createSpyObj 'cookieManager', ['get','set']

In one of my tests, I set cookieManager.get.andReturn(""foo"")
Then in my afterEach, I call .reset() on both methods (get & set), but in the subsequent tests, the .andReturn() value is still returning ""foo"" instead of null or undefined
The reason I am trying to use .reset() instead of ""newing"" up a new one is because the mock object is injected by RequireJS into both the spec and the unit-under-test, and I need the modify the injected mock so I can control logic flow within my test object.",jbarker4682,NONE,2013-06-11 22:54:12+00:00,True,2013-06-11 23:12:01+00:00,0.01,,2,4,2013-06-11 23:01:16+00:00,0.0,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
386,"new ""words"" to test events","I was thinking about my tests and I suddenly realized that most of the time I was using the words ""when"", ""it"", ""does"".
And I think that it could be great to reflect the when and does words as methods. They could help writing tests for events or settings.
I suppose (really just a supposition) that it might be possible to write the does (inspired from spy, maybe?) and I might even try to code that, but some help would be very welcome. I don't even know if it is a good idea.
Anyway, I really like jasmine. Thanks for that.",zeropaper,NONE,2013-06-12 19:37:22+00:00,True,2013-10-03 22:49:07+00:00,113.13,,3,3,2013-10-03 22:49:07+00:00,113.13,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
387,.andReturn(...) strips properties starting with '$' from the object to be returned,"When I try to return an object that has a property whose name starts with a dollar sign, the property gets removed from my return object:
spyOn(myObj, 'myFunction').andReturn({
    $a: ""this will disappear"",
    b: ""this will stay""
});
var result = myObj.myFunction();
console.log(result);

// --> {""b"": ""this will stay""}

Is there any way to preserve the return object unchanged?",ecowden,NONE,2013-06-14 20:05:44+00:00,True,2013-06-14 20:23:55+00:00,0.01,,2,2,2013-06-14 20:19:31+00:00,0.01,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
389,test,ste,gaecom,NONE,2013-06-20 10:37:35+00:00,True,2013-07-21 14:27:00+00:00,31.16,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
395,Show 'pending' examples,"In my experience it is helpful be able to create pending examples as soon as I think of them, without actually have to think about how exactly I'm going to implement them.
Inspired by RSpec, I think it would be a good idea to mark examples as pending instead of passing when the it function has not been provided a callback. This way, a developer is not fooled by passing specs to think that she is testing behavior that hasn't actually been implemented.",KaptajnKold,NONE,2013-06-26 08:24:53+00:00,True,2013-07-05 18:11:41+00:00,9.41,,3,2,2013-07-05 18:07:57+00:00,9.4,jdmarshall,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
396,Explain the current development process,"I am trying to update a couple of pull requests that don't merge cleanly with Master. I'm having some issues understanding how to update them and guessing the original authors had the same issue.
It appears that some of the generated files have been committed.  The contributor's guide doesn't illuminate this situation so I'm hoping that some light can be shed on this, and some indication of what the short- and medium-term plans are regarding code organization.
So far I've figured out that about half of lib is generated code. But several files, including boot.js, don't exist outside of lib.",jdmarshall,NONE,2013-07-01 06:32:42+00:00,True,2013-07-21 15:27:34+00:00,20.37,,2,1,2013-07-21 15:28:35+00:00,20.37,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
399,Recent changes cause Jasmine to hang when using the 'raise exception' button,"Commit 34b8bf5 removes the following line:
    env = new j$.Env({now: fakeNow}),

Causing the 'env' call on line 214 to fail and the entire test run hang.",jdmarshall,NONE,2013-07-05 04:32:05+00:00,True,2013-07-11 04:00:26+00:00,5.98,,3,5,2013-07-05 06:57:23+00:00,0.1,sheelc,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
402,Spies should save the return value of method calls when using andCallThrough(),"This would be cool:
# Foo! Bar!
foo =
    bar: (string) -> foo.baz(string) + '-bar'
    baz: (string) -> string.toUpperCase()

# Spy!
bazSpy = spyOn(foo, 'baz').andCallThrough()

# Bar something!
barredHello = foo.bar('hello')

# Expect!
expect(baredHello).toBe('HELLO-bar')
expect(bazSpy.returnValueForCall[0]).toBe('HELLO')

…the addition to the framework being the spy.returnValueForCall array.",steveluscher,NONE,2013-07-10 18:50:25+00:00,True,2013-07-21 14:33:24+00:00,10.82,,2,4,2013-07-10 18:50:56+00:00,0.0,steveluscher,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
403,"Update documentation to remove reference to runs, waitsFor / add documentation for using done()","I've spoken to @infews in the mailing list a couple of days ago about the need to update the docs to illustrate how to use done for async tests, as well as remove the docs on runs and waitsFor.
I've just been using Jasmine for a week and in no way I'm an expert, although I'd very happy to submit new docs once I get to grasp the method's usage. Any help / instruction would be greatly appreciated.",josemotanet,NONE,2013-07-17 18:16:19+00:00,True,2013-10-03 22:38:06+00:00,78.18,,5,6,2013-09-15 01:25:26+00:00,59.3,mvolkmann,NONE,2,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
405,RM crash when running jasmine rake task when binding_of_caller is installed,"I have binding_of_caller gem installed on my development bundle, and when running rake, I get a segmentation fault.
Previous versions of jasmine would get this error on rake jasmine:ci but no longer in 1.3.1.
Has anyone seen this?
== Background
OSX 10.8
Ruby 1.9.3 p385 (ruby 1.9.3p385 (2013-02-06 revision 39114) [x86_64-darwin12.2.1])
== Stack Trace
/Users/dlikhten/.rvm/rubies/ruby-1.9.3-p385/bin/ruby -S rspec /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/jasmine-1.3.2/lib/jasmine/run_specs.rb --colour --format progress -r /Users/dlikhten/repos/doorsteps/config/environment
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/better_errors-0.3.2/lib/better_errors/core_ext/exception.rb:9: [BUG] Segmentation fault
ruby 1.9.3p385 (2013-02-06 revision 39114) [x86_64-darwin12.2.1]

-- Control frame information -----------------------------------------------
c:0038 p:---- s:0122 b:0122 l:000121 d:000121 CFUNC  :callers
c:0037 p:0064 s:0119 b:0119 l:0011d0 d:000210 LAMBDA /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/better_errors-0.3.2/lib/better_errors/core_ext/exception.rb:9
c:0036 p:---- s:0116 b:0116 l:000115 d:000115 FINISH
c:0035 p:---- s:0114 b:0114 l:000113 d:000113 CFUNC  :new
c:0034 p:---- s:0112 b:0112 l:000111 d:000111 CFUNC  :require
c:0033 p:0010 s:0108 b:0108 l:0000e8 d:001f08 BLOCK  /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:251
c:0032 p:0071 s:0106 b:0106 l:0002c8 d:0002c8 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:236
c:0031 p:0019 s:0101 b:0101 l:0000e8 d:0000e8 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:251
c:0030 p:0032 s:0096 b:0096 l:000588 d:000588 TOP    /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/ruby-prof-0.12.2/lib/ruby-prof.rb:6
c:0029 p:---- s:0094 b:0094 l:000093 d:000093 FINISH
c:0028 p:---- s:0092 b:0092 l:000091 d:000091 CFUNC  :require
c:0027 p:0026 s:0088 b:0088 l:0006d0 d:0007d0 BLOCK  /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:72
c:0026 p:---- s:0085 b:0085 l:000084 d:000084 FINISH
c:0025 p:---- s:0083 b:0083 l:000082 d:000082 CFUNC  :each
c:0024 p:0091 s:0080 b:0080 l:0006d0 d:000760 BLOCK  /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:70
c:0023 p:---- s:0073 b:0073 l:000072 d:000072 FINISH
c:0022 p:---- s:0071 b:0071 l:000070 d:000070 CFUNC  :each
c:0021 p:0046 s:0068 b:0068 l:0006d0 d:0006d0 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:59
c:0020 p:0021 s:0064 b:0064 l:000ae0 d:000ae0 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler.rb:132
c:0019 p:0137 s:0060 b:0060 l:000c28 d:000c28 TOP    /Users/dlikhten/repos/doorsteps/config/application.rb:13
c:0018 p:---- s:0058 b:0058 l:000057 d:000057 FINISH
c:0017 p:---- s:0056 b:0056 l:000055 d:000055 CFUNC  :require
c:0016 p:0026 s:0052 b:0052 l:000d68 d:000d68 TOP    /Users/dlikhten/repos/doorsteps/config/environment.rb:2
c:0015 p:---- s:0050 b:0050 l:000049 d:000049 FINISH
c:0014 p:---- s:0048 b:0048 l:000047 d:000047 CFUNC  :require
c:0013 p:0012 s:0044 b:0044 l:000eb0 d:000f20 BLOCK  /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration.rb:460
c:0012 p:---- s:0041 b:0041 l:000040 d:000040 FINISH
c:0011 p:---- s:0039 b:0039 l:000038 d:000038 CFUNC  :map
c:0010 p:0012 s:0036 b:0036 l:000eb0 d:000eb0 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration.rb:460
c:0009 p:0071 s:0032 b:0032 l:001158 d:0011c0 BLOCK  /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration_options.rb:27
c:0008 p:---- s:0029 b:0029 l:000028 d:000028 FINISH
c:0007 p:---- s:0027 b:0027 l:000026 d:000026 CFUNC  :each
c:0006 p:0075 s:0024 b:0024 l:001158 d:001158 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration_options.rb:26
c:0005 p:0062 s:0019 b:0019 l:0013f8 d:0013f8 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/command_line.rb:21
c:0004 p:0137 s:0014 b:0014 l:001558 d:001558 METHOD /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/runner.rb:80
c:0003 p:0054 s:0007 b:0007 l:001568 d:000006 BLOCK  /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/runner.rb:17
c:0002 p:---- s:0004 b:0004 l:000003 d:000003 FINISH
c:0001 p:0000 s:0002 b:0002 l:0005a8 d:0005a8 TOP   

-- Ruby level backtrace information ----------------------------------------
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/runner.rb:17:in `block in autorun'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/runner.rb:80:in `run'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/command_line.rb:21:in `run'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration_options.rb:26:in `configure'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration_options.rb:26:in `each'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration_options.rb:27:in `block in configure'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration.rb:460:in `requires='
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration.rb:460:in `map'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration.rb:460:in `block in requires='
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/rspec-core-2.13.1/lib/rspec/core/configuration.rb:460:in `require'
/Users/dlikhten/repos/doorsteps/config/environment.rb:2:in `<top (required)>'
/Users/dlikhten/repos/doorsteps/config/environment.rb:2:in `require'
/Users/dlikhten/repos/doorsteps/config/application.rb:13:in `<top (required)>'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler.rb:132:in `require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:59:in `require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:59:in `each'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:70:in `block in require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:70:in `each'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:72:in `block (2 levels) in require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@global/gems/bundler-1.3.5/lib/bundler/runtime.rb:72:in `require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/ruby-prof-0.12.2/lib/ruby-prof.rb:6:in `<top (required)>'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:251:in `require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:236:in `load_dependency'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:251:in `block in require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:251:in `require'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/activesupport-3.2.13/lib/active_support/dependencies.rb:251:in `new'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/better_errors-0.3.2/lib/better_errors/core_ext/exception.rb:9:in `block in <class:Exception>'
/Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/gems/better_errors-0.3.2/lib/better_errors/core_ext/exception.rb:9:in `callers'

-- C level backtrace information -------------------------------------------

   See Crash Report log file under ~/Library/Logs/CrashReporter or
   /Library/Logs/CrashReporter, for the more detail of.

-- Other runtime information -----------------------------------------------

* Loaded script: /Users/dlikhten/.rvm/gems/ruby-1.9.3-p385@doorsteps/bin/rspec

* Loaded features:

Truncated due to github limitation",dlikhten,NONE,2013-07-22 21:54:29+00:00,True,2013-10-02 19:19:53+00:00,71.89,,2,1,2013-10-02 19:19:53+00:00,71.89,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
406,toContain should work with DOMTokenList,"Many of our specs verify expectations of CSS class names being present or absent on DOM elements. It would be nice to be able to just say expect(element.classList).toContain('myExpectedClassName'), but that doesn't work with the current toContains implementation that checks for Array types.
Our workaround is expect(element.className.split(' ')).toContain(...), which is OK, but somewhat clumsier than it ought to be.",vin,NONE,2013-07-24 22:44:28+00:00,True,2013-10-02 21:08:42+00:00,69.93,,3,3,2013-07-25 05:11:42+00:00,0.27,sheelc,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
409,toThrow fails in FF 23 (modifying native Exception),"expect(func).toThrow() fails in Firefox 23 (func throws as expected) with this error:
NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN: Cannot modify properties of a WrappedNative
The offending line is https://github.com/pivotal/jasmine/blob/master/src/core/PrettyPrinter.js#L33.
Moreover, the call stack reveals that https://github.com/pivotal/jasmine/blob/master/src/core/matchers/toThrow.js#L28 is being executed - the message itself is puzzling, as the matcher actually expects the function to throw.",ondras,NONE,2013-07-30 09:52:43+00:00,True,2013-08-03 19:01:40+00:00,4.38,,3,6,2013-07-31 05:05:15+00:00,0.8,sheelc,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
411,Dynamically created tests based on Async result ..,"http://jsfiddle.net/3wfkr/2/
I'm trying to get an async setup to generate some nested specs , the specs run and work, but an error is also generated  ...
TypeError: 'undefined' is not an object (evaluating 'this.views.suites')
(the reason I'm actually trying to do it is ..
I want to call an API retrieve a list of resources and then generate tests for each one at runtime ..)",vurt007,NONE,2013-08-05 14:06:53+00:00,True,2013-08-05 16:13:55+00:00,0.09,,2,4,2013-08-05 14:11:31+00:00,0.0,vurt007,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
412,Dynamically created tests based on Async result ..,"http://jsfiddle.net/3wfkr/3/
using jasmine 2.0.0 rc2
I'm trying to get an async setup to generate some nested specs , the specs run and work, but an error is also generated ...
Time's out .. no response ..
Console output shows the first nested test is actually executing ...
testSuiteStarted name='test-gen-test.js'
testStarted name='Jasmine spec gen Tests A complex call to a dynamic API:It got some Guidance'
testStdOut name='Jasmine spec gen Tests A complex call to a dynamic API:It got some Guidance' out='Passed'
testFinished name='Jasmine spec gen Tests A complex call to a dynamic API:It got some Guidance' duration='74'
testStarted name='Jasmine spec gen Tests A complex call to a dynamic API:with nested async tests'
testStdOut name='Jasmine spec gen Tests A complex call to a dynamic API:with nested async tests' out='Passed'
testFinished name='Jasmine spec gen Tests A complex call to a dynamic API:with nested async tests' duration='661'
testStarted name='Jasmine spec gen Tests something async:completes the first stage'
testStdOut name='Jasmine spec gen Tests something async:completes the first stage' out='Passed'
testFinished name='Jasmine spec gen Tests something async:completes the first stage' duration='0'
testStarted name='dynamically adding nested contexts based on an async result:this one should pass'
testStdOut name='dynamically adding nested contexts based on an async result:this one should pass' out='Passed'
testFinished name='dynamically adding nested contexts based on an async result:this one should pass' duration='0'
AppData\Local\NCrunch\7200\10\src\AIMS.Specs\specs\test-gen-test.js
Chutzpah.Exceptions.ChutzpahTimeoutException: Timeout occured when running AppData\Local\NCrunch\7200\10\src\AIMS.Specs\specs\test-gen-test.js
at Chutzpah.TestRunner.HandleTestProcessExitCode(Int32 exitCode, String inputTestFile)
at Chutzpah.TestRunner.InvokeTestRunner(String headlessBrowserPath, TestOptions options, TestContext testContext, TestRunnerMode testRunnerMode, ITestMethodRunnerCallback callback)
at Chutzpah.TestRunner.<>c__DisplayClass2.b__1(PathInfo testFile)
testSuiteFinished name='test-gen-test.js'
Child test failed",vurt007,NONE,2013-08-06 10:41:52+00:00,True,2013-08-06 19:07:48+00:00,0.35,,2,1,2013-08-06 19:07:48+00:00,0.35,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
414,Bail on first failure,"Put together an extension to add bail after first failure behavior after someone else had the same request, and I didn't hear of existing work from the community.
I'd love to see this behavior (jasmine.Env.prototype.bailFast()) added to jasmine core before I suggest a flag for jasmine-node.
I'm happy to put together a PR if folks think this would be useful and agree it belongs in jasmine core.",hurrymaplelad,NONE,2013-08-15 23:24:14+00:00,True,2018-02-07 18:04:32+00:00,1636.78,,54,68,2013-08-20 02:10:56+00:00,4.12,hurrymaplelad,NONE,1,2,0,51,"['feature request', 'has Tracker story', 'ready for work']",False,True,False,False,False,False,False,False,True,True,False,False,False,False,False
415,Improve readability of printed javascript objects by formatting output,"Currently, reading an error message that includes a javascript object is fairly difficult.
For example, reading an error from expect(myFunction).toHaveBeenCalledWith(largeObject) is hard to do as the object printed are all on one or two lines, instead of many.
The current output of javascript objects makes them hard to read, hard to compare, and thus, leads to more time spent figuring out what went wrong in a test rather than fixing it.
So, as a developer, I expect the printed output of javascript objects to look pretty and to be easy to read.",lalunamel,CONTRIBUTOR,2013-08-16 18:33:07+00:00,True,2014-06-23 04:17:05+00:00,310.41,,3,3,2014-06-23 04:16:59+00:00,310.41,infews,CONTRIBUTOR,0,1,0,1,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
416,expect({}).toBe({}) Fails.,For some reason empty objects/arrays aren't expected to be empty objects or arrays.,winrid,NONE,2013-08-20 23:22:11+00:00,True,2013-08-21 02:26:47+00:00,0.13,,5,8,2013-08-21 02:26:47+00:00,0.13,ragaskar,CONTRIBUTOR,0,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
417,Jasmine 2.0.0 RC2 (head) on IE8,"Morning!
We're testing running our jasmine tests on the latest Jasmine against IE8, and it seems to be broken.
Attaching a screenshot.
Object doesn't support this property or method  jasmine-html.js, line 229 character 7
>> getContainer().querySelector
undefined


Ian Zabel & Swaroop Murthy",iwz,NONE,2013-08-21 14:39:36+00:00,True,2013-08-22 18:35:21+00:00,1.16,,2,1,2013-08-21 15:00:55+00:00,0.01,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
418,RangeError: Maximum call stack size exceeded,"I am trying to use Karma to setup my Jasmine tests, and I get the following error when running ""karma run""
RangeError: Maximum call stack size exceeded. at C:/Users/myName/angular/node_modules/karma-jasmine/lib/jasmine.js:1811
Chrome 29.0.1547 (Windows 7): Executed 0 of 1 ERROR (0.244 secs / 0 secs)
PhantomJS 1.9.1 (Windows 7): Executed 0 of 1 ERROR (0.237 secs / 0 secs)
grunt Package.json:
Here is my Package.json:
{
""name"": ""App"",
""description"": ""App engine"",
""version"": ""0.1.0"",
""readme"": ""Read Me..."",
""readmeFilename"": ""README.md"",
""repository"": {
""type"": ""svn"",
""url"": ""http://v8.googlecode.com/svn/trunk/""
},
""devDependencies"": {
""grunt"": ""~0.4.1"",
""grunt-contrib-copy"": ""~0.4.1"",
""grunt-contrib-concat"": ""~0.3.0"",
""grunt-contrib-coffee"": ""~0.7.0"",
""grunt-contrib-uglify"": ""~0.2.0"",
""grunt-contrib-compass"": ""~0.3.0"",
""grunt-contrib-jshint"": ""~0.6.0"",
""grunt-contrib-cssmin"": ""~0.6.0"",
""grunt-contrib-connect"": ""~0.3.0"",
""grunt-contrib-clean"": ""~0.4.1"",
""grunt-contrib-htmlmin"": ""~0.1.3"",
""grunt-contrib-imagemin"": ""~0.1.4"",
""grunt-contrib-watch"": ""~0.5.1"",
""grunt-usemin"": ""~0.1.11"",
""grunt-rev"": ""~0.1.0"",
""grunt-karma"": ""~0.6.2"",
""grunt-open"": ""~0.2.0"",
""grunt-concurrent"": ""~0.3.0"",
""matchdep"": ""~0.1.2"",
""connect-livereload"": ""~0.2.0"",
""grunt-google-cdn"": ""~0.2.0"",
""grunt-ngmin"": ""~0.0.2"",
""karma-phantomjs-launcher"": ""~0.1.0"",
""karma-jasmine"": ""~0.1.3"",
""karma"": ""~0.10.2""
}
}
System Info:
NodeJS: v0.10.17
Karma: v0.10.2
Phantomjs: version: 1.9.1-8
I have already loaded:
Angular 1.0.7
jQuery 2.0.3
bootstrap 3
jasmine
Any idea what's missing or what I am doing wrong?",aminjam,NONE,2013-08-27 19:11:57+00:00,True,2013-08-27 20:07:42+00:00,0.04,,5,5,2013-08-27 20:07:42+00:00,0.04,ragaskar,CONTRIBUTOR,0,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
419,"Async test specs can have an undefined ""this"" context in Jasmine 2.0","My production and test JavaScript code runs in a ""use strict"" environment. When Jasmine calls our async test functions, it invokes them directly without using Function.call, so the async function context is undefined.
This makes it impossible to attach state to this. in beforeEach and use it in it.
The problem is in Spec.js's timeoutable function, which calls the it function callback directly:
        fn(callDone); //TODO: do we care about more than 1 arg?

Instead, this should be:
        fn.call(this, callDone); //TODO: do we care about more than 1 arg?

I'll submit a pull request with a fix and a new test.",Eric-Wright,NONE,2013-08-28 05:25:02+00:00,True,2013-08-29 05:13:13+00:00,0.99,,2,1,2013-08-29 05:13:12+00:00,0.99,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
421,innerHTML error on The Runner and Reporter section,"Using angular-seed-app I couldn't run tests on the this tutorial, not even the first one,
the Runner and Reporter section of the doc there is:
document.querySelector('.version').innerHTML = jasmineEnv.versionString();
browser console throws an error
Uncaught TypeError: Cannot set property 'innerHTML' of null
after looking around I found other examples dont have that line. I used the example in tuts+ http://net.tutsplus.com/tutorials/javascript-ajax/testing-your-javascript-with-jasmine/
On that tutorial there is SpecRunner.html it has that block of code without document.querySelector('.version').innerHTML = jasmineEnv.versionString();
and everything works as expected.",dlodeprojuicer,NONE,2013-08-28 14:31:15+00:00,True,2014-01-18 06:03:33+00:00,142.65,,3,2,2013-08-29 05:24:17+00:00,0.62,infews,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
422,Async tests shouldn't have a hardcoded 10-second timeout in Jasmine 2.0,"In Jasmine 1.x, the timeout for waits() and waitsFor() was configurable, either by passing a timeout arg to each invocation, or by changing jasmine.DEFAULT_TIMEOUT_INTERVAL globally.
In Jasmine 2.0, there is still a DEFAULT_TIMEOUT_INTERVAL, but it only affects  synchronous tests. Async tests have a hard-coded 10-second timeout in Spec.js:
var timeout = Function.prototype.apply.apply(self.timer.setTimeout, [j$.getGlobal(), [function() {
  onException(new Error('timeout'));
  done();
}, 10000]]);

Async tests should respect the DEFAULT_TIMEOUT_INTERVAL like they did in Jasmine 1.x.",Eric-Wright,NONE,2013-08-28 16:45:49+00:00,True,2013-08-28 17:36:14+00:00,0.04,,2,1,2013-08-28 17:36:14+00:00,0.04,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
423,"Async test ""done"" callbacks should take an optional error in Jasmine 2.0","I really like that Jasmine 2.0 has adopted a Mocha-like done() callback for completing async tests - they're much easier to write now. Mocha's done() callback also accepts an optional error parameter; if omitted, the test succeeds, otherwise the test fails by throwing the error. I propose that Jasmine adds the same support to make it easier to write async tests.
An example of how to use this feature:
it(""should save without error"", function(done) {
  var user = new User('Eric');
  user.save()
    .done(function() { done(); }
    .fail(function() { done(""save error""); });
});

Without this support, async test failures are a little more cumbersome to write. In this example, I have to force a test failure in my callback function before calling done():
it(""should save without error"", function(done) {
  var user = new User('Eric');
  user.save()
    .done(function() { done(); }
    .fail(function() {
      expect(""save error"").toBe(undefined); // something to cause the test to fail
      done();
     });
});

I modified Spec.js to support this in my local copy of Jasmine. I can submit a pull request you're interested.",Eric-Wright,NONE,2013-08-28 18:15:43+00:00,True,2013-08-29 05:22:44+00:00,0.46,,2,5,2013-08-28 18:31:22+00:00,0.01,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
424,Comparing complex Object to toEqual(jasmine.any(Array)) cause Browser to hang,"I have a really complex javascript object - containing two Backbone views, to be specific - and when I compare that object using toEqual(jasmine.any(Array)) it causes the browser to hang hard.
Tested on Firefox 22 and Chrome 27.",thomb,NONE,2013-08-30 20:30:17+00:00,True,2016-09-29 00:35:56+00:00,1125.17,,7,8,2013-09-01 18:41:10+00:00,1.92,infews,CONTRIBUTOR,1,1,0,3,['1.3.x'],False,False,False,False,False,False,False,False,False,False,False,False,True,False,False
425,Add 'jasmine.objectContaining' to the documentation,"This method is undocumented and it's pretty useful.
I would have written the documentation and submitted a pull request, but I didn't see the documentation as a part of the repo.",gustly,NONE,2013-09-05 14:20:48+00:00,True,2013-10-03 22:35:31+00:00,28.34,,3,2,2013-09-05 15:17:40+00:00,0.04,infews,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
427,Remove the trailing dot at the end of the failing spec,"When a test is failing, the reporter adds a trailing dot to the test title. This dot is not added to the passing tests report so the programmer tends to add it manually at the end of the test title. So, when failing, two dots are displayed.",delapuente,NONE,2013-09-08 19:31:47+00:00,True,2013-10-01 23:31:15+00:00,23.17,,2,1,2013-10-01 22:56:56+00:00,23.14,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
429,jasmine-core gem doesn't install with RubyGems 2.1.x,"I'm not sure if this is a RubyGems or Jasmine issue, but RubyGems 2.1.0 and higher will not install or unpack jasmine-core.  The install ""succeeds"", but the jasmine-core-1.3.1 directory is empty.  This is happening to me on OSX and Ubuntu 12.10.  Ruby is installed using rvm.
Simple repro steps:
cd /tmp
wget http://rubygems.org/downloads/jasmine-core-1.3.1.gem
gem update --system
gem unpack jasmine-core-1.3.1.gem
ls jasmine-core-1.3.1
# Directory will be empty.  It should contain a lib directory.",blt04,NONE,2013-09-12 18:39:45+00:00,True,2013-09-15 17:48:34+00:00,2.96,,3,2,2013-09-12 22:24:38+00:00,0.16,drbrain,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
430,How to use ConsoleReporter with 1.3.1 Jasmine version from a zip download?,"Firstly. Jasmine is great :) Tests make more sense for everyone when written in specification way. However I run into a small issue. It's not stopping me from work, yet it's pretty irritating :)
I downloaded my version of Jasmine from here: https://github.com/pivotal/jasmine/downloads
There is no ConsoleReporter bundled with this one. So I decided to download it directly from github. Normally I wouldn't work this way, but I'm still pretty new t Jasmine and wanted to play around a little bit.
Unfortunately I can't get it work with my version of Jasmine. After inspecting the code I tried this one in my Runner:
var reporter = new getJasmineRequireObj().ConsoleReporter({ print : console.log });.
There are no error and no output in the console :(
If it doesn't make sense I will just clone repository and I will use master branch.
Thanks!",op1ekun,NONE,2013-09-13 07:42:13+00:00,True,2013-09-13 21:14:00+00:00,0.56,,5,6,2013-09-13 21:14:00+00:00,0.56,infews,CONTRIBUTOR,0,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
431,What about version 2.0?,"Hey dear Pivotal Team.
I really love jasmine, and asking myself, what's up with the 2.0 branch? The last commit is 7 Months old. Will it ever be see the light of day, or what is the plan there?
Keep up the good work,
Georg",Calamari,NONE,2013-09-13 18:02:30+00:00,True,2013-09-13 18:16:04+00:00,0.01,,2,2,2013-09-13 18:16:03+00:00,0.01,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
433,Test runner crashes when testing toHaveBeenCalledWith with complex parameters,"I am writing unit tests for a Sencha Touch app and I am increasingly coming across an issue that I can't resolve.  It would seem that when I am testing that a particular method was called with a particular parameter it works fine if the parameter is simple, but if it is quite complex then the test runner just completely crashes out and I have to restart the browser.
Example code (you will need a Sencha App running for this particular example but I am guessing this will reproducible with any semi-complex object).
controller.someView = Ext.create('Ext.container');
spyOn(Ext.Viewport, 'add');

controller.someMethodThatAddsSomeViewToViewport();

expect(Ext.Viewport.add).toHaveBeenCalledWith(controller.someView);

controller = {
    someMethodThatAddsSomeViewToViewport: function() {
        Ext.Viewport.add(this.someView);
    }
}


Now if I write this test before writing the code it completely crashes my browser.  If I go back and write the correct code to satisfy this test and re-run the spec runner is absolutely fine and registers the test as passed.
This is quite frustrating as I am trying to do test driven development.  I hope this is enough to go on - let me know if you need any more information.  I am not able to provide stack traces or other debugging information as it renders my browser unusable.  I am running the tests in Google Chrome on a Mac.
Tom",tomcooksey,NONE,2013-09-26 20:25:08+00:00,True,2013-09-26 22:51:46+00:00,0.1,,2,1,2013-09-26 22:51:46+00:00,0.1,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
435,jasmine forcing to use .live instead of .on,"Hi,
I am running a test for dialog(fancybox) close. I am using a function
$(""#deleteAllDialog"").on(""click"", ""#cancelDeleteAll"", function () {
    dialog.close();
});

and got a error
Testing View History Structure:: clicks the delete all button: failed
  Expected '<div id=""deleteAllDialog"" class=""dialog"" style=""display: block; ""><p class=""dialog-heading""> Are you sure you want to delete all items in your viewing history?</p><a class=""button-standard"" id=""confirmDeleteAll"" href=""#"">CONFIRM</a><a class=""button-standard"" id=""cancelDeleteAll"" href=""#"">CANCEL</a></div>' to be hidden. (6)

and when i use .live than i didn't get any error.
  $(""#cancelDeleteAll"").live('click', function () {
      dialog.close();
  });

Here is my Jasmine code
describe(""Testing View History Structure"", function () {
    var server;

beforeEach(function() {
    jasmine.getFixtures().set(
     '<div id=""deleteAllDialog"" class=""dialog"">' +
                '<p class=""dialog-heading""> Are you sure you want to delete all items in your viewing history?</p>' +
                '<a class=""button-standard"" id=""confirmDeleteAll"" href=""#"">CONFIRM</a>' +
                '<a class=""button-standard"" id=""cancelDeleteAll""  href=""#"">CANCEL</a>' +
            '</div>' 
);
    server = sinon.fakeServer.create();
    spyOnEvent($(""#cancelDeleteAll""), 'click');
});

it(""clicks the delete all button"", function () {
    expect($('#deleteAllDialog')).toBeHidden();
    $(""#deleteAll"").trigger('click');
    expect('click').toHaveBeenTriggeredOn($(""#deleteAll""));
    expect($('#deleteAllDialog')).toBeVisible();
    expect($(""#cancelDeleteAll"")).toHaveClass(""button-standard"");
    $(""#cancelDeleteAll"").trigger('click');
    $(""#cancelDeleteAll"").click();
    expect('click').toHaveBeenTriggeredOn($(""#cancelDeleteAll""));
    expect($('#deleteAllDialog')).toBeHidden();
});",kuldeeparora,NONE,2013-09-27 09:48:24+00:00,True,2013-10-02 19:27:43+00:00,5.4,,3,3,2013-09-27 15:34:10+00:00,0.24,sheelc,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
436,Jasmine causes exception in Firefox and Chrome,"We are using the 2.0.0 version of jasmine. Problem is still present in RC2.
NS_ERROR_XPC_BAD_OP_ON_WN_PROTO: Illegal operation on WrappedNative prototype object
This is caused by trying to alias the global timing functions:
    realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
    },
With ECMAScript 5, adding .bind(global) causes the errors to go away - ie,
    realTimingFunctions = {
        setTimeout: global.setTimeout.bind(global),
        clearTimeout: global.clearTimeout.bind(global),
        setInterval: global.setInterval.bind(global),
        clearInterval: global.clearInterval.bind(global)
    },",mrusinak,NONE,2013-09-30 18:39:36+00:00,True,2013-09-30 22:09:15+00:00,0.15,,5,9,2013-09-30 22:00:24+00:00,0.14,infews,CONTRIBUTOR,1,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
441,Expose object equality comparator,"When adding a custom matcher I often need to test objects for equality. It would be very helpful if the jasmine equality comparison function was publicly exposed on the expectation object (as this.equals or this.compare for example).
As an example, I might want to create 'toPromise' matcher testing whether a function returns specific data wrapped in a promise. I can do this:
beforeEach(function () {
    this.addMatchers({
        toPromise: function (expected) {
            this.message = [...];
            // call function, unwrap data and assign to this.actual
            return this.toEqual(expected);
        }
    });
});

but that outputs unwanted message from 'toEqual' matcher along with my own message. I'd like to be able to do this:
beforeEach(function () {
    this.addMatchers({
        toPromise: function (expected) {
            this.message = [...];
            // call function, unwrap data
            return this.compare(unwrappedData, expected);
        }
    });
});",hon2a,NONE,2013-10-07 08:49:35+00:00,True,2013-12-07 23:53:53+00:00,61.63,,4,5,2013-10-07 14:51:32+00:00,0.25,slackersoft,MEMBER,1,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
442,1.3.1 standalone no longer available,"http://cloud.github.com/downloads/pivotal/jasmine
jasmine-standalone-1.3.1",marcosjitisoft,NONE,2013-10-07 13:19:11+00:00,True,2013-10-07 14:25:21+00:00,0.05,,5,5,2013-10-07 14:23:49+00:00,0.04,slackersoft,MEMBER,1,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
444,Spies save call arguments by reference ,"When a spy is called with arguments, the spy's mostRecentCall.args and argsForCall properties are set as a direct reference to the arguments. This means that if the argument objects themselves are changed, our reference to them will change as well.
Consider this example (http://jsfiddle.net/a5kp9/2/):
var spy = jasmine.createSpy();
var arg = ['a', 'b'];

spy(arg);

arg.length = 0;

expect(spy.mosRecentCall.args[0][0]).toEqual('a');
expect(spy.mosRecentCall.args[0][1]).toEqual('b');
// Fails. Actual value of spy.mostRecentCall.args[0] is now '[]'
I would expect that the answer to ""What arguments was this spy called with?"" shouldn't change after the spy is called.
I'm thinking it would make more sense to save a copy of the arguments, rather than a reference. Thoughts?",eschwartz,NONE,2013-10-09 15:19:07+00:00,True,2016-09-27 19:28:33+00:00,1084.17,,9,12,2013-10-09 16:03:21+00:00,0.03,ragaskar,CONTRIBUTOR,1,1,0,7,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
445,toBeDefined always passes?,"var bob;
describe('toBeDefined test', function() {
        it('should fail', function() {
                expect(bob).toBeDefined;
        });
        it('should not fail', function() {
                expect(bob).toBeUndefined;
        });
});

Both tests pass.  I've seen this both in the browser, with Jasmine 1.3.1 revision 1354556913, and with jasmine-node.  I can't help but suspect that I'm missing something really obvious since I'm new to Jasmine, but....",jbhelfrich,NONE,2013-10-09 17:12:51+00:00,True,2013-10-09 17:29:01+00:00,0.01,,2,3,2013-10-09 17:26:57+00:00,0.01,ohaibbq,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
446,andReturnPromise() ?,"My setup of tests becomes very bulky because of setup of promises and returning using AndReturn.
andReturnPromise(resolve, reject) or something like that would be a nice addition that would slice my setup code.
Thanks",Dashue,NONE,2013-10-11 17:32:06+00:00,True,2013-11-10 06:22:17+00:00,29.53,,2,1,2013-11-10 06:22:17+00:00,29.53,sheelc,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
447,Feature Request: Add (official) mechanism for intercepting matcher results,"This is actually a request to preserve a (likely inadvertant) feature of 1.3.1.
I've been using jasmine 1.3.1 for a few months now, and was exciting to see you are preparing to release jasmine 2.0. I wrote the following jasmine extension (for 1.3.1) to test the messages output by custom matchers, and wish to be able to adapt it for compatibility after jasmine 2's been released:
(function (jasmine) {
    beforeEach(function() {
        expect.messageWhenExpecting = (function messageWhenExpecting(actual) {
            expect(arguments.length).toEqual(1);
            var expectation = expect(actual);
            var wrapUserFacingMatcher = (function (isNot, matcherName) {
                var wrappedMatcher = (function () {
                    var matcherArgs = [].slice.call(arguments, 0);
                    if (!isNot) {
                        expectation = expectation.not;
                    }
                    expectation[matcherName].apply(expectation, matcherArgs);
                    expectation = expect(actual);
                    if (isNot) {
                        expectation = expectation.not;
                    }
                    var result;
                    var realAddMatcherResults = expectation.spec.addMatcherResult;
                    expectation.spec.addMatcherResult = (function intercept(r) {
                        result = r;
                    });
                    expectation[matcherName].apply(expectation, matcherArgs);
                    expectation.spec.addMatcherResult = realAddMatcherResults;
                    return (expect(result.toString()));
                });
                return wrappedMatcher;
            });
            var retVal = {not:{}};
            var name;
            for (name in expectation) {
                if ((name != 'not') && ({}.toString.apply(expectation[name]) === '[object Function]')) {
                    retVal[name] = wrapUserFacingMatcher(false, name);
                    retVal.not[name] = wrapUserFacingMatcher(true, name);
                }
            }
            return retVal;
        });
    });

    describe(""jasmine extension"", function() {
        it(""add expect.messageWhenExpecting() method"", function() {
            expect.messageWhenExpecting(0).toEqual(1).toEqual('Expected 0 to equal 1.');
            expect.messageWhenExpecting(0).not.toEqual(0).toEqual('Expected 0 not to equal 0.');
        });
    });
})(jasmine);
You can see that this code relies on being able to intercept the result from matchers by replacing and restoring the expectation.spec.addMatcherResult() function. While this allows me to intercept the event it is in no way obvious or elegant and I am not advocating that support for this hack be maintained. I am asking that a supportable method to request that the next n calls to expect() have their matcherResults diverted to a user provided callback, or something similar to that.
I have not looked at all at the 2.0.0.rc3 source yet, and this may very well have been addressed already, but I wanted to bring this to your attention before you stamp the official ""2.0.0"" stamp on the next release.
Thank you,
-Loren",loren-osborn,NONE,2013-10-15 17:55:25+00:00,True,2014-08-26 20:16:25+00:00,315.1,,3,4,2014-07-01 20:17:02+00:00,259.1,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
448,Save context of spy calls,"It would be helpful for the spies to save and expose context of their calls. I'd like to do the following:
var shortcut = _.bind(instance.method, instance);
spyOn(instance, 'method');
shortcut();
expect(instance.method.mostRecentCall.context).toBe(instance);

to ensure that the shortcut calls the method in the appropriate context. There could also be a shortcut:
expect(instance.method).toHaveBeenCalledOn(instance);",hon2a,NONE,2013-10-16 10:51:09+00:00,True,2013-10-16 14:36:52+00:00,0.16,,3,4,2013-10-16 14:36:52+00:00,0.16,ragaskar,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
449,"Broken link on the wiki page for ""A simple project""","Wiki page: https://github.com/pivotal/jasmine/wiki/A-simple-project
Broken link: https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/example/SpecRunner.html",nickmccurdy,NONE,2013-10-17 04:47:25+00:00,True,2013-10-17 05:07:14+00:00,0.01,,2,1,2013-10-17 05:07:14+00:00,0.01,sheelc,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
451,Change the order of nested tests displayed by the trivial reporter,"This is a small usability improvement, whose impact is greater for big test suites that experiment multiple failures.
What i experience now is the following: on the trivial reporter, failures related to the more nested specs appear on top.
So for example in a suite like:
describe(
  A
  describe(
      B
      describe(
      C
      D
      E
      F
      )
   )
 )
If all of them will fail, the failures will be sorted like so:
C
D
E
F
B
A
Now, imagine the most nested define has many specs. The user may be led to fix those before, while probably an error on the topmost setup method is causing the whole suite to fail. Thus it would be much better to start from A. In order to avoid this cascade effect, i have to scroll and manually pick the topmost failing test in a nested define, it would be great if the order was simply the reverse of what is now.",danse,NONE,2013-10-18 08:54:03+00:00,True,2014-04-17 23:49:58+00:00,181.62,,2,1,2014-04-17 23:49:58+00:00,181.62,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
452,Repoters don't mention ignored tests,"If I have a test suite with 100 tests and add one prefixed by x i.e. xit(...) the reporters still say ""executed 100 of 100 tests"". Shouldn't it be ""executed 100 of 101 tests""?
I think this would better communicate that there are in fact ignored tests in the suite.",TheLudd,NONE,2013-10-22 07:37:37+00:00,True,2013-10-22 16:45:20+00:00,0.38,,2,1,2013-10-22 16:45:20+00:00,0.38,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
453,1.3.1 is missing from standalone downloads,,tuupola,NONE,2013-10-22 15:16:48+00:00,True,2013-10-22 16:33:44+00:00,0.05,,2,1,2013-10-22 16:33:44+00:00,0.05,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
454,1.3.1 is missing from standalone downloads,1.3.1 is missing from standalone downloads. This page is also linked from docs.,tuupola,NONE,2013-10-22 15:19:14+00:00,True,2013-10-22 16:17:59+00:00,0.04,,2,1,2013-10-22 16:17:59+00:00,0.04,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
456,Support matchers in waitsFor(),"I'm new to Jasmine so apologize if this has been discussed already, but I couldn't find an issue discussing it.
I'd like to be able to use matchers/expectations directly in a waitsFor function.
Instead of (or in addition to)
waitsFor(function() {
  return someCondition === 1;
}, ""waiting for someCondition === 1"")

runs(function() {
  expect(someCondition).toBe(1);
});

I'd like to be able to take advantage of my matchers and reduce duplication:
waitsFor(function() {
  expect(someCondition).toBe(1);
});

Now instead of having to manually type my waitsFor message, the message would be the result of the failed expectation: 'Waited x seconds for 0 to be 1, but was 10'.
One really simple fix would be to allow matchers to return through:
waitsFor(function() {
  return expect(someCondition).toBe(1);
});

You wouldn't get the nice waitsFor message.  But despite toBe matcher returns true/false, for some reason expect().toBe() returns undefined.",matthughes,NONE,2013-10-28 20:08:10+00:00,True,2013-10-28 21:46:34+00:00,0.07,,2,1,2013-10-28 21:46:34+00:00,0.07,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
457,Documentation of available matchers is missing,"The wiki says ""Jasmine has several built-in matchers. Here are a few:""
Wouldn't it be good to have a complete list?
I would volunteer to write it if this seriously does not exist.",thulka,NONE,2013-10-30 07:42:22+00:00,True,2013-10-30 14:03:31+00:00,0.26,,2,1,2013-10-30 14:03:30+00:00,0.26,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
461,a click on a pending spec should run it ,"I was surprised that clicking on a xit() spec from the html runner didn't run the pending test.
The current UI is confusing - it's hard to tell what happened when you click on a pending test from the html runner.  It could be made more clear that no were run...  But I think it would be less confusing and a handy feature to just run a pending test if it is selected explicitly.
The use I had in mind was creating some specs that were of the form 'create interactive debug environment'.  i.e. debugging versions of tests with extended timeouts, noisy logging, etc.   These tests would be normally disabled, but could be clicked or bookmarked to run as needed.
What do y'all think?",mighdoll,NONE,2013-11-05 00:33:53+00:00,True,2014-08-15 20:22:50+00:00,283.83,,4,3,2014-02-24 19:53:47+00:00,111.81,sheelc,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
463,Feature request:  color blind friendly CSS ,"The color choices of red/green for pass/fail are not visible to red/green color blind users, such as myself.  Up to 8% of men of northern European ancestry are red/green color blind according to Wikipedia.
Below are the CSS rules I use to override the default.  ""Green"" traffic lights use a blue-green frequency to distinguish them from red traffic lights, and the same is true below.  In addition, the red is slightly brighter than the green, making the difference visible even to users with no color vision.  I tested this with Color Oracle ( http://colororacle.org/ ) where it appears (to me) that people with protanopea might still find the colors ambiguous, so I added ""font-weight: bold"" to ""failed.""  This was tested on an IPS LED monitor with reasonable (to me) color calibration.
#HTMLReporter .summary .specSummary.passed a {
   color: #007069;
}

#HTMLReporter .summary .specSummary.failed a {
    color: #ca3a11;
    font-weight: bold;
}",dleppik,NONE,2013-11-11 18:21:48+00:00,True,2013-11-12 23:57:39+00:00,1.23,,4,4,2013-11-12 05:30:44+00:00,0.46,tjarratt,CONTRIBUTOR,0,3,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
464,expect() should accept an optional failureMessage like junit ,"Hey guys,
I see that many people have talked about having a way in jasmine to accept failure message on expect() api but to my knowledge jasmine doesn't have that feature yet.
I came up with a backward-compatible solution. See this commit: aatishm@73dce81
(It works in my projects and soon I would like to contribute to Jasmine)
What do you guys think about it?
Thanks!",aatishm,NONE,2013-11-11 19:29:59+00:00,True,2013-12-19 17:36:41+00:00,37.92,,4,3,2013-11-20 11:11:44+00:00,8.65,just-boris,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
467,Support npm,"Please make 1.3 installable via npm.
Currently the only way of installing jasmine is either by source inclusion or by installing one of the many jasmine-* packages that include the source of jasmine.",cburgmer,NONE,2013-11-14 08:45:46+00:00,True,2013-11-15 05:10:12+00:00,0.85,,2,1,2013-11-15 05:10:12+00:00,0.85,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
471,Is Jasmine not compatible with this HTML5 call?,"I have this inside my file.js..
window.addEventListener(""message"", this.receiveMessage.bind(this), false);
Which Jasmine returns as..
Failure/Error: TypeError: 'undefined' is not a function (evaluating 'this.receiveMessage.bind(this)') in http://127.0.0.1:53048/assets/models/file.js?body=1 (line 12)

So within Jasmine I did a log of this broken down, and the following work properly..
window
window.addEventListener
window.addEventListener(""message"", this.receiveMessage(), false);
But what breaks is when I .bind(this) to receiveMessage which is required so that I can still reference this from within the method..",gotoAndBliss,NONE,2013-12-04 14:34:50+00:00,True,2013-12-04 15:00:09+00:00,0.02,,2,1,2013-12-04 14:48:59+00:00,0.01,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
472,Unknown behavior while testing async events with Jasmine 2.0 rc5,"I am trying to write test cases for video tag events with jasmine, earlier i have tried the same with 1.3.1 which works fine but handling of async events was cumber-some,
So tried jasmine 2.0 rc5 with done() callbacks for async (which was simpler). When i execute my test case with Chrome Version 31.0.1650.57 m, some times the test case gives a weird behavior. It keeps executing recursively. Following is the spec:
describe(""Test Video"", function() {
beforeEach(function(done) {
setTimeout(function() {
done();
}, 1);
});
it(""check the loadstart event"", function(done) {
var vid = document.getElementById(""vidEle"");
vid.addEventListener('loadstart', function() {
done();
});
vid.src = ""video/Malang.mp4"";
});
it(""check the progress event"", function(done) {
var vid = document.getElementById(""vidEle"");
vid.addEventListener('progress', function() {
done();
});
vid.src = ""video/Malang.mp4"";
});
it(""check the canplay event"", function(done) {
var vid = document.getElementById(""vidEle"");
vid.addEventListener('loadstart', function() {
done();
});
vid.src = ""video/Malang.mp4"";
});
it(""check the loadstart event"", function(done) {
var vid = document.getElementById(""vidEle"");
vid.addEventListener('loadstart', function() {
done();
});
vid.src = ""video/Malang.mp4"";
});
});
Is there any thing i am doing wrong with the jasmine 2.0 (note that it is working jasmine 1.3.1 version)?
i have attached a screen capture of the problem below:",krsacme,NONE,2013-12-04 18:31:38+00:00,True,2013-12-09 17:13:36+00:00,4.95,,2,3,2013-12-05 14:59:49+00:00,0.85,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
475,Throwing `undefined` causes jasmine to crash,"I ran into a situation today where a failed spec caused the jasmine library to throw an uncaught error.
I'm testing out an object which uses a Validator helper class. The Validator is supposed to provide an Error object if the target object does not pass validation.
I had a spec with something like this:
// ...
Model.prototype.set = function(attr, val) {
  if (!this.validator_.isValid(attr, val)) {
    throw this.validator_.getLastError();
  }
  // ...
}
// ...

it('should fail validation', function() {
  var object = new Model();
  expect(function() {
    object.set('aNumber', 'aString');
  }).toThrow();
});
The problem I ran into was that my objects Validator failed to provide a error object, thus my object attempted to throw undefined. However, the spec did not fail -- instead I got a Uncaught Error from jasmine:
jasmine.Spec.prototype.fail = function (e) {
  var expectationResult = new jasmine.ExpectationResult({
    passed: false,
    message: e ? jasmine.util.formatException(e) : 'Exception',
    trace: { stack: e.stack }  // ERROR: e does not have a stack property
  });
  this.results_.addResult(expectationResult);
};
It would have been preferable to get some sort of spec failure output from jasmine. You could either wrap the fail method in a try/catch, or check that e is defined before creating the ExpectationResult object.
I realize this is a fringe case, but I thought I'd put it out there :)",eschwartz,NONE,2013-12-12 18:52:06+00:00,True,2013-12-13 05:31:30+00:00,0.44,,2,2,2013-12-13 05:31:30+00:00,0.44,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
476,Confusing documentation links,"Hi, for starters, you guys do great work - Jasmine is awesome and the changes in 2.0 look pretty reasonable to me.
I just tried to set up a new project with Jasmine testing though, and a couple of things really confused me:
On http://jasmine.github.io/, the 1.3 text should link to http://pivotal.github.io/jasmine/  - pull request at jasmine/jasmine.github.io#3
The ""Standard Release"" download links on both of those documentation pages point to  https://github.com/pivotal/jasmine/downloads, but the up-to-date packages are actually at https://github.com/pivotal/jasmine/tree/master/dist - I think you should consolidate those into one, preferably the GH downloads page. (The dist/ folder tries to give you a preview of the file, and you have to know to click the ""raw"" link to actually download it, whereas the downloads page is much more straightforward.)
Lastly, searching for ""pivotal labs jasmine"", the top link (on duck duck go) is http://jasmine.pivotallabs.com/ - which is a copy of your home page. That should redirect somewhere useful, or at least give an error.
Sorry if this comes across as nit-picky - I really do love your project, I'm just trying to help it be easier for a new (or old) user to get up to speed :)",nfriedly,NONE,2013-12-17 17:03:38+00:00,True,2014-03-17 01:37:51+00:00,89.36,,2,3,2013-12-17 20:28:30+00:00,0.14,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
477,Problem with RequireJS,"I have a requireJS module currently unit tested with Mocha and Chai. But I am going to use Angular for my project so I tried to unit test with Jasmine 2.0. but having a hard time get it to work.
I follow the post on http://kilon.org/blog/2012/08/testing-backbone-requirejs-applications-with-jasmine/ and included the code bellow in my SpecRunner.js but I keep getting this exception in function HtmlReporter(options) with options is undefined.
require(['jasmine-boot'], function(jasmine){
var jasmineEnv = jasmine.getEnv();
jasmineEnv.updateInterval = 1000;

var htmlReporter = new jasmine.HtmlReporter(); // get options is undefined

jasmineEnv.addReporter(htmlReporter);

jasmineEnv.specFilter = function(spec) {
return htmlReporter.specFilter(spec);
};

var specs = [];
specs.push(""common/validator.spec"");

require(specs, function(){
    jasmineEnv.execute();
});

})
Here is the code need to test (common/validator.js)
define(function(require) {
var v = {};
var validateEmail = function (email) {
var email_verifier = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,4}$/;
return email_verifier.test(email);
}
v.validateEmail = validateEmail;
return v;
});
Here is my simple spec (common/validator.spec.js)
require(['common/Validator'], function(VLDT) {
describe('Validator Module', function () {
describe('validateEmail', function () {
it('should be return true with abcd@gmail.com', function () {
expect(VLDT.validateEmail(""abcd@gmail.com"")).toBe(true);
});
});
});
});
Bellow is partial of my RequireJS config:
/**

RequireJS configuration for unit testing
Extend and override require.vars.js
*/

""use strict"";
// throw error if current config not exists
if (!require) throw(""require does not exists"");
// set baseUrl for unit testing
// require.baseUrl = ""../../web/test"";
// set paths for unit testing
// use libraries from local server instead of CDN
require.paths = require.paths || {};
require.paths['test'] = ""../test"";
require.paths['jasmine'] = ""../libs/jasmine-2.0/jasmine"";
require.paths['jasmine-html'] = ""../libs/jasmine-2.0/jasmine-html"";
require.paths['jasmine-boot'] = ""../libs/jasmine-2.0/boot"";
// set shim for unit testing
// define dependencies for libraries
require.shim = require.shim || {};
require.shim['jasmine'] = {
exports: 'jasmine'
};
require.shim['jasmine-html'] = {
deps: ['jasmine'],
exports: 'jasmine'
};
require.shim['jasmine-boot'] = {
deps: ['jasmine', 'jasmine-html'],
exports: 'jasmine'
};
Please help!
Thanks",vinngn,NONE,2013-12-18 01:36:44+00:00,True,2013-12-18 02:35:00+00:00,0.04,,5,10,2013-12-18 02:35:00+00:00,0.04,sheelc,CONTRIBUTOR,0,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
480,Data Driven Testing,"Following the principles of DRY, it would be great if jasmine offered support for writing tests in a data-driven manner.
This is particularly useful for things like validation helpers, where you want to run a battery of different values against it, and assert that they're either valid or not.
It appears that this has already been blogged about, and even implemented it, but it would be nice to see this in the core.",PeterJCLaw,NONE,2013-12-21 12:15:04+00:00,True,2014-08-06 19:54:50+00:00,228.32,,4,6,2014-01-14 18:06:52+00:00,24.24,dfkaye,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
483,Feature Request: Allow tests to specify their own timeout as an optional third parameter,"Sometimes, it's useful for a particular spec to have a different timeout from the default. At the moment (in 2.0), all timeouts are tied to jasmine.DEFAULT_TIMEOUT_INTERVAL. Many adapters and other implementations allow specifying a per-spec timeout as a third interval:
it('should fail if this takes longer than 50 ms', function() {
  // your test
}, 50);
This is something of a regression from 1.3, since that used to allow 'waitsFor' to specify a timeout per test.",juliemr,NONE,2013-12-26 22:31:47+00:00,True,2014-09-26 05:33:44+00:00,273.29,,10,19,2014-01-07 06:47:45+00:00,11.34,wardbell,NONE,1,2,0,7,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
484,Accidentally created issue delete me,,Tecuya,NONE,2013-12-26 23:56:41+00:00,True,2013-12-26 23:59:17+00:00,0.0,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
485,Skewed images on introduction page in IE,"The svg images on the documentation introduction page appear skewed on IE 11 (and possibly other versions of Internet Explorer):

I ran into an issue similar to this and it ended up being due to a missing viewBox parameter in the svg - perhaps that's what's going on here. Alternatively, the size of the svg could simply be changed so it doesn't need to be scaled.",theodorejb,NONE,2013-12-27 03:49:49+00:00,True,2014-01-05 23:54:21+00:00,9.84,,2,1,2014-01-05 23:54:21+00:00,9.84,sheelc,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
487,Jasmine HTML reporter not honouring reporting dom element,"I found a problem with the jasmine.HtmlReporter class. When you pass a HTML document element it should be using that to append the results into. However it was assuming that document was always passed.
I have changed this to check that the document element has a body or not to determine which element location it should append the report to.",damienwhaley,NONE,2013-12-30 04:01:09+00:00,True,2013-12-30 04:56:57+00:00,0.04,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
491,Feature Request: Sourcemap support,"It would be nice if the original line number of the error is displayed when developing in coffeescript.
For example for this error:
TypeError: entityCollection.get(...) is undefined in http://somehost:[someport]/somepath/SomeSpec.js (line 37)
It can be something like this (reading the sourcemap):
TypeError: entityCollection.get(...) is undefined in http://somehost:[someport]/somepath/Spec.coffee (line 15) (and line 37 on /somepath/SomeSpec.js)
I think this can be done reading the //@sourceMappingURL or the //#sourceMappingURL attribute of the compiled js and later the sourcemap itself (using the value of that attribute), then there is the sourcemap interpretation using https://github.com/mozilla/source-map",nicosommi,NONE,2014-01-02 18:26:11+00:00,False,,,,25,38,2014-01-06 22:02:59+00:00,4.15,infews,CONTRIBUTOR,1,2,0,22,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
492,How to determine if a spec is running? (RE: Angular Mocks),"Angular Mocks checks if a spec is running by using
  // Line 1922
  isSpecRunning = function() {
      return currentSpec && (window.mocha || currentSpec.queue.running);
  };

  beforeEach(function() {
    currentSpec = this;
  });

However in Jasmine 2.0.0 currentSpec.queue doesn;t exist nor does any ""running"" property. How do we determine if a spec is running so we can propose a pull request for NG mocks?",johnpapa,NONE,2014-01-04 15:26:13+00:00,True,2014-01-07 03:08:04+00:00,2.49,,3,5,2014-01-04 16:11:13+00:00,0.03,johnpapa,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
493,Jasmine for ExtendScript,"I've tried to port Jasmine for ExtendScript using the standalone zip file. I have already fixed the errors on that environment which is basically the window object changed to $.global. However I can't get the output displayed on the console. The file console.js doesn't seem to be used. Was this the one responsible for printing the results?
Also, is there already an implementation for ExtendScript?",madevelopers,NONE,2014-01-06 06:25:15+00:00,True,2014-01-07 16:28:02+00:00,1.42,,5,4,2014-01-06 06:44:45+00:00,0.01,sheelc,CONTRIBUTOR,0,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
494,version 2.0 document error,"Following is the description provided for spy and.throwError in the document.
By chaining the spy with and.callThrow, all calls to the spy will throw the specified value.
Is and.callThrow a document error?",smarigowda,NONE,2014-01-06 10:55:25+00:00,True,2014-01-06 15:52:51+00:00,0.21,,2,1,2014-01-06 15:52:51+00:00,0.21,sheelc,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
495,Feature Request: Collapsable Suites/Describes,"With 100's or 1000's of tests it is not fun to scroll through them all to find tests.
Would be easy to have a collapsable set of list items for the specs, by suite.
Would love to see this added.",johnpapa,NONE,2014-01-08 07:12:24+00:00,True,2014-01-08 19:42:45+00:00,0.52,,2,3,2014-01-08 19:42:45+00:00,0.52,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
496,"""Negative zero"" value passed to expect doesn't match value in HTML report","If you have a simple test like:
expect(-0).toEqual(0);
Would expect to see something like this in the report:
Expected -0 to equal 0.
However, Jasmine 2.0 reports a confusing failure:
Expected 0 to equal 0.
Jasmine 1.3 didn't fail on the above test case.",callmevlad,NONE,2014-01-09 21:46:48+00:00,True,2014-02-09 22:15:33+00:00,31.02,,6,9,2014-01-10 05:06:51+00:00,0.31,sheelc,CONTRIBUTOR,0,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
498,Add documentation about how to set up and install jasmine,"I've searched the docs and the README.md but haven't been able to quickly find how to set up Jasmine from scratch (without node js)
The current documentation only explains how to use it.",PVince81,NONE,2014-01-12 15:10:21+00:00,True,2014-01-19 22:16:38+00:00,7.3,,3,4,2014-01-12 15:12:16+00:00,0.0,PVince81,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
499,Jasmine suppresses errors thrown in an Asynchronous context,"Here's an example:
describe ( 'Jasmine suppresses errors in async context', function () {
    it ( 'should throw this error to the console, and stop execution', function () {
        var done = false;

        runs ( function () {
            setTimeout ( function () {
                throw ( 'error' );
                done = true;
            }, 100 );
        } );

        waitsFor ( function () {
            return done;
        } );
    } );
} );

This adds the necessity to first test code outside of Jasmine, until all errors are solved, and then moving tests into Jasmine. It hampers the TDD process.",adriaan-pelzer,NONE,2014-01-14 11:23:34+00:00,True,2014-01-14 19:52:39+00:00,0.35,,3,7,2014-01-14 11:28:46+00:00,0.0,matcarey,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
500,Objects with null prototype cause exceptions when pretty-printing,"This test:
describe(""objects"", function() {
  it(""should print results for null protos"", function() {
    var o = Object.create(null);
    var o2 = Object.create(null);
    expect(o).toBe(o2);
  });
});

Will fail while reporting the test faillure with:
1) objects should print results for null protos.
  TypeError: Object [object Object] has no method 'hasOwnProperty'
    at PrettyPrinter.iterateObject (<...>lib/jasmine/lib/jasmine-core/jasmine.js:1350:16)

I think a fix would be to have https://github.com/pivotal/jasmine/blob/2670bb40a7d0135553a688f0102ee6e0d8500dc1/lib/jasmine-core/jasmine.js#L1393 use Object.prototype.hasOwnProperty.call rather than relying on the object itself having the field, but I'm not familiar enough with the internals to know what else that change could affect, so it's just a guess.",jpolitz,NONE,2014-01-15 14:40:33+00:00,True,2014-01-18 05:57:39+00:00,2.64,,4,3,2014-05-20 12:11:02+00:00,124.9,meltuhamy,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
501,How to wait synchronously before to run an expectation,"I am trying to test the postMessage API as there is a slight delay before message are receive i can not run expectation right after sending a message.
In jasmine 1.3 i used to wait() a few milliseconds before running expectation and that worked fine. However with jasmine 2.0 wait() is deprecated and it now seems that everything inside a setTimeout do not get run unless done() is called, witch in my case doesn't cut it as i actually want to wait real time before running my expectation..
Not sure if that all make sense, if it does I'd love some pointers on how I could go about this.
Thanks!",m4nuC,NONE,2014-01-16 08:24:00+00:00,True,2014-01-19 03:57:18+00:00,2.81,,4,9,2014-01-18 00:27:04+00:00,1.67,slackersoft,MEMBER,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
502,Feature Request: Stub a variable (vs spyOn a function),"Hi,
I often find myself needing a feature where I can stub a variable (either a global variable, or an object's member variable) with a fake value or dummy implementation.  Note: I am not referring to spyOn-ing on a function call.
example:
window.foo = 7;

window.bar = Backbone.View.Extend({
   initialize: function(){
     // complex behavior with alot of setup required or side-effects kicked off
     throw(""side effects...."");
   }
});

Then I have a ""baz"" module, which I want to test and isolate the tests to just ""baz"" functionality, so I'd like todo this:
jasmine.stub(window, ""foo"", 42);
jasmine.stub(window, ""bar"", fakeSimpleBackboneView);

Note: I could just do window.foo = 42 in my ""baz"" test, but jasmine.stub would perform the cleanup after the test, just like spyOn does.
If you guys think this is a good idea, I will work on a pull request to jasmine.  If not, that's cool too and I will release a seperate module which people can pull into their projects.  I just want to ask upfront to avoid double work.  (I would predict higher usage if it's in jasmine core).  What are your guys thoughts?  @infews?
Thanks,
Tom",tommyh,NONE,2014-01-16 18:21:55+00:00,True,2014-01-16 19:50:13+00:00,0.06,,3,3,2014-01-16 19:29:58+00:00,0.05,infews,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
504,toThrow does not except if ExceptionClass is undefined,"I created an Error-Class in my library:
var mylib = {};
mylib.MyError = function () {
this.message=""something went wrong"";
this.name = ""mylib::MyError"";
};
mylib.MyError.prototype = new Error();
mylib.MyError.prototype.constructor = MyError;
...
This is how Nicolas Zakas recommends to create your own Error class if you want to differentiate Errors  in a try-catch-block.
I created a test spec expecting this:
expect(mylib.myfunc()).toThrow(mylib.myMissSpelledError);
Resulting in a toThrow()-Call with an expected-argument of value undefined.
I would expect that toThrow() should now throw an Exception informing me, that the caught Error is not of the specified Error-Class. But it does not!
I think this happens, because toThrow() compares the caughtException with jasmine.undefined before checking if the exception is of the right class.
jasmine.undefined is in my Environment (Chrome  32.0.1700.76 m) also of value undefined, so the test succedes although it should not!
I am using jasmine 1.3.1 from
""http://cdnjs.cloudflare.com/ajax/libs/jasmine/1.3.1/jasmine.js
A fix might be to define jasmine.undefined as
jasmine.undefined = {};
By that jasmine would have an unique value (the pointer of the object literal) and would be differentiable from javascripts undefined.",fonzerelly,NONE,2014-01-20 14:26:08+00:00,True,2014-02-24 19:04:46+00:00,35.19,,3,2,2014-01-20 16:39:50+00:00,0.09,infews,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
505,Way to specify that async examples may NOT be run simultaneously?,"I am trying to write specs for an indexedDB adapter, and the setup deletes the database before each run. The problem I am having is that the test block each other, and time out. Any single test will run successfully if all the others are commented out.
I need some way to specify that although these tests are asynchronous, each one must wait to start until the previous one has completed.
Thanks,
-- Steve J.",stevecj,NONE,2014-01-22 22:19:52+00:00,True,2014-01-23 02:31:26+00:00,0.17,,3,7,2014-01-22 22:24:20+00:00,0.0,infews,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
507,Unable to uncompress dist/zip files,"I tried to uncompress :

https://github.com/pivotal/jasmine/blob/master/dist/jasmine-standalone-1.3.1.zip
https://github.com/pivotal/jasmine/blob/master/dist/jasmine-standalone-2.0.0.zip

But was unable to decompress it. ( Unzip failed with errors )
I even tried online archivers they also failed with errors.
I guess there is some problem with the compression tool.",yugaljindle,NONE,2014-01-25 17:48:21+00:00,True,2014-01-25 18:08:14+00:00,0.01,,1,1,2014-01-25 18:08:14+00:00,0.01,yugaljindle,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
508,Sealed object can't be compared,"Jasmine comparer and pretty printer is trying to extend sealed objects with property 'Jasmine_been_here_before'. This property is silently doesn't added to the object and Jasmine doesn't work properly.
I am getting an error: TypeError: Object [object Object] has no method 'hasOwnProperty'
jasmine.Env.prototype.compareObjects_ = function(a, b, mismatchKeys, mismatchValues) {

  if (a.__Jasmine_been_here_before__ === b && b.__Jasmine_been_here_before__ === a) {
    return true;
  }

  a.__Jasmine_been_here_before__ = b;
  b.__Jasmine_been_here_before__ = a;

  var hasKey = function(obj, keyName) {
    return obj !== null && obj[keyName] !== jasmine.undefined;
  };

...",gedbac,NONE,2014-01-27 12:44:14+00:00,True,2014-04-17 23:52:04+00:00,80.46,,3,3,2014-01-27 16:25:51+00:00,0.15,infews,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
509,SpecRunner output is not color-deficiency-friendly,I am red/green color deficient (like 8% of men) and I can't distinguish between passed and failed specs visually. It would be nice if the colors that represented failure and success were more different and not red and green.,modelm,NONE,2014-01-29 23:06:27+00:00,True,2014-01-30 21:37:53+00:00,0.94,,2,1,2014-01-30 21:37:53+00:00,0.94,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
510,Filtering out specs in HTML report,"In Jasmine 1.3, clicking on a suite or a specific spec (e.g. TestRunner.html?spec=A spy) would only show that spec (or tree) in the HTML report, which was really handy. Jasmine 2.0 seems to write out the entire tree, with disabled specs having a different style, which can be quite verbose (especially with thousands of specs in the report).
Is there a way to enable 1.3-like reports in 2.0? If not, would you guys be open to a pull request to restore 1.3-like behavior (or at least have the option to revert to that mode with a query parameter)?",callmevlad,NONE,2014-01-30 22:17:20+00:00,True,2016-11-04 17:29:18+00:00,1008.8,,5,10,2014-01-30 22:35:57+00:00,0.01,infews,CONTRIBUTOR,1,1,0,3,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
511,jasmine-core boot.js duplicated,"In the npm package of jasmine-core, it appears that boot.js is duplicated.

jasmine-core/

boot.js
boot/

boot.js





Is there a reason for the duplication, or is this just an oversight?",intel352,NONE,2014-01-31 02:53:06+00:00,True,2014-08-26 20:15:00+00:00,207.72,,4,5,2014-01-31 19:26:56+00:00,0.69,infews,CONTRIBUTOR,1,1,0,2,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
512,Make bootstrap AMD/CommonJS compliant,"Currently Jasmine 2 cannot be used (or at least requires a lot of brute force) to test modular JavaScript, such as files authored as AMD modules to be used with a script loader such as RequireJS. Fundamentally I think the only limitation is this line: https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/boot.js#L187
I think it would be extremely useful if the boostrap could export a simple interface for use with a script loader. For example:
function kickoff() {
  if (currentWindowOnload) {
    currentWindowOnload();
  }
  htmlReporter.initialize();
  env.execute();
};

if ( typeof define === 'function' && define.amd ){
  define(function() {
    return kickoff;
  });
}
else if ( typeof module !== 'undefined' && module.exports ) {
    module.exports = kickoff;
}
else {
  window.onload = kickoff;
}
I'm quite probably way oversimplifying the issue (I don't have much knowledge of the Jasmine internals) but this would be really, really useful!",i-like-robots,NONE,2014-01-31 15:30:15+00:00,True,2014-02-03 17:32:01+00:00,3.08,,2,3,2014-01-31 19:19:38+00:00,0.16,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
513,Example-specific context to make async code problems easier to diagnose,"I have run into a case where I have async code timing out, and it's hard to isolate the real problem because the same vars are shared across multiple test passes, and code that runs after timeout is having state interactions with test that started after the first one timed out.
It would be nice if each time an example runs, it has access to its own context object that will be shared between all the beforeEach, afterEach, and it calls, but not shared with any other example runs.
(or perhaps there's already some way to accomplish something similar that I don't know about)
This would be kind of nice for synchronous examples too since the context would always start out as a an empty object with no risk of having anything left over from a previous run. For synchronous examples, this can be achieved simply by having a top-level beforeEach that assigns c = {}, but it would be nice to have the pattern be institutionalized in jasmine.
Unfortunately, I can't see any way of delivering the example-run context to each method that needs it except by way of a parameter, but the arity of the function is already used to indicate an asynchronous step receiving a done function. Perhaps, there is some other way to accomplish this that I have not thought of though.",stevecj,NONE,2014-02-02 18:50:17+00:00,True,2014-02-02 19:14:04+00:00,0.02,,2,5,2014-02-02 19:06:10+00:00,0.01,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
514,Need a main entry point for node,"As @substack has noted in this comment, the way to require Jasmine in node now is very weird and non-obvious. It's not even documented. Can we have a main entry point AKA a valid main entry inside package.json so library authors can have an easier time consuming Jasmine please?",wyuenho,NONE,2014-02-04 01:35:56+00:00,True,2014-10-31 20:12:17+00:00,269.78,,6,11,2014-02-11 18:43:30+00:00,7.71,sindresorhus,NONE,2,1,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
515,resart jasmine test suite in from browser console in debug mode,"Hi,
I need to restart my jasmine test suite from my debug console is it possible?
I use the following  steps ot be in the console
https://github.com/ekonijn/grunt-require-demo/blob/master/doc/debugging-jasmine.md#attaching-developer-tools-to-phantomjs
Then I can see a jasmine and jasmine object etc ...
I tried to execute the test suite with
jasmine.Suite.prototype.execute();
without success, i think i should initialize something first but don't know why what !
Thx",mmslice,NONE,2014-02-04 23:07:14+00:00,True,2014-09-21 04:08:16+00:00,228.21,,2,2,2014-02-26 22:57:27+00:00,21.99,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
516,testing fadeOut() method,"Hi guys, I'm new to Jasmine 2.0 as we were been using 1.0 version and got stuck with that for a while. I wonder if there's a way to test fadeOut callbacks? I know that waitsFor() method is already deprecated on this new version. Is there a way to test the fadeOut() callback using Jasmine Clock?
Thanks,
marc",marcagas,NONE,2014-02-05 02:38:33+00:00,True,2014-02-12 02:05:30+00:00,6.98,,2,2,2014-02-05 05:40:31+00:00,0.13,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
518,track spy call number document outdate,"index page document  list
  it(""tracks its number of calls"", function() {
    expect(foo.setBar.calls.length).toEqual(2);
  });

but in  jasmine 2.0.0 ,the right case seem
  it(""tracks its number of calls"", function() {
    expect(foo.setBar.calls.count()).toEqual(2);
  });

is the index document outdate?",lvscar,NONE,2014-02-10 10:04:56+00:00,True,2014-02-10 15:52:32+00:00,0.24,,2,2,2014-02-10 15:52:32+00:00,0.24,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
519,Document new custom matcher inferface.,"So the release document states that something has changed, and apparently my setup from 1.x does not work anymore. Could you please document what the new correct way is to add custom matchers?",cburgmer,NONE,2014-02-11 22:54:22+00:00,True,2014-02-12 00:13:14+00:00,0.05,,2,2,2014-02-12 00:13:14+00:00,0.05,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
520,performance issue with toHaveBeenCalledWith arguments check,"Hey,
I noticed some strange slow behavior when using toHaveBeenCalledWith with Backbone events. It seems like the arguments check for the call is going down some slow path, it causes the browser to eat up a lot of memory and slows the tests down.
When I perform the arguments check myself it doesn't seem to do this.
Here is an example:
it('should receive some event', function() {
  var mySpy = jasmine.createSpy('mySpy');
  var model = new Backbone.Model(), anotherModel = new Backbone.Model();
  model.on('mySpy', mySpy);

  model.trigger('mySpy', anotherModel);
  //The following toHaveBeenCalledWith is crazy slow...
  expect(mySpy).toHaveBeenCalledWith(anotherModel);
});

My fix was to do the following:
it('should receive some event', function() {
  var mySpy = jasmine.createSpy('mySpy');
  var model = new Backbone.Model(), anotherModel = new Backbone.Model();
  model.on('mySpy', mySpy);

  model.trigger('mySpy', anotherModel);
  expect(mySpy).toHaveBeenCalledWith(jasmine.any(Backbone.Model));
  expect(mySpy.calls.mostRecent().args[0]).toEqual(anotherModel);
});

I think the slow path is caused by jasmine.js:2165
if (util.contains(actual.calls.allArgs(), expectedArgs)) {

Somehow the contains check is recursing in a weird way for backbone models and callbacks at least to cause some serious performance issues. I can do more analysis of the actual cause but I wanted to report it right away. Has anyone else seen a problem like this?",rdy,NONE,2014-02-16 17:46:10+00:00,True,2014-02-19 04:07:33+00:00,2.43,,5,12,2014-02-16 18:50:13+00:00,0.04,jboyens,MEMBER,1,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
523,Calling done after timeout continues test execution,"Calling done after timeout causes execution of tests to continue. Done should be invalidated when timeout causes the test to fail and any calls to done after that should  not do anything.
Example:
http://jsfiddle.net/6bPD8/1/
var asyncTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
describe(""Async tests"", function() {
it(""should be possible to call done after timeout without causing tests to continue"", function(done) {
  _.delay(function () {
      done();
  }, asyncTimeout + 1000);

});
});
Running the test above executes the test twice:
1 spec, 1 failure
Spec List | Failures
raise exceptions
2 specs, 2 failures
Spec List | Failures
Async tests should be possible to call done after timeout without causing tests to continue
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
at http://cdnjs.cloudflare.com/ajax/libs/jasmine/2.0.0/jasmine.js:281:23
Async tests should be possible to call done after timeout without causing tests to continue
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
at http://cdnjs.cloudflare.com/ajax/libs/jasmine/2.0.0/jasmine.js:281:23",kharrhei,NONE,2014-02-18 09:35:54+00:00,True,2014-02-26 02:06:52+00:00,7.69,,2,2,2014-02-18 09:58:22+00:00,0.02,kharrhei,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
524,Green dots cutting off on the test suite display,".html-reporter .symbol-summary li {
display: inline-block;
height: 8px;
width: 14px;
font-size: 16px;
}
should be
.html-reporter .symbol-summary li {
display: inline-block;
height: 14px;
width: 14px;
font-size: 16px;
}
jasmine v2.0.0
Can you please fix this?",i-bajrai,NONE,2014-02-20 07:42:06+00:00,True,2014-10-23 20:32:16+00:00,245.53,,6,7,2014-02-20 16:14:26+00:00,0.36,infews,CONTRIBUTOR,1,2,0,3,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
525,add done() to describe() so that you can load data once and then test it.,"I was looking for a way to request data just once inside of a test suite, and then test the result against multiple it() blocks without having to request the data multiple times in a beforeEach(). It seems like this could be accomplished by adding the async done() function to describe().",mroberge,NONE,2014-02-21 05:25:13+00:00,True,2014-09-25 19:50:42+00:00,216.6,,4,4,2014-02-23 03:46:42+00:00,1.93,stevecj,NONE,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
526,How do I run before and after asynchronous specs in jasmine 2.0,"The new done() syntax, at first glance, appears to be far less flexible than the old syntax. Using done how do I implement something like:
it('should allow multi stage asynchronisity', function () {
    runs(function () {
        //set up
        var initialState
        // call something asynchronous
        expect(middleState).toEqual(initialState);
    });

    waits(200);

    runs(function () {
        expect(middleState).not.toEqual(initialState);
       // call something else asynchronous
        expect(finalState).toEqual(middleState);
    });

    waits(200);

    runs(function () {
       // call something else asynchronous
        expect(finalState).not.toEqual(middleState);
    });
});",wheresrhys,NONE,2014-02-21 15:59:43+00:00,True,2014-06-23 03:22:43+00:00,121.47,,5,7,2014-02-21 19:33:27+00:00,0.15,infews,CONTRIBUTOR,1,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
528,"Equivalent of RSpec ""let""","In a project that I'm working on, I have defined a ""def"" method on the user context object (this) that works similarly to the ""let"" method in RSpec. This works fine, but it would be nice to have a standard way of doing this in Jasmine.
I could just make a PR to add the functionality to Jasmine as a ""def"" method on the user context, but I'm not sure if that's the best API for such a thing. Any better suggestions for an API?
For the implementation in my project, see https://github.com/stevecj/headway/blob/master/spec/support/userContextExt.js .",stevecj,NONE,2014-02-22 21:26:55+00:00,True,2014-10-24 19:55:23+00:00,243.94,,3,2,2014-07-29 14:59:27+00:00,156.73,Benmidi,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
529,Fail with error & stack trace in asynchronous code,"When an error is thrown from asynchronous code, Jasmine currently has no way of knowing that it happened, skipping subsequent stages (e.g. ""it"" following error in ""beforeEach"") and reporting a trace.
As a workaround, I have written helper code to catch and record the error from a function execution so that it can be re-thrown from an ""afterEach"" block. This solution at least gives a failure and a stack trace, but still leaves a lot to be desired.
For my partial workaround, see the ""asyncStep"" and ""getCaptureAsyncError"" functions in https://github.com/stevecj/headway/blob/master/spec/support/userContextExt.js . To see how those are used, see https://github.com/stevecj/headway/blob/master/spec/indexedDbAdapterSpec.js .",stevecj,NONE,2014-02-22 21:39:09+00:00,True,2017-03-08 00:34:31+00:00,1109.12,,13,36,2014-02-24 19:24:45+00:00,1.91,sheelc,CONTRIBUTOR,2,2,0,9,"['feature request', 'has Tracker story', 'ready for work']",False,True,False,False,False,False,False,False,True,True,False,False,False,False,False
530,Feature request: Allow passing multiple functions into `it` for a better asynchronous testing API,"As raised here #526 the API for multi stage asynchronous test is a marked regression from 1.3. It forces the developer to misuse beforeEach in order to get asynchronous behaviour in a single spec. It also means various mid-point testable values need to be stored and then finally passed into expect only when the it call is finally reached.
An improvement would be to allow multiple callbacks to be passed in to it which would be called in a waterfall fashion e.g.
it('does the job asynchronously', function (done) {
   // setup code
   expect(aValue).toBe('just fine');
   done();
}, function (done) {
   //more test code
   expect(anotherValue).toBe('dandy');
   done();
});

as opposed to the current api
describe('only here to bend the asynchronous testing API into shape', function () {
    var aCachedValue;
    beforeEach(function () {
       // setup code
       aCachedValue = aValue;
       done();   
    });
    it('does the job asynchronously', function (done) {
       //more test code
       expect(aCachedValue).toBe('just fine');
       expect(anotherValue).toBe('dandy');
       done();
    });
});",wheresrhys,NONE,2014-02-24 10:50:33+00:00,True,2014-10-31 20:09:04+00:00,249.39,,3,2,2014-08-14 05:16:06+00:00,170.77,slackersoft,MEMBER,1,0,0,0,"['feature request', 'waiting']",True,True,False,False,False,False,False,False,False,False,False,False,False,False,False
532,toHaveBeenCalledWith fails for repeated use of Float32Array,"Spies keep a reference to Float32Array when called with them, but should keep a copy:
var spy = jasmine.createSpy('spy');
var data = new Float32Array(1);
data[0] = 1;
spy(data);
data[0] = 2;
spy(data);
expect(spy).toHaveBeenCalledWith([1]); // fails (false negative).
expect(spy).toHaveBeenCalledWith([2]); // passes.",alecmce,NONE,2014-02-27 16:12:39+00:00,True,2014-02-27 18:01:59+00:00,0.08,,2,1,2014-02-27 18:01:58+00:00,0.08,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
533,expect({}).toEqual([]) should fail but doesn't.,"I just ran the assertion expect({}).toEqual([]); and it passed. Unless there's some decision that I'm not aware of by the developers, I'd think this assertion should fail.",opnsrce,NONE,2014-02-27 16:58:47+00:00,True,2014-02-27 17:50:38+00:00,0.04,,2,1,2014-02-27 17:50:38+00:00,0.04,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
534,Crashes Firefox with unresponsive script,"There are cases where a running Jasmine test suite will eventually crash Firefox, with the ""unresponsive script"" dialog popping up. Stopping the script will in some instances stop the runner, but in some fewer instances crash Firefox.
It seems switching tabs with a running test suite will trigger that behaviour:

Switching back will suddenly show failing tests,
After the test suite finishes even more failing tests will pop up,
Eventually the tab hangs.",cburgmer,NONE,2014-02-27 18:59:36+00:00,True,2014-03-04 21:20:11+00:00,5.1,,2,5,2014-02-27 19:00:20+00:00,0.0,cburgmer,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
535,Need to reset Jasmine environment between specs?,"I just upgraded Jasmine

jasmine-core 1.3.1 -> 2.0.0
jasmine-jquery-rails 1.5.9 -> 2.0.2
jasmine-rails 0.5.6 -> 0.6.0

I have several spec files. Each of them are structured the same way: require of jquery and jasmine-jquery files and a top beforeEach that load fixture, followed by my examples.
After upgrade I noticed that when I run all specs (by accessing '/jasmine') I have many failures.
But if I run them individually (by accessing '/jasmine?spec=MySpec') all tests pass.
I am forgetting some kind of 'reset' statement in my specs?
Thanks for your help",randoum,NONE,2014-02-28 08:11:52+00:00,True,2014-09-21 04:08:40+00:00,204.83,,3,2,2014-03-02 20:17:44+00:00,2.5,sheelc,CONTRIBUTOR,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
536,toHaveBeenCalledWith does no longer work with custom matcher,"In Jasmine 1.3 you could use your custom matcher with toHaveBeenCalledWith, which was especially useful to ensure that the actual argument was identical to the expected one, not just equal. E.g.:
  var mySpy = jasmine.createSpy();
  var foo = {};
  var bar = {};
  mySpy( foo );

  expect( mySpy ).toHaveBeenCalledWith( foo );
  expect( mySpy ).toHaveBeenCalledWith( bar );
  expect( mySpy ).toHaveBeenCalledWith( same( foo ) );
  expect( mySpy ).not.toHaveBeenCalledWith( same( bar ) );

This is no longer possible with Jasmine 2.0, only 'any' and 'objectContaining' are accepted.",tbuschto,NONE,2014-03-01 11:29:31+00:00,True,2014-03-27 05:20:30+00:00,25.74,,4,5,2014-03-03 18:33:51+00:00,2.29,infews,CONTRIBUTOR,0,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
537,Request: Supply filename and line numbers for specs,"I've created a Visual Studio Test Adapter for Jasmine; but I've had to put a massive hack in it to discover tests and get filenames/line numbers.
When ""discovering"" tests I previously used the filter so that none would run; but I couldn't provide VS with file/line number to allow the user to double-click to jump to a test.
So, I implemented a horrendous bodge, where when discovering tests, the it function is rigged to explode, and I can parse the stack trace.
This is nasty; it would be nicer if Jasmine provided file/line info for a spec in the information; and then I can go back to using the filter to simply disable execution when discovering.",DanTup,NONE,2014-03-02 17:52:09+00:00,True,2014-03-02 19:05:55+00:00,0.05,,4,4,2014-03-02 19:03:56+00:00,0.05,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
539,regression: toThrowError() won't accept jasmine.any(String),"Example fiddle here - http://jsbin.com/debipanu/1/edit
It fails the RegExp, typeof 'string' and error type checks, then throws error 'Expected is not an Error, string, or RegExp.'.
https://github.com/pivotal/jasmine/blob/31d71ac22fd3e7e994e014229f83b96b81c9f8dd/src/core/matchers/toThrowError.js#L123
I don't know how important this use-case is, as expecting toThrow() is just as meaningful and works fine.",alextreppass,CONTRIBUTOR,2014-03-04 15:50:36+00:00,True,2014-06-23 03:17:36+00:00,110.48,,2,1,2014-06-23 03:17:30+00:00,110.48,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
541,How can I use jasmine?,"The documentation contains a lot about writing tests, but I can not find anything about setting it up.
Am I missing something?",EECOLOR,NONE,2014-03-06 21:58:12+00:00,True,2014-03-06 22:30:01+00:00,0.02,,5,7,2014-03-06 22:30:01+00:00,0.02,infews,CONTRIBUTOR,0,3,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
542,throwing string exceptions does not display correctly in the exception formatter,"If you have something in a spec like:
throw 'Expected selector ' + $jquery.selector + ' to match exactly 1 element, but matched ' + $jquery.length)'

jasmine reporter displays this as undefined: undefined
Throwing this:
throw new Error('Expected selector ' + $jquery.selector + ' to match exactly 1 element, but matched ' + $jquery.length);

Displays the exception correctly. We should probably check to see if the exception is a string before calling 'message' on it.
We should probably fix this in jasmine:
getJasmineRequireObj().ExceptionFormatter = function() {
  function ExceptionFormatter() {
    this.message = function(error) {
      var message = error.name +
        ': ' +
        error.message;

      if (error.fileName || error.sourceURL) {
        message += "" in "" + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += "" (line "" + (error.line || error.lineNumber) + "")"";
      }

      return message;
    };

    this.stack = function(error) {
      return error ? error.stack : null;
    };
  }

  return ExceptionFormatter;
};

We should check to see if error is a string before dereferences name and message. I can send a pull request if you like.",rdy,NONE,2014-03-07 18:22:55+00:00,True,2014-03-08 23:31:35+00:00,1.21,,2,3,2014-03-08 07:07:43+00:00,0.53,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
543,Add custom expectation modifiers,"Jasmine provides the .not expectation modifier that enables us to write pretty things like:
expect(myString).not.toBe('foo');
I would like the ability to write functions similar to .not in the same way that I can write custom matchers. This would come in handy when I am writing tests on a complex object and I want to extract a piece of information from that object to test:
expect(myComplexObject).withSubtleCharacteristic('foo').toBe('bar')
I imagine that writing such a modifier could look something like
this.addExpectationModifiers({
  withSubtleCharacteristic = function(propertyName) {
    return this.actual[transform(propertyName)];
  }
});
Obviously this is a contrived example, but imagine that the transform function performs some complex operation that I want to abstract behind the withSubtleCharacteristic modifier.",alexdmiller,NONE,2014-03-07 19:48:28+00:00,True,2014-10-23 19:56:28+00:00,230.01,,2,2,2014-08-07 20:29:39+00:00,153.03,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
544,Spies wiki page out of date,The wiki page on spies seems to be using the old pre-2.0 syntax. Needs an update.,togakangaroo,NONE,2014-03-10 20:08:40+00:00,True,2014-06-23 03:28:08+00:00,104.31,,3,3,2014-03-10 20:17:30+00:00,0.01,jaapz,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
545,Gramatical Error in Jasmine v2.0 Docs 'toBeGreaterThan' Example,"The string param in the 'it' function in the 'toBeGreaterThan' function should be
""The 'toBeGreaterThan' matcher is for mathematical comparisons""
not
""The 'toBeGreaterThan' is for mathematical comparisons""",siegbenn,NONE,2014-03-10 20:45:01+00:00,True,2014-03-12 23:59:39+00:00,2.14,,2,1,2014-03-12 23:59:39+00:00,2.14,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
546,Mock Clock TODO in documentation for the released version of Jasmine 2.0.,"In the 2.0 docs, there is a section on using the mock clock in single tests. However, it actually contains a TODO message and the code that should be on the right hand side appears with the rest of the text. A screenshot probably explains the issue better:

Link to the section on the live docs",tonyfinn,NONE,2014-03-11 11:10:24+00:00,True,2014-03-12 23:55:41+00:00,1.53,,3,2,2014-03-11 20:39:35+00:00,0.4,freethejazz,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
547,Re-expose detailed spec result information to reporters,"Hi, I'm looking at moving a test suite to Jasmine 2.0.0 and have it running fine locally, however running it remotely on Saucelabs depends on programmatic access via a custom reporter, namely: jasmine-jsreporter.
In Jasmine 1.3.1, specs used to expose the following information to reporters:

durationSec
totalCount
passedCount
failedCount

@sclevine has done some work to port jasmine-jsreporter in jasmine-jsreporter/pull/7 but it seems the above information is no-longer available to reporters in Jasmine 2.0.0.
Would it be possible to get the above back into Jasmine 2?",alextreppass,CONTRIBUTOR,2014-03-11 14:50:03+00:00,True,2014-06-23 03:31:35+00:00,103.53,,3,7,2014-03-11 16:52:26+00:00,0.08,sclevine,NONE,0,2,0,1,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
549,Calling `done` followed by more expect will report to the reporter multiple times,"consider the spec:
describe('a block', function() {
  it('uses done improperly', function(done) {
    expect(1).toBe(1);
    done();
    expect(2).toBe(2);
  });
});
In this spec we have 2 expect statements and a done statement. The reporter is called with a specDone after done is called, and again after the it returns. This causes a problem for custom reporters, as suiteDone and specDone both get called multiple times. If the spec with the misplaced done is the last spec to be called, suddenly jasmineDone is called, then afterwords specDone, followed by suiteDone, then yet another jasmineDone.
I would suggest that done() updates a variable in closure scope around the function that contains it and sets the status as done. This has the side effect of waiting until the spec itself is done, and then checking to verify that done has been called as well. I'm seeing a few obvious problems with this, but something could probably be done around that.
Please let me know if this is unclear or if you have any questions. This issue just bit me bigtime while writing a reporter for jasmine-node's upgrade to Jasmine2.0 (available on the Jasmine2.0 branch)",tebriel,NONE,2014-03-13 19:25:53+00:00,True,2014-08-26 19:48:31+00:00,166.02,,3,6,2014-03-27 06:05:23+00:00,13.44,sheelc,CONTRIBUTOR,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
551,Pip install jasmine failing,"Trying to install jasmine using [pip install jamsine] but it's failing, see output below:
Downloading/unpacking jasmine-core>=2.0 (from jasmine)
Downloading jasmine-core-2.0.1.tar.gz (41kB): 41kB downloaded
Running setup.py egg_info for package jasmine-core
Traceback (most recent call last):
File """", line 16, in 
File ""/Users/tomclement/Envs/jazz/build/jasmine-core/setup.py"", line 4, in 
with open('package.json') as packageFile:
IOError: [Errno 2] No such file or directory: 'package.json'
Complete output from command python setup.py egg_info:
Traceback (most recent call last):
File """", line 16, in 
File ""/Users/tomclement/Envs/jazz/build/jasmine-core/setup.py"", line 4, in 
with open('package.json') as packageFile:

IOError: [Errno 2] No such file or directory: 'package.json'",tomclement,NONE,2014-03-14 10:12:29+00:00,True,2014-03-21 22:20:44+00:00,7.51,,2,1,2014-03-14 15:08:08+00:00,0.21,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
552,Jasmine Bootstrap Reporter,"Hi
I would like to see support added for an official Jasmine reporter that would utilize Twitter Bootstrap.
For the moment, this is what I am using: https://github.com/agileapes/jasmine-bootstrap/
(this is actually something I have written personally, but I'm not that familiar with Jasmine in the first place)
I think the formatting looks a little better this way.",mmnaseri,NONE,2014-03-15 22:49:24+00:00,True,2014-03-17 04:47:48+00:00,1.25,,2,1,2014-03-17 04:47:48+00:00,1.25,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
553,jasmine 2.0 incompatible with code completion,"Using jasmine 2.0 as a javascript library in jetbrains products fails during code completion due to hidden function declarations for main entry points such as describe, it.",robmurtha,NONE,2014-03-16 09:33:22+00:00,True,2014-10-23 20:32:54+00:00,221.46,,3,3,2014-06-23 03:34:08+00:00,98.75,infews,CONTRIBUTOR,1,1,0,0,"['feature request', 'waiting']",True,True,False,False,False,False,False,False,False,False,False,False,False,False,False
554,addMatchers have stopped when using  karma-jasmine 2.2,"Please have a look at this issue that came up
zcaudate-me/example.purnam.test#1
I'm wondering if someone could advise on what broke and how to fix the problem.",zcaudate,NONE,2014-03-17 22:00:51+00:00,True,2014-08-05 22:44:06+00:00,141.03,,4,3,2014-04-11 13:19:39+00:00,24.64,alextreppass,CONTRIBUTOR,1,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
555,External CoffeeScript tests aren't run,"Jasmine v2.0 does not run tests in external <script type=""text/coffeescript""> files despite ostensibly seeing the describe calls in which they are contained.  If the CoffeeScript is inline in the <script> tag (i.e. there is no src attribute), Jasmine runs the tests properly.  However, as soon as they are moved into a separate file, Jasmine does not seem to notice them at all (""0 specs, 0 failures"").
Here's a short example, assuming you have coffee-script.js in the same directory.
<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8"">
  <title>Jasmine Spec Runner v2.0.0</title>

  <link rel=""shortcut icon"" type=""image/png"" href=""lib/jasmine-2.0.0/jasmine_favicon.png"">
  <link rel=""stylesheet"" type=""text/css"" href=""lib/jasmine-2.0.0/jasmine.css"">

  <script type=""text/javascript"" src=""coffee-script.js""></script>

  <script type=""text/javascript"" src=""lib/jasmine-2.0.0/jasmine.js""></script>
  <script type=""text/javascript"" src=""lib/jasmine-2.0.0/jasmine-html.js""></script>
  <script type=""text/javascript"" src=""lib/jasmine-2.0.0/boot.js""></script>

  <!-- This works fine (both console.log()s are called): -->
  <!--<script type=""text/coffeescript"">
    describe ""my spec"", ->
    console.log ""In describe() call.  Looks like Jasmine sees the spec.""
    it ""works"", ->
      console.log ""In it() call.  Looks like Jasmine is running the test.""
      expect(true).toBe(true)
  </script>-->

  <!-- This doesn't: -->
  <script type=""text/coffeescript"" src=""some-file.coffee""></script>
</head>

<body>
</body>
</html>
There are some CoffeeScript + Jasmine examples floating around, but they're all for v1.  v1 seemed to work fine with separate CoffeeScript files.",SyntaxColoring,NONE,2014-03-18 01:55:32+00:00,True,2014-03-20 23:36:32+00:00,2.9,,2,7,2014-03-19 05:01:58+00:00,1.13,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
556,Spy method is reset to original with setTimeout.,"Within the done call of an deferred object, the spied method reset to the original method, not the spied version.
Test case here:
http://jsfiddle.net/wzAyL/91/",unional,NONE,2014-03-19 19:02:32+00:00,True,2014-03-19 20:38:07+00:00,0.07,,2,2,2014-03-19 20:40:58+00:00,0.07,unional,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
557,Simplify custom matchers,"I really like the new result based approach for custom matchers in 2.0 but the thunk/compare approach introduces unnecessary boilerplate.
Any chance of a way to add simple matchers such as the one below?
jasmine.addMatchers({
  myMatcher: function(actual, expected) {
    var result = {};
    result.pass = ...;
    result.message = ...;
    return result;
  }
});

Even if it needs to be through a separate jasmine.addMatchersSimple() method it would be far better than the current approach.
jasmine.addMatchers({
  myMatcher: function(utils, customEqualityTesters) {
    return {
      compare: function(actual, expected) {
        var result = {};
        result.pass = ...;
        result.message = ...;
        return result;
      }
    };
  }
});

Why not just make utils available through jasmine.utils in the first place?  Happy to put this together as a pull request if there's interest.",rymohr,NONE,2014-03-20 00:30:51+00:00,True,2014-06-23 03:35:38+00:00,95.13,,3,10,2014-03-20 03:55:40+00:00,0.14,infews,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
558,"SpecRunner.html as referred to in the documentation, doesn't seem to exist","Steps to reproduce:

git clone https://github.com/pivotal/jasmine.git huh
cd huh
consult http://jasmine.github.io/2.0/introduction.html.  Seems like SpecRunner.html is where i can do configuration and things.
Look for SpecRunner.html.  It's not there.

Hmm...
find . -name SpecRunn\*
./grunt/templates/SpecRunner.html.jst
./spec/core/integration/SpecRunningSpec.js

Hmmm.  Am I sure I'm running the right version?
Seems to be 2.0 per screen shot:


Edit ./grunt/templates/SpecRunner.html.jst just to see if I can get something to change
Restart server, changes not reflected 😦
Post issue.

I'm a bit embarrassed that I'm having this trouble.  Am I doing something Horribly Wrong ™ here?",sgharms,NONE,2014-03-20 18:16:44+00:00,True,2014-03-27 05:03:45+00:00,6.45,,3,6,2014-03-20 18:59:48+00:00,0.03,infews,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
559,Support adding describe() and it() calls at runtime,"This feature request is a follow-up to issues #555 and #412.
It would be nice to support adding describe and it calls after Jasmine is loaded.  This would permit asynchronously loading and running test suites.  (This is necessary, for example, to run CoffeeScript test suites through coffee-script.js.)
I admit that this seems like a pain to implement, but it might be worth considering for future major releases.",SyntaxColoring,NONE,2014-03-21 01:04:52+00:00,True,2014-08-27 16:32:51+00:00,159.64,,5,6,2014-08-15 20:28:44+00:00,147.81,slackersoft,MEMBER,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
561,How Return Object in createSpy() in Jasmine 2,"In Jasmine 1.x, I was able to do this:
FB_mock = {
  value1: ""val1"",
  value2: ""val2""
}
var method = jasmine.createSpy().andReturn(FB_mock);
How can I do the same in Jasmine 2? It looks like andReturn() is gone. Thanks.",demisx,NONE,2014-03-22 18:55:17+00:00,True,2014-03-22 22:05:12+00:00,0.13,,2,2,2014-03-22 19:07:36+00:00,0.01,jaapz,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
562,Documentation for Spies doesn't mention how they are removed.,"I'm pretty sure the spies are automatically removed after the block they are in- either an it or a describe if they are setup in a beforeEach.  But the jasmine docs are silent on the issue- I want to make sure spies I setup in one test don't affect code in another, across both it and describe blocks.",jtfairbank,NONE,2014-03-23 18:11:57+00:00,True,2014-03-27 04:54:44+00:00,3.45,,3,3,2014-03-24 04:04:54+00:00,0.41,infews,CONTRIBUTOR,0,2,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
563,Manually fail a test with fail() method,Is there still a fail() function on the it object in 2.0?,dasois,NONE,2014-03-24 14:03:38+00:00,True,2014-09-24 20:23:37+00:00,184.26,,29,49,2014-03-24 16:41:53+00:00,0.11,infews,CONTRIBUTOR,1,3,0,25,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
564,"""describe""s match name greedily","Given this set of tests:
describe(""on"", function() {
    // Several ""it"" tests
});

describe(""once"", function() {
    // Several ""it"" tests
});

In the HTML test runner, if I click the ""on"" category to narrow my scope it will also run ""once"" tests. This is reproducible with any ""foo"" and ""foo*"" combination.
I'm running Jasmine 2.0 with Jasmine-html loaded via RequireJS.",montlebalm,NONE,2014-03-26 18:04:56+00:00,True,2014-08-28 19:53:43+00:00,155.08,,5,8,2014-03-27 16:31:05+00:00,0.93,infews,CONTRIBUTOR,1,2,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
565,Request:  Collapse groups of successful tests into a single passing symbol (jasmine-html),"Currently, each passing test gets an Unicode character, \u2022, in jasmine-html.js.  I'd like to request that one hundred passing tests be collapsed to a single character as well (say, a bulls-eye, or \u2A00).
It doesn't have to be 100 - I just picked that number out of a hat.
Rationale:  I'm running 1000+ tests and adding more as I go.  The dots are taking up a lot of space...",ajvincent,NONE,2014-03-27 04:51:49+00:00,True,2014-03-27 16:23:39+00:00,0.48,,2,2,2014-03-27 16:23:39+00:00,0.48,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
566,Passing a spec by reference does not seem to work,"The following test works fine:
describe(""My Test Suite"", function(){
    var a;
    beforeEach(function(){
        a = 'Apple';
    });
    describe(""Sub test suite"", function(){
        it(""my async spec"", function(done) {
            setTimeout(function(){
                expect(a).toBe('Apple');
                done();
            }, 400);
        });
    });
});

But when I pass the spec by reference the test fails. Refactoring above code as below does not work -
function foo() {
    it(""my async spec"", function(done) {
        setTimeout(function(){
            expect(a).toBe('Apple');
            done();
        }, 400);
    });
}

describe(""My Test Suite"", function(){
    var a;
    beforeEach(function(){
        a = 'Apple';
    });
    describe(""Sub test suite"", foo);
});

Here is a jsfiddle with these two tests - http://jsfiddle.net/y1426i/ed34q/
Any help with this is much appreciated. Thanks.",yusufnb,NONE,2014-03-27 19:19:03+00:00,True,2014-03-28 03:51:42+00:00,0.36,,2,2,2014-03-27 20:56:34+00:00,0.07,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
567,Allow done() to take an optional error.,"It is a popular pattern to pass an error object to a done() callback in NodeJS.
We should support that in Jasmine 2.0, too so that users can properly unit test asynchronous code.
Example
describe('async with error', function() {

  it('should fail on done(err)', function(done) {

    setTimeout(function() {
      done(new Error('async fail'));
    }, 100);
  });
});

should fail with
error: 'async fail'

instead of succeeding which is the case as of v2.0.0.",nikku,NONE,2014-04-02 16:02:53+00:00,True,2014-10-02 15:16:50+00:00,182.97,,15,24,2014-05-23 22:56:48+00:00,51.29,bilalq,NONE,1,2,0,12,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
569,Support running Jasmine in Nashorn,"I started working on JUnit to JavaScript testing support using Java 8 and Nashorn [1]. I quickly found that Jasmine is not plug-and-play in a stock Nashorn environment. In particular, the use of window and window.onload is problematic and requires a shim.
I'll fork Jasmie itself and do the hacks but it would be nice if there was a way to support Nashorn OOTB without a browser emulator shim because the JS that I'll be testing will never see a browser (ever), so there's no point in making Jasmine think that's where it is.
[1] - https://github.com/reactor/reactor-js",jbrisbin,NONE,2014-04-03 11:33:56+00:00,True,2014-08-28 20:31:31+00:00,147.37,,4,7,2014-04-03 16:47:19+00:00,0.22,infews,CONTRIBUTOR,0,1,0,3,"['bug', 'has Tracker story']",False,False,False,False,False,False,False,False,True,False,False,True,False,False,False
570,Spy documentation errors,"The 2.0 documentation describes several methods on the calls object of a spy. But as far as I can tell, the calls property just contains an array and the methods should be called on the spy object itself.",sjoerdvisscher,NONE,2014-04-03 12:04:37+00:00,True,2014-05-09 15:57:59+00:00,36.16,,3,4,2014-05-08 08:12:10+00:00,34.84,KasMA1990,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
571,Calling expect inside EXTJS Ajax.request callback fails intermittently,"I am trying to write asynchronous test cases as below, which fails intermittently by giving error -
TypeError: Cannot call method 'expect' of null in expect method, where it get currentSpec as null.
My spec sample is as below, pls note that I have 10 service tests in same describe block:
describe(""Services:"", function() {
it(""Notifications"",function(done){
Ext.Ajax.request({
url : '.../notificationsService',
method : 'GET',
callback : function (options, success, response) {
expect(success).toBeTruthy();
done();
},
scope : this
});
});
// Similarly I have 10 services to test in same describe block...
});
Workaround:
I tried one change which made it work consistently is that to move 'currentSpce=null', in the method 'specResultsCallback' before the call to 'removeAllSpies', as below:
function specResultCallback(result) {
j$.Expectation.resetMatchers();
customEqualityTesters = [];
currentSpec = null;
removeAllSpies();
reporter.specDone(result);
}
Please let me know if this fix can be made in the core files so that it resolves permanently.
Thanks,
Sriram",sriram139,NONE,2014-04-03 16:22:02+00:00,True,2014-04-03 16:37:47+00:00,0.01,,2,1,2014-04-03 16:37:47+00:00,0.01,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
572,Asynchronous testing with Jasmine 2 using Coffeescript,"We've been trying to write some tests of async functions using Jasmine 2 but they are not working due to the way Coffeescript wraps its rendered Javascript within closures.
I'm struggling to find a sensible solution for this. Does anyone have any working examples of how one might test async functions with Jasmine 2 using Coffeescript?
Thanks in advance
D",davesag,NONE,2014-04-03 23:51:12+00:00,True,2014-04-04 00:18:52+00:00,0.02,,3,4,2014-04-03 23:59:01+00:00,0.01,infews,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
576,console info statements after jasmine.clock().tick won't show,"describe('a possible bug', function() {
/* global console */
'use strict';
it('jasmine stops logging after a call to jasmine.clock().tick ', function (done) {
var foo = {
bar: function() {
        }
    };

    spyOn(foo, 'bar');

    foo.bar();

    jasmine.clock().install();

    window.setTimeout(function() {
        done();
    }, 10);

    console.info('before ticking the clock');

    jasmine.clock().tick(11);

    console.info('after ticking the clock');

    expect(foo.bar).toHaveBeenCalled();

    jasmine.clock().uninstall();
});

});",ingoe,NONE,2014-04-15 19:55:26+00:00,True,2014-04-15 20:31:39+00:00,0.03,,2,2,2014-04-15 19:57:00+00:00,0.0,ingoe,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
577,Stop testcase execution on failure in beforeEach,"I think it would be very useful to stop execution of a testcase if the beforeEach fails (i.e. throws an exception or similar).
Example: precondition is used for login -> if the login does not succeed, it does not make any sense to run the actual test.
I already tried to expect() something in the beforeEach (or in a function that it calls, to be more exact), and throwing an exception. The first did not work at all for my purposes (as other steps in the beforeEach were still executed), the 2nd at least registers as an error but the execution still continues.
Or maybe something like an option to stop executing the testcase as soon as one expectation fails could work, but I didn't find any such option.",FrankyBoy,NONE,2014-04-18 09:28:39+00:00,True,2017-06-19 20:49:31+00:00,1158.47,,13,20,2014-04-29 16:27:56+00:00,11.29,otomi,NONE,1,2,0,9,"['feature request', 'has Tracker story', 'ready for work']",False,True,False,False,False,False,False,False,True,True,False,False,False,False,False
578,Description String of failing test are incorrect.,"When running my test via karma runner, I get the following output for a failed test description:
Firefox 28.0.0 (Ubuntu) [object Object] [object Object] [object Object]
[object Object] [object Object] [object Object] [object Object] [object Object]
[object Object] [object Object] [object Object] [object Object] [object Object]
[object Object] [object Object] [object Object] [object Object] [object Object]
[object Object] [object Object] [object Object] [object Object] [object Object]
[object Object] [object Object] [object Object] [object Object] [object Object]
[object Object] [object Object] [object Object] [object Object] [object Object]
[object Object] [object Object] should wipe out empty names on close FAILED

According to my hierarchy of describes in my jasmine test, the description of the test should be:
dispPermListsCtrl close test should wipe out empty names on close FAILED

I have so far noticed this on all other failing test as well.
I am running Jasmine 2.0.0 on Karma Version 10.2, npm 1.4.3, node 0.10.26.
Here is a spit out of the jasmine test of interest:
describe(""dispPermListsCtrl"", function() {
  var scope;
  var list = [];
  var title = ""TEST TILE"";
  var roleName = ""Role"";
  beforeEach(module('adminPortal'));
  beforeEach(inject(function($rootScope, $controller) {
    scope = $rootScope.$new();

    controller = $controller(""dispPermListsCtrl"", {
      $scope : scope,
      $modalInstance : modalInstanceMock,
      list : list,
      title : title,
      roleName : roleName
    });
  }));
  describe(""close test"", function() {
    beforeEach(function() {
      spyOn(modalInstanceMock, 'close');
    });

    it(""should wipe out empty names on close"", function() {
      scope.list.push({itemInfo :{}, create:false, read:false, update:false, delete:false});
      scope.close();
      expect(modalInstanceMock.close).toHaveBeenCalledWith([]);
    });

    it(""should call modalInstance close"", function() {
      scope.close();
      expect(modalInstanceMock.close).toHaveBeenCalledWith(list);
    });
  });
});",CorbynS,NONE,2014-04-21 16:15:59+00:00,True,2014-08-18 20:03:45+00:00,119.16,,3,2,2014-06-23 03:48:04+00:00,62.48,infews,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
579,-0 should equal 0,"I've written a unit test for a function were I expect my returned value to be rounded to 0 (example -0.4 should return 0). I've written my unit test as expect(result).toEqual(0) and it is failing.
When attempting to debug I eventually found out that it was failing because it thought that -0 did not equal 0. It did however pass when using expect(result).toBe(0), however I should still be able to use expect(-0).toEqual(0).",jonatr35,NONE,2014-04-21 18:50:46+00:00,True,2014-11-03 21:15:35+00:00,196.1,,6,7,2014-04-24 03:06:32+00:00,2.34,sheelc,CONTRIBUTOR,1,2,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
581,resolving promise returned from a factory in jasmine,"Hi,
I have designed a factory that contains a method that makes an asynchronous using $http.
I am trying to access promise values returned from factory in jasmine.
I want the returned promise value to be resolve in jasmine.
I need a simple example that would solve this issue
Please help me resolve the issue
The following is the piece of factory code
var app=angular.module('chartApp');
app.controller('chartCtrl', [
'$scope',
'$http',
'scatterplot',
    function($scope, $http, scatterplot) {

        $http({
    method: 'GET',
    url: 'RNASequenceDataServlet',
         headers: { 'Content-Type': 'application/json' },

  })
  .success(function (data, status, headers, config) {


        deferred.resolve(configu);

}
return (deferred.promise);
});
});
Please help me wrtitng a test case with proper syntax that will help me resolve this issue",jitendrasbhati,NONE,2014-04-28 10:40:35+00:00,True,2014-08-25 20:29:09+00:00,119.41,,3,1,2014-06-23 03:49:52+00:00,55.71,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
582,accessing the applications data in jasmine,"Hi,
I have designed a web application in which I first send a request to the server to load the data.After the data is returned I process the data and then display the results on the web page.I am using angularjs t o design this application.I am trying to test this application using jasmine.I want to cross verify the values returned from the server.Is there any way in which I can test the data returned from the server using jasmine.I am using $http request to make an asynchronous call to the server.Please help me with an example to solve this problem",jitendrasbhati,NONE,2014-04-29 02:47:10+00:00,True,2014-04-29 13:30:28+00:00,0.45,,3,2,2014-04-29 13:30:28+00:00,0.45,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
583,Execute specs in random order,"Hi. Is it possible to force specs execute in random order, similar to RSpec? That would help to detect interdependencies between the specs early.
Thanks.",demisx,NONE,2014-04-29 17:07:41+00:00,True,2014-08-27 16:53:08+00:00,119.99,,5,7,2014-08-27 16:53:08+00:00,119.99,infews,CONTRIBUTOR,1,2,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
584,[ ] toEqual { } returns true,I have  var foo = { categories: [ ] } and when I call expect(foo.categories).toEqual({ }); the spec pass. Why?,passalini,NONE,2014-05-01 21:08:10+00:00,True,2014-05-05 11:47:58+00:00,3.61,,3,3,2014-05-01 22:01:04+00:00,0.04,joshuacc,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
586,HtmlUnit and Jasmine 2.0,"I've tried upgrading some HtmlUnit tests from Jasmine 1.3.1 to 2.0 and found some issues. As it runs fine in the browser I've logged the issue here, but am just making you aware of it. Cheers.",tntim96,NONE,2014-05-04 02:38:43+00:00,True,2014-05-13 09:57:51+00:00,9.3,,2,3,2014-05-06 10:21:44+00:00,2.32,alextreppass,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
589,Spies don't propagate down test suites,"Example here:
http://plnkr.co/edit/UAJ6G8aupKO3ldlw5ONS?p=preview
I presumed that the spy would be available at inner suites, but that doesn't seem to be the case.
Is this intended?",chreekat,NONE,2014-05-09 18:09:26+00:00,True,2014-05-09 23:35:04+00:00,0.23,,2,2,2014-05-09 23:35:04+00:00,0.23,ragaskar,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
590,IE6/7 support,"Hi, do you support internet explorer 6 and 7?
I use jasmine 2.0.0 with https://github.com/gruntjs/grunt-contrib-jasmine. When I open SpecRunner.html in those IE, I get error ""Object doesn't support this property or method on line 129"". Line 129 refers to this code https://github.com/pivotal/jasmine/blob/00c8e372576438243a8f977b8bc7b81f04389dd6/lib/jasmine-core/boot.js#L150 in my setup.
If I replace calls of createElement() and createTextNode() in those lines to direct call (without apply, just normal function call), then IE shows another error in line 250 (i don't remember exact line, but near 250). There is no such line in boot.js, and IE don't says in which file ...
So, I just wondering, do you support IE6/7 and there is probably some issue in my setup, or you don't support it?",rpominov,NONE,2014-05-11 20:46:41+00:00,True,2014-05-11 20:58:24+00:00,0.01,,5,6,2014-05-11 20:48:36+00:00,0.0,sheelc,CONTRIBUTOR,1,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
591,Provide a way to clear/reset reporters,"Building a jasmine runner that runs within a single page app, and without refreshing the page, the jasmine reporters never clean themselves out. Subsequent test runs compound the results of previous test runs. It'd be nice if reporters were either self-cleansing or provided a simple way to reset the reporters.",plukevdh,CONTRIBUTOR,2014-05-12 22:03:00+00:00,True,2014-06-07 06:00:23+00:00,25.33,,3,3,2014-05-23 16:25:46+00:00,10.77,infews,CONTRIBUTOR,0,3,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
592,how to use toEqual to skip undefined?,"expect({key1:'value1', key2:undefined}).toEqual({key1:'value1'})",atian25,NONE,2014-05-15 10:45:58+00:00,True,2014-05-17 01:33:10+00:00,1.62,,4,4,2014-05-17 01:33:05+00:00,1.62,atian25,NONE,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
593,Structured JsApiReporter with specs inside suites,"Currently the reporter gives a flat list of all specs and a flat list of all suites, but they're not linked in any way (other than an inherited title).
Would you consider building a tree of suites and tests as they pass / fail. So a driver could use the reporter to build an accurate representation of the suites?",linssen,NONE,2014-05-16 10:50:20+00:00,True,2014-12-16 21:27:27+00:00,214.44,,3,5,2014-06-23 03:54:43+00:00,37.71,infews,CONTRIBUTOR,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
595,Were are the sources for the documentation pages located?,"In the custom_matcher documentation 'actual' is misspelled as 'acutal'.
I wanted to create a pull request for this minor improvement, but I was unable to find the documentation in the repository. So I have the following questions:

Where are the sources for the documentation pages located?",dvberkel,NONE,2014-05-25 14:42:42+00:00,True,2014-06-01 22:54:04+00:00,7.34,,2,1,2014-05-25 19:19:25+00:00,0.19,sheelc,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
596,API reference missing?,"Hi guys,
I have been using Jasmine for some time, but I still don't know everything about it. There are still some things that I need to check before writing my tests. While ""Introduction"" page is great for understanding all the basics it's not helping if you want to find something quickly (I know how to use Ctrl + F, but it is not the best solution). I would really appreciate API reference page so I can quickly find what I'm looking for instead of going through ""Introduction"" page or googling it.
Thanks!",op1ekun,NONE,2014-05-26 10:45:07+00:00,True,2017-03-24 00:00:12+00:00,1032.55,,11,12,2014-05-29 12:43:03+00:00,3.08,otomi,NONE,1,2,0,8,['docs'],False,False,False,False,False,False,False,True,False,False,False,False,False,False,False
597,Jasmine's CSS affecting body tag,"in jasmine's CSS file there's some code which affects the body, this interferes with the style of the page your testing. Jasmines CSS should only effect Jasmines elements i think.",lee101,CONTRIBUTOR,2014-05-30 04:06:53+00:00,True,2014-06-03 06:07:10+00:00,4.08,,1,1,2014-06-03 06:07:01+00:00,4.08,lee101,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
598,.toEqual fails for objects with the same members but of different types,"it(""should tell me what's the difference between these 2"", function () {
  function A() { this.a = 10; }
  function B() { this.a = 10; }
  expect(new A()).toEqual(new B());
});

fails, but it does not say why - it only states: Expected { a : 10 } to equal { a : 10 }. which is instead true.",adrianton3,NONE,2014-05-31 20:33:53+00:00,True,2014-12-16 20:57:30+00:00,199.02,,11,17,2014-06-02 17:00:39+00:00,1.85,infews,CONTRIBUTOR,1,1,0,9,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
599,License of the logo,"Which license is the logo of this project applied to?
I'd like to use it for the documentation of the Node module which supports Jasmine.",shinnn,NONE,2014-06-02 06:21:08+00:00,True,2014-06-02 16:37:56+00:00,0.43,,2,2,2014-06-02 16:37:56+00:00,0.43,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
601,Feature request: Add ability to run just one test by prefixing it with a letter,"In a similar way to how music software has both a mute and a solo button for each track of a recording, it'd be nice if Jasmine had a 'solo' equivalent to each of its xit and xdescribe methods. So e.g. a single (or multiple) calls of zit() will mean all calls of it() are ignored and only zit() calls will run",wheresrhys,NONE,2014-06-03 09:47:33+00:00,True,2014-09-25 19:52:47+00:00,114.42,,4,4,2014-06-04 04:41:20+00:00,0.79,driv,NONE,1,0,0,3,"['duplicate', 'feature request']",False,True,False,False,False,False,False,False,False,False,True,False,False,False,False
602,Improve how matchers/API deal with a timeout aka don't blow up.,"When executing matchers after a timeout you get this nasty and misleading error:
""TypeError: Cannot read property 'expect' of null
    at Env.expect (http://cdnjs.cloudflare.com/ajax/libs/jasmine/2.0.0/jasmine.js:698:25)
    at jasmineInterface.expect (http://cdnjs.cloudflare.com/ajax/libs/jasmine/2.0.0/boot.js:61:18)
    at StreamClient.<anonymous> (http://localhost:8080/js/StreamClientTest.js:220:36)
    at ...

I just spent a long time reorganizing an async-heavy test in dozens of various ways, because I thought that the flow of my test triggered a bug in Jasmine or that I misunderstood the API. After a while I realized that it was really a too conservative timeout - sigh...
Yes the UI is clear about the timeout, but while developing async tests I hit the timeout so often that I tend to ignore that and look in the console for a trace of what failed.
May I suggest that in this situation Jasmine ignores any matcher calls instead of blowing up?",jayv,NONE,2014-06-04 04:28:49+00:00,True,2014-06-07 06:51:16+00:00,3.1,,2,1,2014-06-07 06:53:48+00:00,3.1,sheelc,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
603,Downloading the standalone distribution is pretty unintuitive,"I've only found two ways to do it:

git clone the jasmine repo, take the zip file out
Use the 'Downloads' button to download the jasmine repo, unzip, take the zip file out.

I'd honestly expect something less onerous, like ... Click and download.",Trevoke,NONE,2014-06-05 21:11:20+00:00,True,2014-06-06 13:55:34+00:00,0.7,,3,5,2014-06-05 22:41:57+00:00,0.06,infews,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
604,jasmine's equals doesn't interact well with angular.copy,"I could go either way on this issue because using custom equals is an easy workaround. However, I did notice that after an upgrade to jasmine 2.0
expect(a).toEqual(angular.copy(a))
no longer passes.",bradyoo,NONE,2014-06-05 23:34:04+00:00,True,2014-06-23 04:08:07+00:00,17.19,,2,1,2014-06-23 04:07:59+00:00,17.19,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
605,Reporter listens for `onRaiseExceptionsClick` on a non-jasmine element,"Hi, maybe this is somewhere duplicated, I've tried to search but found nothing relevant.
I discovered an tricky issue - I composed a test, that contains jasmine boot and a custom container to which i append elements and then I write test's for their presence and functionlity.
Obsuce is, that jasmine-boot appends a click listener to the first input I paste to my $('#custom-test-container') element.
here is an output from chrome -> devel tools -> elements -> event listeners -> click
handler: function () { queryString.setParam(""catch"", !env.catchingExceptions()); }
isAttribute: true
lineNumber: 126
listenerBody: ""function () { queryString.setParam(""catch"", !env.catchingExceptions()); }""
node: input.seq-loopsection-input
sourceName: ""http://localhost:7357/testem/jasmine2-boot.js""
type: ""click""
useCapture: false
I also need to mention, that I've been using it with testem, so I don't know if this could be caused by testem, but more important is the logic that appends the _onRaiseExceptionsClick_ handler to DOM.",vire,NONE,2014-06-06 08:10:16+00:00,True,2014-06-07 19:18:57+00:00,1.46,,2,3,2014-06-07 05:24:49+00:00,0.89,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
606,"toEqual behave differently with DOM elements in PhantomJS, Chrome and Firefox","There is a simple spec to reproduce the bug.
describe(""Compare of DOM elements"", function() {
    var d1 = document.createElement(""div"");
    d1.appendChild(document.createTextNode(1));
    var d2 = document.createElement(""div"");
    d2.appendChild(document.createTextNode(2));

    var d3 = document.createElement(""div"");
    var d4 = document.createElement(""div"");

    it(""should pass in Chrome and PhantomJS, fail in Firefox"", function() {
        expect(d1).not.toEqual(d2);
        expect([d1, d2]).not.toEqual([d2, d1]);
        expect([d1, d2]).toEqual([d1, d2]);
    });
    it(""should pass in PhantomJS, fail in Chrome and Firefox"", function() {
        expect(d3).not.toEqual(d4);
        expect([d3, d4]).not.toEqual([d4, d3]);
        expect([d3, d4]).toEqual([d3, d4]);
    });
});

I've tested this in PhantomJS 1.9, Firefox 29, Chrome 35 under Windows 7 x64. I use Jasmine from grunt-contrib-jasmine 0.6.5",alexeibs,CONTRIBUTOR,2014-06-06 09:28:08+00:00,True,2014-12-16 19:26:58+00:00,193.42,,3,6,2014-06-23 04:05:38+00:00,16.78,infews,CONTRIBUTOR,1,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
607,not abel to match two string path,"Hi,
I was not able to compare two string given below.
var expPath =""C:\Program Files (x86)\Application Designer\dev"";
var actualPath =""C:\Program Files (x86)\Application Designer\dev"";
expect(expPath).toMatch(actualPath)
the above test case if failing.
Regards
Ashish.",2007ay,NONE,2014-06-06 11:55:35+00:00,True,2014-06-09 11:46:43+00:00,2.99,,2,2,2014-06-07 05:10:09+00:00,0.72,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
608,`npm install jasmine-core` installs different contents for same version,"Installing jasmine-core through npm on a Mac OSX and Ubuntu 13.10 (on a virtual machine) yields different contents for version 2.0.0.
The Mac OSX version seems to have the more recent contents including line https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/jasmine.js#L1206 whereas the Ubuntu installation does not.
As a result the code I am looking at fails on Ubuntu but works on Mac OSX.
I am trying to debug this issue further, but so far am stuck with npm repeatedly installing the same specific content, even after clearing the caches.",cburgmer,NONE,2014-06-12 21:38:57+00:00,True,2014-09-03 20:58:43+00:00,82.97,,4,6,2014-06-23 04:01:53+00:00,10.27,infews,CONTRIBUTOR,1,1,0,2,"['bug', 'waiting']",True,False,False,False,False,False,False,False,False,False,False,True,False,False,False
609,How can I get the specified tests?,"Say I have two spec suites: OneSpec.js and TwoSpec.js, and in the html I added:
<script type=""text/javascript"" src=""js/spec/OneSpec.js""></script>
<script type=""text/javascript"" src=""js/spec/TwoSpec.js""></script>
I know that jasmine.getEnv() can get all tests of OneSpec.js and TwoSpec.js.
The problem is sometimes I just want to get tests of OneSpec.js or TwoSpec.js.
Is that possible?",AnnieCyl,NONE,2014-06-13 09:18:49+00:00,True,2014-06-18 07:55:02+00:00,4.94,,2,4,2014-06-13 15:22:38+00:00,0.25,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
610,provide a way to test custom matchers when they don't pass,"On the http://jasmine.github.io/2.0/custom_matcher.html page there are 3 tests that show how to test custom matcher but they only show how to test it passes.
Is there a way to test how it fails? I have some matchers that throw different messages when they fail and I'd like to test them.
What I think I can do is to test the compare function alone and then only test the if the matcher passes as shown on http://jasmine.github.io/2.0/custom_matcher.html
This is not what I find the most accurate though.
There should be a way to test custom matchers provided or if there's one already - it should be shown how to test matcher message when it fails.",jrencz,NONE,2014-06-13 14:48:45+00:00,True,2014-06-13 15:26:44+00:00,0.03,,2,2,2014-06-13 15:26:44+00:00,0.03,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
611,Get currently executed test name in beforeEach,"TLDR; Is there a way to get the currently executed test case (its description derived from describe / it) in a beforeEach block?
What for?
Assuming I have a test runner that performs some sort of visual job on the screen (e.g. drawing SVG elements).
I provide each test case with a container to draw on and want the result to be inspectable by a user. In addition, I would like to add a caption to each of the tests, so that the user can easier keep track of which drawing result belongs to which test execution.",nikku,NONE,2014-06-16 13:16:28+00:00,True,2014-06-18 05:44:12+00:00,1.69,,27,37,2014-06-17 16:43:16+00:00,1.14,stoeffel,NONE,1,1,0,25,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
612,Mocking the JavaScript Timeout Functions in IE 8 with Jasmine 2.0.0,"Hi
I can't get the following test to work in IE 8.
describe('Time mock in IE 8', function() {
    beforeEach(function() {
        jasmine.clock().install();
    });

    afterEach(function() {
        jasmine.clock().uninstall();
    });

    it('calls test after timeout', function() {
        var test = jasmine.createSpy('timeout');
        setTimeout(test, 1000);
        jasmine.clock().tick(1000);
        expect(test).toHaveBeenCalled();
    });
});

I checked what Sinon does and found this http://sinonjs.org/releases/sinon-ie-1.10.2.js
So I tested by adding this to my SpecHelper.js
var origSetTimeout = setTimeout;
function setTimeout() {}
setTimeout = origSetTimeout;

After that the spec runs correctly.",Wraul,NONE,2014-06-17 12:22:03+00:00,True,2014-07-25 07:36:45+00:00,37.8,,3,4,2014-06-23 04:00:41+00:00,5.65,infews,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
613,Asynchronous tests run twice in standalone,"When running the standalone version of jasmine tests (asynchronous) run twice. The log looks something like this:
TestA starts
TestA done asynchronously
TestB starts
TestB done asynchronously
TestA starts
TestA done asynchronously
TestB starts
TestB done asynchronously
TestC starts
TestC done asynchronously

As far as I can see the tests/jasmine are not loaded twice.
It might be important to note, that I'm running the jasmine standalone version inside a Cordova application on an iOS device. I initialize the tests like the following, since I need to wait for cordova to finish loading:
var loadScript = function(src) {
  var el = document.createElement('script')
  el.setAttribute('src', src);
  el.async = false;
  document.body.appendChild(el);
};

var loadTests = function() {
  [
    'lib/jasmine-2.0.0/boot.js',
    'spec/myTest.js',
  ].forEach(loadScript);

  // timeout and window.onload needed to start tests
  setTimeout(function() {
    window.onload();
  }, 1000);
};

document.addEventListener('deviceready', loadTests, false);",schickling,NONE,2014-06-18 10:54:48+00:00,True,2014-12-16 23:52:33+00:00,181.54,,8,11,2014-06-23 03:58:30+00:00,4.71,infews,CONTRIBUTOR,1,1,0,6,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
614,How to test events?,"I know that jasmine-jquery offers spyOnEvent to spy on  jQuery events.
But I don't use jQuery, how can I test my events via jasmine?",AnnieCyl,NONE,2014-06-19 08:00:16+00:00,True,2014-08-14 04:42:26+00:00,55.86,,3,2,2014-06-23 03:52:28+00:00,3.83,infews,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
615,"Don't run tests, that don't have actual test body","If I have a test it(), but there is no actual test body expect(), then seems pointless to show, that test is okay.
Maybe exclude at runtime?",jeserkin,NONE,2014-06-25 09:12:55+00:00,True,2014-06-26 15:36:46+00:00,1.27,,3,9,2014-06-25 20:24:08+00:00,0.47,infews,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
617,Events getting too widely attached?,"The problem is best illustrated through this Plunker. Clicking on the form field seems to reload the page. It's not an Angular issue, as it goes away entirely when I remove the Jasmine bootstrap file.
I think it is related to this line in boot.js: onRaiseExceptionsClick: function() { queryString.setParam(""catch"", !env.catchingExceptions()); }
If I remove that, I can click on the form field, but I still get event trouble with the button.",selfinterest,NONE,2014-06-28 04:48:03+00:00,True,2014-12-16 23:51:05+00:00,171.79,,3,4,2014-06-28 04:54:11+00:00,0.0,sheelc,CONTRIBUTOR,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
618,Can a spy tell me what the 'this' object was each time it was called.,"It would be really useful if a spy could keep track of the this object it had when it was called. I am currently writing tests for several functions for functions. compose, throttle etc. To check context I have to use my own implementation of a spy.",CrowdHailer,NONE,2014-06-28 16:49:42+00:00,True,2014-06-30 16:54:36+00:00,2.0,,3,2,2014-06-28 17:11:50+00:00,0.02,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
619,Can't find banner,"Some times I got this error:

and I have added these in <head>:

But the banner is null.
When I inspected my html, I found that there was no <div class=""html-reporter"">...</div> in <body>. So find('.banner') returned null.
How it happened?",AnnieCyl,NONE,2014-07-03 01:57:13+00:00,True,2014-07-03 05:40:58+00:00,0.16,,2,3,2014-07-03 04:44:27+00:00,0.12,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
620,Including installation instructions in documentation,"Including installation instructions in the documentation would be helpful to new users not familiar with how to set up Jasmine.
Stack question re this issue:
http://stackoverflow.com/questions/23648821/installation-of-jasmine-for-automated-testing",bengrunfeld,CONTRIBUTOR,2014-07-07 15:03:39+00:00,True,2014-07-08 04:26:59+00:00,0.56,,2,1,2014-07-08 04:26:59+00:00,0.56,sheelc,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
622,toHaveBeenCalled() doesn't take comment message,"expect(spy).toHaveBeenCalled('have been called!') – doesn't work
expect(spy.calls.any()).toBe(true, 'have been called!') – works",Yeti-or,NONE,2014-07-09 15:18:30+00:00,True,2014-08-20 19:57:21+00:00,42.19,,2,1,2014-07-09 20:26:15+00:00,0.21,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
623,ReferenceError: Can't find variable: require,"I've been trying to get a basic jasmine project working that tests a JavaScript library I'm working on. The library will run in either the browser or in Node.js. Unfortunately, I've been unable to use Jasmine. I keep getting an error that says 'ReferenceError: Can't find variable : require'
I have a stripped down project that demonstrates the problem. That code can be found here.
I'm opening an issue as I only have it as soon as I reference my jasmine task.",paranoid-android,NONE,2014-07-11 11:16:06+00:00,True,2014-10-08 20:18:08+00:00,89.38,,2,2,2014-08-26 20:30:00+00:00,46.38,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
625,How to test KnockoutJS sample with HTML data-bind on Jasmine,"How can we test KnockoutJS sample with HTML data-bind on Jasmine test spec.
Can somebody throw some idea on this as it is very useful for me on my current project as we are using Jasmine test framework to test KnockoutTJS source code.
Please provide some example if you have any.",bcoreddy,NONE,2014-07-16 09:59:30+00:00,True,2014-07-16 13:37:18+00:00,0.15,,2,1,2014-07-16 13:37:18+00:00,0.15,ragaskar,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
626,Add expected assertion count,"Especially with async tests it's very useful to be able to check if assertion count at the end of the spec matches what was actually checked. This would also allow to catch mistakes like:
expect(some-long-expression);
(which I've experienced yesterday).
An API could look like:
it('a test', function () {
  this.expect(2);
  expect(true).toBe(true);
  // error: two assertions expected
});
or like that:
it('a test', function (2[, done]) {
  expect(true).toBe(true);
  // error: two assertions expected
});",mgol,NONE,2014-07-17 08:09:01+00:00,True,2014-08-27 16:50:42+00:00,41.36,,9,9,2014-08-27 16:50:42+00:00,41.36,infews,CONTRIBUTOR,1,2,0,5,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
627,expect(blah).toContain(x) gives poor error messages if blah is undefined or null,"Hi,
I'm on 2.0.0 and it gives the following message:
TypeError: haystack is undefined in http://localhost:8100/Tests/Jasmine/lib/jasmine-2.0.0/jasmine.js (line 1759).
Applying this patch (in contains in the matchersUtil in jasmine.js):
@@ -1756,6 +1756,11 @@
         }
         return false;
       }
+
+      //note this is a patch!  library's normal behaviour is to throw an exception
+      if(haystack === undefined || haystack === null)
+          return false;
+
       return haystack.indexOf(needle) >= 0;
     },

produces more sensible output:
Expected undefined to contain '7'.
I know I could probably submit this as a pull request but I dont really know how to use git.
Cheers",JonnyRa,NONE,2014-07-17 11:35:33+00:00,True,2014-07-18 20:19:33+00:00,1.36,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
629,Dynamically update spec description,"I'm using jasmine 2.0 to do integration tests with a REST API. I'd like to add some information that is created dynamically to the output report to aid debugging when tests fail. Is it possible to do something like this?
For example:
describe('My Test', function () {
    var model = new MyModel();
    beforeEach(function (done) {
        // Creates a new model in the service
        model.save().done(done); 
    });
    it('should have properties', function () {
        // Update spec name to have dynamically created ID
        this.name = this.name + ' (ID: ' + model.get('id') + ')'; 
        expect(model.get('prop')).toBe('val');
    });
});


Output (1234 as the model ID from the service)
My Test
- should have properties (ID: 1234)",robrichard,NONE,2014-07-18 09:31:56+00:00,True,2014-09-03 20:05:04+00:00,47.44,,2,2,2014-07-18 13:07:30+00:00,0.15,robrichard,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
631,grammar error in http://jasmine.github.io/2.0/introduction.html,"By default jasmine will wait for 5 seconds for an asynchronous spec to finish before causing at timeout failure. If specific specs should fail faster or need more time this can be adjusted by setting jasmine.DEFAULT_TIMEOUT_INTERVAL around them.
possible meaning:
By default jasmine will wait for 5 seconds for an asynchronous spec to finish before causing a timeout failure. If specific specs should fail faster or need more time this can be adjusted by setting jasmine.DEFAULT_TIMEOUT_INTERVAL around them.",aishelm,NONE,2014-07-20 14:08:24+00:00,True,2014-07-23 20:12:21+00:00,3.25,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
634,Boot.js throws an error (no html function),"I must be missing something.
Here is the simplest jasmine thing possible
<!DOCTYPE html>
<html>
<head>
  <link rel=""stylesheet""  href=""//cdnjs.cloudflare.com/ajax/libs/jasmine/2.0.0/jasmine.css"" />
</script>
<script src=""//cdnjs.cloudflare.com/ajax/libs/jasmine/2.0.0/jasmine.js""></script>
<script src=""//cdnjs.cloudflare.com/ajax/libs/jasmine/2.0.0/boot.js""></script>
  <meta charset=""utf-8"">
  <title>Jasmine bootjs error</title>
</head>
<body>

</body>
</html>

You get a script error since boot.js calls jasmineRequire.html(jasmine) but jasmineRequire has no such method!",togakangaroo,NONE,2014-07-21 14:43:37+00:00,True,2014-07-21 15:21:39+00:00,0.03,,2,5,2014-07-21 14:55:20+00:00,0.01,sheelc,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
635,Issue in jasmine-ajax installation,"npm WARN git config --get remote.origin.url returned wrong result (git://github.com/pivotal/jasmine-ajax)
npm ERR! git clone git://github.com/pivotal/jasmine-ajax Cloning into bare repository 'C:\Users\le\AppData\Roaming\npm-cache_git-remotes\git-github-com-pivotal-jasmine-ajax-8282d883'...
npm ERR! git clone git://github.com/pivotal/jasmine-ajax fatal: unable to connect to github.com:
npm ERR! git clone git://github.com/pivotal/jasmine-ajax github.com[0: 192.30.252.130]: errno=No error
npm ERR! Error: Command failed: Cloning into bare repository 'C:\Users\le\AppData\Roaming\npm-cache_git-remotes\git-github-com-pivotal-jasmine-ajax-8282d883'...
npm ERR! fatal: unable to connect to github.com:
npm ERR! github.com[0: 192.30.252.130]: errno=No error
npm ERR!
npm ERR!
npm ERR!     at ChildProcess.exithandler (child_process.js:647:15)
npm ERR!     at ChildProcess.emit (events.js:98:17)
npm ERR!     at maybeClose (child_process.js:755:16)
npm ERR!     at Process.ChildProcess._handle.onexit (child_process.js:822:5)
npm ERR! If you need help, you may report this entire log,
npm ERR! including the npm and node versions, at:
npm ERR!     http://github.com/npm/npm/issues
npm ERR! System Windows_NT 6.1.7601
npm ERR! command ""d:\Tools\Nodejs\node.exe"" ""d:\Tools\Nodejs\node_modules\npm\bin\npm-cli.js"" ""install"" ""karma-jasmine-ajax""
npm ERR! cwd d:\workspace\token_js
npm ERR! node -v v0.10.29
npm ERR! npm -v 1.4.14
npm ERR! code 128",duleitony,NONE,2014-07-22 06:45:49+00:00,True,2014-07-29 18:03:09+00:00,7.47,,2,2,2014-07-23 20:02:55+00:00,1.55,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
636,Karma / Jasmine 1.x / 2.0 / ExtJS 4. Async Issues,"I've run across some issues when dealing with ExtJS 4.x using either Jasmine 1.3.1/1.5 or 2.0 version with Karma.  I've written some code and demo on GitHub which solves the problem in terms of being able to implement working tests, but I'm wondering if there isn't some bug fixes which could be done to actually deal with the issues moving forward. For one thing, according of the Sencha/ExtJS folks, there won't be any PromisesAPI for the near future with ExtJS 5.0, so the done() method won't work when testing Ext.Store/Ext.Model.  Anyways, you can look at my code on GitHub and let me know your thoughts and comments.  https://github.com/cgauthier/karma_jasmine_2_extjs4 for Jasmine 2.0 and https://github.com/cgauthier/karma_jasmine_1_extjs4 for Jasmine 1.x",cgauthier,NONE,2014-07-22 16:44:43+00:00,True,2014-07-23 20:52:49+00:00,1.17,,3,6,2014-07-22 20:19:49+00:00,0.15,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
637,Nested objectContaining doesn't work,"Here is a minimal test case that is failing on karma 0.12.17, which is using karma-jasmine 0.2.2.
it('can nest objectContaining', function() {
    expect(
        {
            foo: {
                bar: 'baz',
                other: 1
            }
        }
    )
    .toEqual(
        jasmine.objectContaining({
            foo: jasmine.objectContaining({
                bar: 'baz'
            })
        })
    );
});",lkogler,NONE,2014-07-25 17:54:57+00:00,True,2014-08-20 23:24:24+00:00,26.23,,2,1,2014-07-25 19:53:18+00:00,0.08,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
638,Jasmine Swallows Error Message when throwing own Exception,"Doing something like this in the code that's going to be tested (or in an it):
var MyError = function (message) {
  this.message = message
}
MyError.prototype = new Error('foo')
var myerror = new MyError('bar')
console.log(myerror instanceof Error)
console.log(myerror.message)
throw myerror
Jasmine will report this:

You see that jasmine seems to report the prototypes message. Not the one from myerror. Is this me misunderstanding prototypes or is this actually some kind of error in jasmine?",despairblue,NONE,2014-07-27 21:39:34+00:00,True,2014-07-28 10:38:06+00:00,0.54,,2,3,2014-07-27 21:55:27+00:00,0.01,despairblue,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
639,How to mock functions to send html objects,"Hi,
I want to use jasmine is test d3. However, I need to mock the d3 functions, in order to do that I need to return HTML objects like a , so I could do stuff like attach SVGs to it.
Thanks.",AlaRuba,NONE,2014-07-29 06:38:15+00:00,True,2014-07-30 20:10:45+00:00,1.56,,2,1,2014-07-30 20:10:45+00:00,1.56,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
640,severe performance degradation with jasmine runner in phantomjs,"This is related to the issue we filed in the jasmine-gem: jasmine/jasmine-gem#225
When upgrading to Rails 4.1, @ohrite and I bumped jasmine, and found that our tests took an increasingly long time to run, measured in minutes (before it was in seconds). This only seems to occur running under phantomjs, its fine in the browser.  After watching Activity Monitor, we determined that phantomjs leaks memory and starts thrashing after a few dozen examples.
We isolated the problem being introduced as part of this commit:
5f34be4
Before this commit everything is fine. Hope this helps!",rdy,NONE,2014-07-29 22:27:22+00:00,True,2014-11-22 23:03:37+00:00,116.03,,7,12,2014-07-30 13:45:59+00:00,0.64,ragaskar,CONTRIBUTOR,0,4,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
641,Adding because descriptions to expect failures,"In the past and elsewhere there has been discussion of adding .because property to expect chain for clearer failure classification. The proposed syntax was:
expect(true).toEqual(false).because('yes it is')

Is there a possibility that this feature could be introduced, a reason it has not been introduced and has the team ever estimated how much work the feature would be to implement? In select cases this could greatly improve the speed of resolving causes for breaks, especially if you're trying to find the cause of failures from a CI log etc.",aleksihakli,NONE,2014-07-30 07:49:38+00:00,True,2014-09-07 04:10:46+00:00,38.85,,36,57,2014-07-30 08:30:53+00:00,0.03,rabbitjar,NONE,1,1,0,34,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
642,Get variable value from spec in reporter,"I have created a jasmine reporter but unable to figure out how do I pass some variable values from spec to reporter.
For ex: show some data/form-fields in report.
MyReporter.prototype.reportSpecResults =
    function reportSpecResults(spec) {
        //how to get some value here from spec?
}

I have tried to lookup the spec object, but it doesnt seem to contain the information I need. is there a way to accomplish this?",vikramsoni2,NONE,2014-07-30 09:32:24+00:00,True,2014-08-05 22:41:39+00:00,6.55,,2,2,2014-08-05 20:20:10+00:00,6.45,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
644,grouping related specs with describe - merge multiple files,"Hi,
I was hoping for multiple calls to the describe with the same string would make the tests appear under the same heading.
File2.js:
    describe('Load', ...);
File2.js:
    describe('Load', ...);
There will be two separate headings for 'Load'.
Thanks,",mbana,NONE,2014-08-01 12:53:01+00:00,True,2014-08-18 20:35:04+00:00,17.32,,2,1,2014-08-18 20:35:04+00:00,17.32,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
645,JsHamcrest need support for better assertion,Hi had this hope of seeing better assertion mechanism similar to Hamcrest assertion done for Java. It seems JsHamcrest does provide that.,braghome,NONE,2014-08-02 22:26:40+00:00,True,2014-08-04 20:32:54+00:00,1.92,,2,1,2014-08-04 20:32:54+00:00,1.92,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
648,Scope of test functions,"Hi everyone, first, I really love the new version of jasmine, its very easy and human with the enhacements,
but I have the problem with testing this escenario in my Spec:
https://github.com/yosonjs/yosonjs/blob/master/test/spec/SpecCore.js#L30
I put the ""x"" because i don't want error when travis-ci execute
The basic funcionality of the library depuring it works here if you put an browser the little demo:
https://github.com/yosonjs/yosonjs/blob/master/examples/debug-area/welcome.html
I think by the scope of the function but its a escenario very especial.
Note: the steps of have the escenario you can follow here:
https://github.com/yosonjs/yosonjs/blob/master/DEVELOPMENT.md",andru255,NONE,2014-08-03 21:23:52+00:00,True,2014-08-04 22:50:51+00:00,1.06,,1,1,2014-08-04 21:41:54+00:00,1.01,andru255,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
649,Expectation on spy fails,"Can anyone tell why the expectation fails, but the call gets through.
Module definition
(function() {
    'use strict';
    var module = angular.module(""my.fancyStuff"", []);

    module.factory('service', function() {
        var timeout;

        var service = {
            start: function (scope) {
            }
        };

        return service;
    });

    module.controller('FancyStuffCtrl', function ($scope, $rootScope, service) {
        $rootScope.$on('$stateChangeStart', _.partial(service.start, $scope));
    });
}());

Test
describe('module', function () {
    ""use strict"";

        var mock;

    mock = {
        start: function() {
            console.log('reached start');
        }
    };

    beforeEach(module('my.fancyStuff', function ($provide) {
        $provide.factory('service', function () {
            return mock;
        });
    }));

    describe('FancyStuffCtrl', function () {
        var rootScope, scope, ctrl;

        beforeEach(inject(function ($controller, $injector) {
            rootScope = $injector.get('$rootScope');
            scope = rootScope.$new();
            ctrl = $controller('FancyStuffCtrl', { $scope: scope });
        }));

        it('delegates events from $rootScope', function () {
            spyOn(mock, 'start').and.callThrough();

            rootScope.$broadcast('$stateChangeStart');

            expect(mock.start).toHaveBeenCalled();
        });
    });
});",anho,NONE,2014-08-08 09:35:49+00:00,True,2014-08-13 19:57:42+00:00,5.43,,2,2,2014-08-13 19:57:42+00:00,5.43,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
652,toHaveBeenCalledWith fails to match parameter object methods,"Actual code:
scope.toggle({ getAttribute: function (attName) { return PRIMARY; } });
Unit Test code:
spyOn(scope, ""toggle"");
expect(scope.toggle).toHaveBeenCalledWith({ getAttribute: function (attName) { return PRIMARY; } });
Fails with the message:
""Expected spy toggle to have been called with [ { getAttribute: Function } ] but actual calls were [ { getAttribute: Function } ].""",vs0562,NONE,2014-08-18 15:47:18+00:00,True,2014-08-20 21:35:10+00:00,2.24,,5,5,2014-08-20 21:35:10+00:00,2.24,infews,CONTRIBUTOR,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
653,Jasmine test for AJAX and function that does not return any value,"1.Could you please say how to check the variable value inside the function
eg. function(data)
{
//...
var max=report;
//....
}
Here in the above function, I want to check the value of max using jasmine test cases.
2.How to check the ajax request using jasmine test cases
example:  request = $.ajax({
type: ""POST"",
url: 'login/index',
data: JSON.stringify(data),
contentType: 'application/json; charset=utf-8',
dataType: 'json',
success: function (data) {
//functions
text();
error();
}
});",RenugaP,NONE,2014-08-20 12:28:14+00:00,True,2014-08-20 20:19:45+00:00,0.33,,2,1,2014-08-20 20:19:45+00:00,0.33,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
654,input value does not get updated when keypress simulated,"I don't know if this is really jasmine's issue but here's what I found:
var input = $(""input"", element);
    expect(input.length).toBe(1);

    var keyVal = 111;   // 'o'
    input.trigger({
        type: 'keypress', keyCode: keyVal, which: keyVal, charCode: keyVal
    });
    keyVal = 110;   // 'n'
    input.trigger({
        type: 'keypress', keyCode: keyVal, which: keyVal, charCode: keyVal
    });
    keyVal = 101;   // 'e'
    input.trigger({
        type: 'keypress', keyCode: keyVal, which: keyVal, charCode: keyVal
    });

    expect(input.val()).toBe(""one""); //  !!! FALSE

But if I run this in browser input's value gets updated!
PS. I run this test with Chutzpah in VS2013 test runner.",alvipeo,NONE,2014-08-20 15:13:47+00:00,True,2014-08-20 20:17:53+00:00,0.21,,2,1,2014-08-20 20:17:53+00:00,0.21,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
655,Interval handler can't clear it's own interval,"If the function called by an interval calls clearInterval for the same interval, it isn't cleared.
How to Reproduce

Install jasmine's clock
Start an interval who's handler contains a clearInterval that clears the interval just created
Make the clock tick until the interval is triggered

Example:
jasmine.clock().install();
var intervalId = null;
intervalId = setInterval(function() {
  clearInterval(intervalId);
  console.log('tick');
}, 1000);
jasmine.clock().tick(5000);
jasimne.clock().uninstall();
Expected Result
The interval is cleared (in the example above, only one ""tick"" is printed)
Actual Result
The interval keeps running (in the example above, ""tick"" is printed 5 times)
Cause
In jasmine.js file, line 1110, function runScheduledFunctions there's the following code:
        var funcsToRun = scheduledFunctions[currentTime];
        delete scheduledFunctions[currentTime];

        for (var i = 0; i < funcsToRun.length; ++i) {
          var funcToRun = funcsToRun[i];
          funcToRun.funcToCall.apply(null, funcToRun.params || []);

          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        }
So, the code executes the following tasks in the following order:

Deletes the function from scheduledFunctions
Runs the function
Re-adds the function to scheduledFunctions

So, if ""clearInterval"" is called during the interval's handler invocation, it will run during step 2, when the function is not present on scheduledFunctions, and so, it will not be found by ""removeFunctionWithId"" (called by clearInterval), making the interval endure.",tgirardi,CONTRIBUTOR,2014-08-20 16:40:43+00:00,True,2014-09-02 20:20:33+00:00,13.15,,3,4,2014-08-20 17:05:37+00:00,0.02,tgirardi,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
656,npm package jasmine-core breaks interface in patch level release,"Upgrading jasmine-core through npm from 2.0.0 to 2.0.1 removed node_modules/jasmine-core/lib/jasmine-core/boot.js, the only way to bootstrap jasmine.
Unsure what the expected behaviour is for browser based testing in 2.0.1 now.
Most importantly though, please don't break the entry point in a patch level release!
Expected behaviour:
Keep on shipping boot.js until at least a minor version change.",cburgmer,NONE,2014-08-21 19:34:20+00:00,True,2014-08-21 19:56:21+00:00,0.02,,2,3,2014-08-21 19:56:53+00:00,0.02,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
659,Share a standard Reporter interface?,"We on the QUnit team have been discussing the possibility of working with other JS test frameworks (e.g. Mocha, Jasmine, Intern, etc.) to agree upon a standard Reporter interface so that we could hopefully share Reporter plugins between testing frameworks.
This would most likely come in the form of an EventEmitter interface with an agreed upon minimum viable set of standardly-named events and associated standard set of data/details provided to each.
Would you guys be interested in discussing this further with us?
Cross-reference issues:

qunitjs/qunit#531 (original discussion)
mochajs/mocha#1326
theintern/intern#257

cc: @jzaefferer @Krinkle @leobalter",JamesMGreene,NONE,2014-08-29 13:53:01+00:00,True,2014-09-25 20:02:37+00:00,27.26,,4,7,2014-08-30 04:47:18+00:00,0.62,boneskull,NONE,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
660,spyObj.andReturn() chaining should be allowed to return objects in order for multiple calls,"currently
spyOn(anObject, 'aMethod').andReturn('aValue');
spyOn(anObject, 'aMethod').andReturn('secondValue');

would always spy the aMethod function and second one overrides the first one returning only 'secondValue' when aMethod function is called.
Expected
Allow chaining so that the second spy does not override the first one, but instead, it defines the order of objects to be returned on subsequent calls of the same method.
i.e. the first call to aMethod would return 'aValue' and second method would return 'secondValue'.
An aesthetically better looking code would resemble
spyOn(anObject, 'aMethod').andReturn('aValue').andReturn('secondValue')....

Mocking libraries in other platforms provide this capability and is not a new concept.",zhengyangyin,NONE,2014-09-01 01:35:18+00:00,True,2014-09-15 20:12:33+00:00,14.78,,3,4,2014-09-02 20:15:05+00:00,1.78,slackersoft,MEMBER,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
661,How to use jasmine.any() on literal object?,"jasmine.any() looks for constructors. What if there are none?
I know there is objectContains, but for my test, I just to make sure something is passed, and that it's a literal object. I don't necessarily care what is in it.",alex-dow,NONE,2014-09-04 19:41:05+00:00,True,2014-09-08 17:46:20+00:00,3.92,,3,5,2014-09-04 19:51:52+00:00,0.01,joshuacc,NONE,1,0,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
662,mock class support,"I wrote some simple code about how to mock classes with jasmine:
var mockClass = function (Subject) {
    var Surrogate = function () {
        Surrogate.prototype.constructor.apply(this, arguments);
    };
    Surrogate.prototype = Object.create(Subject.prototype);
    Surrogate.prototype.constructor = Subject;
    return Surrogate;
};

var My = function (a) {
    this.init(a);
};
My.prototype = {
    init: function (a) {
        this.setA(a);
    },
    setA: function (a) {
        this.a = a;
    }
};

var Mock = mockClass(My);
spyOn(Mock.prototype, ""constructor"").andCallThrough();
spyOn(Mock.prototype, ""init"");

var m = new Mock(1);
expect(m instanceof My).toBe(true); //classic prototypal inheritance grants this
expect(m.constructor).not.toBe(My); //since it is a spy
expect(Mock.prototype.init).toBe(m.init);
expect(My.prototype.init).not.toBe(m.init); //since it is a spy
expect(m.constructor).toHaveBeenCalledWith(1); //calls through
expect(m.init).toHaveBeenCalledWith(1); //does not call through
expect(m.a).toBeUndefined(); //so a is not defined
m.setA(1);
expect(m.a).toBe(1);

spyOn(Mock.prototype, ""setA"").andCallFake(function (a) {
    this.a = a + 1;
}); //calls fake
m.setA(1);
expect(m.setA).toHaveBeenCalledWith(1); //spy was called with 1
expect(m.a).toBe(2); //but fake set the value to 2

I hope this solution fits to the current fluent interface of jasmine, and you can add the mockClass() function to the lib. Regards ...",inf3rno,NONE,2014-09-05 21:58:41+00:00,True,2014-10-22 19:56:30+00:00,46.92,,2,4,2014-09-07 03:46:33+00:00,1.24,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
664,Add aroundEach,"Would be nice to be able to wrap execution of steps with an async function, for example wait for promise to finish.
Something like:
aroundEach(function() {
  sendAsyncRequest().then(function() {
    executeStep();
  });
});

or:
aroundEach(function(step) {
  sendAsyncRequest().then(function() {
    step.execute();
  });
});

It exists in ruby RSpec and very useful.",adamkleingit,NONE,2014-09-09 11:28:32+00:00,True,2014-11-05 21:11:47+00:00,57.41,,3,2,2014-09-09 16:49:31+00:00,0.22,Gerg,CONTRIBUTOR,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
665,Error: 'null' is not an object (evaluating 'currentSpec.expect'),"This issue has already been posted on karma-jasmine page, but it is a jasmine issue.
As my test suites grew large (over 1100 specs), I started getting the following error: 'null' is not an object (evaluating 'currentSpec.expect') during test execution (using grunt + karma + karma-jasmine and testing an app written using AngularJS). The error would stop the test execution somewhere around spec #700 and report no details. It would consistently trigger during the subsequent executions. It would only disappear after I removed or disabled a spec (any spec, not necessarilly the previously added one). It seems the problem is simply with the suite being too large.
@Mironor created a fix candidate which fixed this problem for me. If you could include it in the next 2.x version of Jasmine or fix this total blocker in some other way, I'd be much obliged.",hon2a,NONE,2014-09-09 11:34:56+00:00,True,2014-10-03 13:11:21+00:00,24.07,,7,18,2014-09-11 20:02:36+00:00,2.35,slackersoft,MEMBER,1,1,0,5,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
666,Nested beforeEachs are only called the first time the suite is run,"The suite:
describe('my suite', function() {
    it('one', function(done) {
        expect(true).toBe(true);
        done();
    });

    describe('nested suite', function() {
        var myval;
        beforeEach(function(done) {
            myval = 1;
            done();
        });

        it('two', function(done) {
            expect(myval).toBe(1);
            myval = 0;
            done();
        });
    });
});
The code that runs the test:
function runSpecs(){
    var jasmineCont = document.getElementById('jasmine-cont');
    var env = jasmine.getEnv();
    var htmlReporter = new jasmine.HtmlReporter({
        env: env,
        getContainer: function() {
            return jasmineCont;
        },
        createElement: function() {
            return document.createElement.apply(document, arguments);
        },
        createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
        },
        timer: new jasmine.Timer()
    });
    env.clearReporters();
    env.addReporter(htmlReporter);
    jasmineCont.innerHTML = '';
    htmlReporter.initialize();
    env.execute([ jasmine.getEnv().topSuite().children[0].id ]);
}
The first time runSpecs is called:

And the second:


The diff for clearReporters (the function referenced in runSpecs):
diff --git a/jasmine/jasmine.js b/jasmine/jasmine.js
index 17652ea..fa3d4c9 100755
--- a/static/js/jasmine/jasmine.js
+++ b/static/js/jasmine/jasmine.js
@@ -542,6 +542,10 @@ getJasmineRequireObj().Env = function(j$) {
       reporter.addReporter(reporterToAdd);
     };

+    this.clearReporters = function() {
+      reporter.clearReporters();
+    };
+
     this.addMatchers = function(matchersToAdd) {
       j$.Expectation.addMatchers(matchersToAdd);
     };
@@ -1681,6 +1685,10 @@ getJasmineRequireObj().ReportDispatcher = function() {
       reporters.push(reporter);
     };

+    this.clearReporters = function() {
+      reporters = [];
+    };
+
     return this;

     function dispatch(method, args) {",mustafa0x,NONE,2014-09-10 12:43:56+00:00,True,2014-10-23 19:45:37+00:00,43.29,,2,3,2014-09-10 20:40:18+00:00,0.33,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
667,jasmine.Clock.tick() silently swallows errors,"I'm currently trying to write a test like this:
it(""allows errors in setTimeout() functions to be tested"", function() {
    jasmine.Clock.useMock();

    setTimeout(function() {
        throw new Error(""Error within a timeout."");
    }, 0);

    expect(function() {
        jasmine.Clock.tick(1);
    }).toThrow(new Error(""Error within a timeout.""));
});

But errors throw within setTimeout() call-backs can not be tested at present as jasmine.Clock.tick() silently swallows them.",dchambers,NONE,2014-09-11 12:58:04+00:00,True,2015-07-30 14:44:40+00:00,322.07,,2,2,2014-09-11 19:44:03+00:00,0.28,slackersoft,MEMBER,1,0,0,1,"['1.3.x', 'waiting']",True,False,False,False,False,False,False,False,False,False,False,False,True,False,False
668,Feature request: Format long JSON failures nicely,"When you're comparing a big JSON object to an expectation, the result is long, unwieldy, and hard to read. (See screenshot below.) Could Jasmine format/pretty-print these?
Thanks!",elanakoren,NONE,2014-09-12 23:16:07+00:00,True,2015-03-27 15:16:09+00:00,195.67,,3,4,2014-09-20 22:29:41+00:00,7.97,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
670,Feature request: Harmony/Generators support,"I don't know where to post this feature request mhevery/jasmine-node#349 so I'll do again:
As I speak with nodejs developers the majority love --harmony features (generators, yields) and they often complain about slow adoption that new cool features. That includes me ;). Well, once you start with e.g. koajs you can not go back to the old tracks. The code simply becomes sexy and clean.
My proposal is to make jasmine the first framework that support generators. This would become a must-have framework for me and many others who love beautiful code.
it('should support generators', function*() {
   var d = yield do('here we go')
   expect(d).toBe('awesome')
})",xpepermint,NONE,2014-09-14 15:14:28+00:00,True,2014-10-31 19:56:08+00:00,47.2,,5,15,2014-09-15 20:05:51+00:00,1.2,slackersoft,MEMBER,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
671,Pending specs overview,"Currently, pending() ignores any argument.
However, like in RSpec, I think it would be very useful to be able to do something like pending(""doesnt work, issue #123"") and being able to see these message somewhere in the output.
For example, in a similar view as the failed specs.",lenntt,NONE,2014-09-16 09:20:51+00:00,True,2015-01-26 23:56:08+00:00,132.61,,3,1,2014-09-16 20:30:25+00:00,0.46,Gerg,CONTRIBUTOR,0,1,0,0,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
672,Feature Request: status(...) inside unit tests,"Sometimes it can be helpful to output some of the test results. For example, I wrote a small test using canvas that compared the SVG rendered inside the Browser to its PNG fallback rendered by RSVG. In this example, I would like to output the % of deviation - currently, I do that on the console, but I would like it better to have it shown within the results.",atk,NONE,2014-09-16 12:59:25+00:00,True,2014-09-23 20:36:56+00:00,7.32,,2,3,2014-09-16 20:12:31+00:00,0.3,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
673,Describes on pending,"Hi,
It would be useful being able to make a group of specs on pending.
describe(""some stuff"", function()
{
     pending(""Not working until issue #123 is fixed"");
     it_behaves_in_some_way();
}

Currently, its not possible to put 'describes' on pending.
It gives me the output:

some stuff

encountered a declaration exception",lenntt,NONE,2014-09-17 13:11:01+00:00,True,2014-09-17 20:18:18+00:00,0.3,,2,1,2014-09-17 20:18:18+00:00,0.3,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
674,jasmine 1.x support,So I was wondering if anyone had any ideas on how to upgrade from 1.x to 2.x? We have over 500 tests and I was wondering if there was any adapter out there or some easy way to start writing new tests in 2.x and work on deprecating old tests over time?,joseph-jja,NONE,2014-09-17 15:55:21+00:00,True,2014-09-23 20:45:50+00:00,6.2,,2,4,2014-09-17 20:20:03+00:00,0.18,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
675,toEqual should list differences instead of pretty printing objects,"Consider this simple example (jsfiddle):
var actual = { x: 1, y: { z: 2 } };
var expected = { x: 1, y: { z: 3 }};
expect(actual).toEqual(expected);
This outputs:
Expected { x : 1, y : { z : 2 } } to equal { x : 1, y : { z : 3 } }.
In other words it pretty prints both objects.
Now imagine we are in real world where objects are quite complex and toEqual quickly becomes useless.
I would expect output like:
Expected no differences but found 1:
1. Expected y.z = 2 to equal 3

i.e. list all differences with paths.",mwisnicki,NONE,2014-09-18 16:29:06+00:00,True,2016-11-17 02:01:46+00:00,790.4,,24,46,2014-09-18 20:43:10+00:00,0.18,slackersoft,MEMBER,1,1,0,22,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
676,Publish to CDN,Publishing to CDN or providing other means of using jasmine in jsfiddle would be very useful.,mwisnicki,NONE,2014-09-18 16:31:29+00:00,True,2015-01-14 18:30:05+00:00,118.08,,3,2,2015-01-14 15:56:32+00:00,117.98,rohit,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
677, TypeError: 'null' is not an object (evaluating 'currentSpec.$injector') + Phantom JS and Jasmine on grunt,"[4mRunning ""jasmine:src"" (jasmine) task�[24m
Testing jasmine specs via PhantomJS
Cards controllers
cardsListController
- should return 2 cards......×
TypeError: 'null' is not an object (evaluating 'currentSpec.$injector') in file:///D:angular-mocks.js (line 2015) (1)
TypeError: 'null' is not an object (evaluating 'currentSpec.$injector') in file:///D:angular-mocks.js (line 2015) (2)
TypeError: 'null' is not an object (evaluating 'currentSpec.$modules') in file:///D:angular-mocks.js (line 2138) (3)
1 spec in 0.002s.
�[31m>> �[39m1 failures
�[33mWarning: Task ""jasmine:src"" failed.� Use --force to continue.�[39m
�[31mAborted due to warnings.�[39m",DavidAsish,NONE,2014-09-23 08:37:27+00:00,True,2014-12-16 23:58:40+00:00,84.64,,6,11,2014-09-23 20:33:28+00:00,0.5,slackersoft,MEMBER,1,0,0,5,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
678,new Date() instanceof Date returns false if jasmine.clock() is installed,,chernetsov,CONTRIBUTOR,2014-09-23 14:53:43+00:00,True,2014-09-25 19:59:50+00:00,2.21,,2,4,2014-09-23 20:26:55+00:00,0.23,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
680,Configuring DEFAULT_TIMEOUT_INTERVAL declaratively?,"Idea: it’d be nice if one could configure some things declaratively and temporarily (per describe()). Caveat: I’m still getting up to speed on Jasmine, so I’m not 100% sure how well this idea fits in, stylistically.
Currently:
  describe(""long asynchronous specs"", function() {
    var originalTimeout;
    beforeEach(function() {
      originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
      jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;
    });
    ...
    afterEach(function() {
      jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;
    });
  });
Declarative configuration, via an additional parameter:
  describe(""long asynchronous specs"",
    { DEFAULT_TIMEOUT_INTERVAL: 10000 },
    function() {
      ...
    });
A similar mechanism could be introduced for it().",rauschma,NONE,2014-09-26 07:44:07+00:00,True,2014-10-10 20:20:24+00:00,14.53,,3,2,2014-09-26 15:37:39+00:00,0.33,sheelc,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
681,Allow test to return Promise as an alternative to the done callback,"As proposed in issue #567 Jasmine should allow a test to return a Promise as an alternative to using the done callback for async testing.
A test would not specify the done callback as its parameter and would return a Promise:
it('should pass', function () {
  return new Promise(function (resolve, reject) {
    resolve('value');
  });
});

it('should fail', function () {
  return new Promise(function (resolve, reject) {
    reject(new Error('reason'));
  });
});",analog-nico,NONE,2014-09-27 16:19:23+00:00,True,2014-10-31 20:33:20+00:00,34.18,,16,24,2014-09-27 20:04:25+00:00,0.16,bilalq,NONE,2,0,0,13,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
683,Restore behavior for spy,"I think it would be a good to restore a spy to its original value (not talking about reset).
Lets say I spy on an function but later on I want to remove my spy , just for clean up purpose.
This would help different parts of the test suites to create their own spies on certain global functions.
It has been done in sinonJs library. http://sinonjs.org/docs/#spies",gyandeeps,NONE,2014-10-06 18:00:19+00:00,True,2014-10-06 20:42:27+00:00,0.11,,3,3,2014-10-06 20:42:27+00:00,0.11,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
684,Feature request : beforeAll and afterAll callback,It could be nice to have a beforeAll/afterAll callback. Typical use case is login before running tests and logout after runned all tests.,cindoum,NONE,2014-10-06 19:20:35+00:00,True,2014-10-06 20:41:38+00:00,0.06,,3,3,2014-10-06 20:41:38+00:00,0.06,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
687,Ajax - POST Body Expect is Incorrect,"I'm kinda new to this, but it looks like an issue to me.
I'd like to test a POST over jQuery Ajax. Need to test and make sure the BODY is getting attached properly. The comparison failure message says the items are different. But they sure look the same, or at least there's no way to tell the difference. They look the same to me....
Any thoughts?
Is this not supported?
Is it because of the ""JSON.stringify(body)""? When you add the stringify to the output, the toBe still fails.

Expected { some: 'body', another: 'something' } to be { some: 'body', another: 'something' }.

describe(""Tests"", function() {
        beforeEach(function () {
            jasmine.Ajax.install();
        });
        afterEach(function() {
            jasmine.Ajax.uninstall();
        });
        it(""Jasmine Test"", function() {
            var body = { some: 'body', another: ""something"" };
            var req = {
                type: ""POST"",
                url: ""/api"",
                data: JSON.stringify(body),
                dataType: ""json"",
                contentType: ""application/json"",
                beforeSend: function (request) {
                    request.setRequestHeader(""X-Test-Header"", ""value"");
                },
                success: function(data) { },
                error: function(jqXHR) {}
            };
            $.ajax(req);
            //Fails
            expect(jasmine.Ajax.requests.mostRecent().data()).toBe(body);
            //Works
            expect(jasmine.Ajax.requests.mostRecent().method).toBe(""POST"");
            expect(jasmine.Ajax.requests.mostRecent().url).toBe(""/api"")
            expect(jasmine.Ajax.requests.mostRecent().requestHeaders[""X-Test-Header""]).toBe(""value"")
        });
    });

Expected { some: 'body', another: 'something' } to be { some: 'body', another: 'something' }.
Error: Expected { some: 'body', another: 'something' } to be { some: 'body', another: 'something' }.
at stack (http://localhost:8500/test/libs/jasmine/lib/jasmine-2.0.2/jasmine.js:1304:17)
at buildExpectationResult (http://localhost:8500/test/libs/jasmine/lib/jasmine-2.0.2/jasmine.js:1281:14)
at Spec.Env.expectationResultFactory (http://localhost:8500/test/libs/jasmine/lib/jasmine-2.0.2/jasmine.> js:473:18)
at Spec.addExpectationResult (http://localhost:8500/test/libs/jasmine/lib/jasmine-2.0.2/jasmine.> js:271:34)
at Expectation.addExpectationResult (http://localhost:8500/test/libs/jasmine/lib/jasmine-2.0.2/jasmine.> js:431:21)
at Expectation.toBe (http://localhost:8500/test/libs/jasmine/lib/jasmine-2.0.2/jasmine.js:1220:12)",gregberns,NONE,2014-10-08 01:29:25+00:00,True,2014-10-08 16:00:59+00:00,0.61,,2,2,2014-10-08 04:36:05+00:00,0.13,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
688,jasmine.log() missing in Jasmine 2.0,"I have a spec that catches all errors that are thrown, even syntax errors in the specs themselves. (From How to make a Jasmine BDD test suite fail on generic JavaScript syntax errors).
The following was working in Jasmine 1.3, but when I upgraded to 2.0 it seems that jasmine.log() and function to stop Jasmine from running further tests does not work anymore.
describe('App code & tests', function() {
    it('should contain no Javascript errors', function() {
        var numErrors = (window.errors) ? window.errors.length : -1;
        expect(numErrors).toBe(0);

        if (window.errors && numErrors > 0) {
            var loc = window.location;
            jasmine.log('Encountered ' + numErrors + ' error(s):');

            for (var i = 0; i < numErrors; i += 1) {
                jasmine.log(window.errors[i].errorMessage, ' in file ',
                window.errors[i].url.replace(loc.protocol+'//', '').replace(loc.host, ''), ' on line ',
                window.errors[i].lineNumber);
            }
            jasmine.log('If you need more info, run mvn jasmine:bdd and check your browser console!');

            // There is an error in the code - stop running tests!
            jasmine.Queue.prototype.next_ = function () {
                // to instead skip to the end
                this.onComplete();
            };
        }
    });
});

Was there a reason this was changed? And is there an alternative way to achieve the same thing?",amylo,NONE,2014-10-09 17:16:47+00:00,True,2014-10-25 05:48:32+00:00,15.52,,2,3,2014-10-10 20:31:01+00:00,1.13,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
689,No specs found on node 0.11.14,"Just tried Jasmine on Node 0.11.14 (unstable) and I get some errors. It also doesn't seem to find the specs.
$ jasmine
util.print: Use console.log instead
Startedutil.print: Use console.log instead

util.print: Use console.log instead

util.print: Use console.log instead
No specs foundutil.print: Use console.log instead

util.print: Use console.log instead
Finished in 0.001 secondsutil.print: Use console.log instead

deprecations are an easy fix but the fact it doesn't find the specs is kind of a non-starter. Not that I was expecting it to be all hunky dory on an unstable node release. Just thought I'd mention.",PhilT,NONE,2014-10-13 21:49:39+00:00,True,2014-10-21 05:59:26+00:00,7.34,,2,3,2014-10-21 04:01:19+00:00,7.26,amavisca,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
690,Significant increase in testing time on CI with upgrade to 2.0.3,"Hi, we have experienced an approximate doubling of testing on on our CI with the upgrade from jasmine-core 2.0.0 to 2.0.2. Locally, running rake jasmine:ci appears to take a very large amount of time.
Is there anything we can do to remedy this? In the meantime, I've upgraded only jasmine, but set the version of jasmine-core to 2.0.0.",NavyAnt24,NONE,2014-10-15 21:35:19+00:00,True,2014-11-22 23:03:37+00:00,38.06,,3,2,2014-10-19 20:56:54+00:00,3.97,Gerg,CONTRIBUTOR,0,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
692,Lack of rspec/let style support preventing upgrading to Jasmine 2.0,"I have failed to get jasmine-let or memo-is to work with Jasmine 2.0, and those are libraries I would depend on for helping structure test context easily and in a manner similar to what I have grown accustomed to doing with rspec.  jasmine-let work well with 1.3.1, so I will continue to use this as it is unlikely any improvements offered in 2.0 are more important than have a respec/let like facility; however, I am concerned that this will become a genuine problem in the long run.  Is there any plan to fix this (or is there a feature that I am just not aware of that allows for a similar pattern), or are you aware of any library that actually does work with Jasmine 2.0?",jthibeaux,NONE,2014-10-19 19:37:13+00:00,True,2014-10-23 20:18:11+00:00,4.03,,2,1,2014-10-23 20:18:11+00:00,4.03,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
693,"Page Object Pattern - Assertions ""Bad""","The biggest issue I have with Assertions in Page Object Pattern is the time consumed to run the same assertions constantly but believe there are benefits to including Assertions in the Page Object model.  So I'm suggesting mock objects in place for:
element()
element.all()
expect()
And a boolean switch of when to run the assertion and when to ignore the assertion.
This way assertions can still be put inside the page objects but be active for specific tests only.
''''
base.prototype.element = function(locator) {
    if(this.runAssert) {
        return element(locator);
    } else {
        return mockLocator;
    }
}

base.prototype.element.all = function(locator) {
    if(this.runAssert) {
        return element.all(locator);
    } else {
        return mockLocatorList;
    }
}

base.prototype.expect = function (locator, opt_parentElementFinder) {
    if(this.runAssert) {
        return expect(locator, opt_parentElementFinder);
    } else {
        return mockMatcher;
    }
}

var mockLocatorList = {
    get: function() {return mockLocator}
}

var mockLocator = {
     click: function(){return true;},
     sendKeys: function(){return true;},
     getTagName: function(){return true;},
     getCssValue: function(){return true;},
     getAttribute: function(){return true;},
     getText: function(){return true;},
     getSize: function(){return true;},
     getLocation: function(){return true;},
     isEnabled: function(){return true;},
     isSelected: function(){return true;},
     submit: function(){return true;},
     clear: function(){return true;},
     isDisplayed: function(){return true;},
     getOuterHtml: function(){return true;},
     getInnerHtml: function(){return true;},
     getId: function(){return true;}
}

var mockMatcher  = {
    toEqual: function(){return true;},
    toBe: function(){return true;},
    toMatch: function(){return true;},
    toBeDefined: function(){return true;},
    toBeUndefined: function(){return true;},
    toBeNull: function(){return true;},
    toBeTruthy: function(){return true;},
    toBeFalsy: function(){return true;},
    toContain: function(){return true;},
    toBeLessThan: function(){return true;},
    toBeGreaterThan: function(){return true;},
    toThrow: function(){return true;}
};

//Terrible example code that doesn't function for implementing above: 
it(""should have a hyperlink"", function() {
    //Some way to turn on/off the assertion...global var?
    var textXpath = "".//*[@id=""folderContentsTable""]/tbody/tr/td/a/span"";

    var allCells = element.all(by.xpath(textXpath));
    expect(allCells.get(0).getText()).toBe('Jasmine');

    var firstCell = element(by.xpath(textXpath));
    coralExpect(firstCell.getText()).toBe('Jasmine');
}

''''
I had noticed handling the ""expect()"" function alone as a mock had the same decrease in performance as not.  So the other functions were added.",flavouski,NONE,2014-10-21 13:47:58+00:00,True,2014-10-21 16:06:40+00:00,0.1,,2,2,2014-10-21 15:04:42+00:00,0.05,joshuacc,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
694,expects in Asynchronous Support still throws an console log,"If I use setTimeout and the done() function in an it block then i get a weird console log.
Uncaught Error: 'expect' was used when there was no current spec, this could be because an asynchronous test timed out.
The message tells me that u still know about this bug.",akrillo89,NONE,2014-10-23 07:24:38+00:00,True,2015-01-20 00:10:09+00:00,88.7,,7,8,2014-10-23 08:07:53+00:00,0.03,lenntt,NONE,1,0,0,5,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
695,Passing a value to done callback should throw an error,"I believe it's how mocha works and it would simplify a lot of things when it comes to async tests .
For instance :
describe('GET /',function(){
    it(""is 200"",function(done){
        this.agent
            .get('/')
            .expect(200,done);
    });
});

should throw an error if the callback is passed an error instead of doing
describe('GET /',function(){
    it(""is 200"",function(done){
        this.agent
            .get('/')
            .expect(200,function(err){
                  expect(err).toBe(null);
                  done();
              });
    });
});",Mparaiso,NONE,2014-10-24 05:59:52+00:00,True,2014-10-24 20:25:41+00:00,0.6,,2,1,2014-10-24 20:25:40+00:00,0.6,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
697,Memory Leaks in Spies,"We've got a large project and are using spies and stubs to test behaviours, and we end up passing about a lot of bound callbacks.
Unfortunately we have a very unloved test suite which seems to be riddled with memory leaks. In investigating this I've seen a lot of our bound callbacks being held by spies being kept in reporters ""actual"" due to their use in our asserts statements. There's also references all over the place in mostRecent/nthCall args arrays.
Do these need to be kept once the suite has completed?",aslate,NONE,2014-10-27 11:15:27+00:00,True,2016-09-28 00:38:54+00:00,701.56,,3,3,2014-10-27 20:30:16+00:00,0.39,slackersoft,MEMBER,1,0,0,1,['1.3.x'],False,False,False,False,False,False,False,False,False,False,False,False,True,False,False
701,Ruby gem for version 2.0.4 ?,"I notice that there's tags for 2.0.3 and 2.0.4 releases.  However the latest version available on ruby gems is 2.0.2  https://rubygems.org/gems/jasmine-core
I've been holding off merging in Jasmine 2.0 support for GuardJasmine guard/guard-jasmine#161 (comment) until a release is cut so I can properly support disabled suites.
Thanks!",nathanstitt,NONE,2014-11-10 01:49:59+00:00,True,2014-11-10 15:13:30+00:00,0.56,,3,2,2014-11-10 05:37:06+00:00,0.16,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
702,HTML report being able to show timestamps/duration ,"I'm writing high-level application tests with jasmine.
One of the problems is, that I get a lot of these kind of failures, also having a domino effect on other specs:

Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.

Of course, that is my very own problem.
However, It would really help analyzing these errors (e.g. to check whether there is a real regression or the performance just went down) (and to see performance trends), if the timestamp/duration of the spec execution was being shown.
I think showing it in a default view would only pollute the nice&clean output, but perhaps it would be useful to do one of these:

Show it when the URL has a ?show_time=true parameter set.
Show it in a hidden field (so see it with a custom css).

I was wondering if more users would benefit from having a feature like this.",lenntt,NONE,2014-11-11 15:32:48+00:00,True,2014-11-12 09:44:05+00:00,0.76,,2,3,2014-11-11 16:52:18+00:00,0.06,lenntt,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
703,Please clarify asynchronous function support vs. concurrent test execution,"There's some confusion whether or not tests run asynchronously or not:
http://stackoverflow.com/questions/25652895/are-test-cases-in-jasmine-2-0-run-in-parallel
It's somewhat spelled out on this page https://github.com/pivotal/jasmine/blob/master/release_notes/20.md, but I think it should be more prominent:

The next function, whether it's a before, spec or after, will wait until this function is called or until a timeout is reached.

Perhaps this can turn into a feature request for async execution.",motherwaym,NONE,2014-11-12 16:35:56+00:00,True,2014-11-13 21:04:20+00:00,1.19,,6,8,2014-11-13 21:04:20+00:00,1.19,slackersoft,MEMBER,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
704,beforeAll is not defined,"I'm using Protractor 1.4.0 that should include jasmine but doing this:
describe('Create album', function() {
  beforeAll(function () {
    ...
  });
});
Give me this error: ReferenceError: beforeAll is not defined but the jasmine doc refer it.",enricorotundo,NONE,2014-11-14 01:44:56+00:00,True,2014-11-14 01:49:40+00:00,0.0,,5,8,2014-11-14 01:49:40+00:00,0.0,slackersoft,MEMBER,2,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
705,Proposal: `this` binding in `callFake`,"describe('this binding', function() {
  var spy;
  beforeEach(function() {
    spy = {
      override: function() { },
      boundOverride: function() { }
    };
    this.something = 'foo';
    spyOn(spy, 'override').and.callFake(function() {
      this.something = 'bar';
    });
    spyOn(spy, 'boundOverride').and.callFake(function() {
      this.something = 'baz';
    }.bind(this));
  });

  it('should be defined', function() {
    expect(this.something).toEqual('foo');
    spy.boundOverride();
    expect(this.something).toEqual('baz');
    spy.override();
    expect(this.something).toEqual('bar');
  });
});
this binding should be defined
  Expected 'baz' to equal 'bar'.  Error: Expected 'baz' to equal 'bar'.
      at stack (/home/me/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1304:17)

Up for discussion. Probably it makes sense to bind this by default.
Why would you use this in callFake for something else?
Latest jasmine 2.0 used.",pirj,NONE,2014-11-14 13:23:35+00:00,True,2014-11-14 18:31:52+00:00,0.21,,2,2,2014-11-14 17:45:46+00:00,0.18,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
706,Breaking Issue: `suiteDone` gets emitted for top suit,"The top level suite (suite0 per say) which emits a suiteDone event but never emits a suiteStart event.
So all the reporters who listen for these events throw error because they never received a suiteStart for suite0 but at the end they received suiteDone for suite0.
But I think that if this top level suite is for internal jasmine purpose then either it should emit both the events or neither.
This has happened in new version 2.1.0 at this revision: 9402d59#diff-f41e57b2889bae3046aa9f352699785cR182
grunt-contrib-jasmine is breaking too. gruntjs/grunt-contrib-jasmine#181",gyandeeps,NONE,2014-11-15 00:55:03+00:00,True,2014-11-15 02:37:34+00:00,0.07,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
707,Pending specs are missed,"Spotted after update to 2.1, regression from 2.0. I suspect this is due to focused spec changes.
Both versions installed from npm.
describe('Pending specs', function() {
  it('can be the only spec inside a describe block');
});

describe('Pending specs', function() {
  describe('when nested inside a second describe', function() {
    it('can be the only spec in hierarchy');
  });
});
jasmine-npm 2.0.1, jasmine-core 2.0.4:
$ jasmine
Started
**

2 specs, 0 failures, 2 pending specs

jasmine-npm 2.1.0, jasmine-core 2.1.1:
$ jasmine
Started

No specs found

Problem is that the it calls do not make it into the list of the specs if no non-pending specs is present inside describe block.",pirj,NONE,2014-11-16 13:28:09+00:00,True,2014-11-16 22:44:44+00:00,0.39,,2,4,2014-11-16 18:50:04+00:00,0.22,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
708,Interfering timers,"jasmine-npm@2.1.0 jasmine-core@2.1.2
This one was really hard to track down.
describe('Clashing timeouts', function() {
  var spy;

  beforeEach(function() {
    spy = jasmine.createSpy();

    jasmine.clock().install();

    var interval = setInterval(spy, 10000);

    var stopInterval = function() {
      clearInterval(interval);
    };

    setTimeout(stopInterval, 20000);
    // Replace with value that is not multiple to 10000 to pass:
    // setTimeout(stopInterval, 20001);

    setTimeout(stopInterval, 50001);
  });

  it('stops at first timeout', function() {
    jasmine.clock().tick(200000);
    expect(spy.calls.count()).toEqual(2);
  });
});

What would you expect call count to be? One, two? Five!
F

Clashing timeouts stops at first timeout
  Expected 5 to equal 2.  Error: Expected 5 to equal 2.

P.S. I call it ""There must be only one (at a time)"" ;)",pirj,NONE,2014-11-17 18:30:53+00:00,True,2014-12-05 16:55:34+00:00,17.93,,2,1,2014-11-27 06:01:13+00:00,9.48,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
709,Done handling still isn't quite right,"I'm on version 2.0.2
Think there were some pretty big changes to this from 2.0 and it's made it loads better but I'm getting the following problem:
if you have a setup like this:
beforeEach(function(done){
    console.log('start');
    doSomethingThatWillCall(done);
    doSomeOtherStuff();
    console.log('end of beforeEach');
});

it('is a test', function(){
    console.log('in test');
});

If doSomethingThatWillCall calls done immediately (rather than in an asynchronous manner) then you end up dropping into the test before the subsequent call is done.  Eg you'd get the following in the console:
'start'
'in test'
'end of beforeEach'
Im not sure where the fix would go in the jasmine code but I'd suggest you could do something like this when the before each is run
function functionThatSortsItOut(beforeEachFunction, existingDoneFunction) {
    var endReached = false;
    var triedToCallDoneEarly = false;

    var patchedDone = function () {
        triedToCallDoneEarly = true;

        if(!endReached)
            return;

        existingDoneFunction();
    };

    beforeEachFunction(patchedDone);
    endReached = true;

    if(triedToCallDoneEarly)
        existingDoneFunction();
}

It sort of feels like that could be simpler but it's nearly home time and i'm tired!
That way it calls done only if the end of the function has already been hit - either when it gets run or later when done gets called asynchronously.

As a bit of an aside nice one with including beforeAll and afterAll... although I've not tried them out yet (I've patched in my own version of beforeAll already).  I really like this library - in particular nesting suites is a really great feature - lets you save repeating setup code and bits of test names + something that puts it ahead of similar frameworks in other languages.",JonnyRa,NONE,2014-11-18 17:17:59+00:00,True,2014-11-18 23:18:31+00:00,0.25,,4,12,2014-11-18 21:46:09+00:00,0.19,pirj,NONE,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
710,Jasmine clock() and native Promise,"Any idea or suggestion on how to deal with native Promises when mocking the clock?

You can make setTimeout or setInterval synchronous executing the registered functions only once the clock is ticked forward in time.

Take a look at this example
describe('Promise', function () {
    var resolvedValue;

    beforeEach(function () {
        resolvedValue = null;
        jasmine.clock().install();
    });
    afterEach(function () {
        jasmine.clock().uninstall();
    });

    function getDataPromise () {
        new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve(12);
            }, 100);
        }).then(function (value) {
            resolvedValue = value;
        });
    }

    function getDataJQuery () {
        var deferred = new $.Deferred();
        setTimeout(function () {
            deferred.resolve(12);
        }, 100);
        deferred.promise().then(function (value) {
            resolvedValue = value;
        });
    }

    it('native promise', function () {
        // This is async, but I'd like to turn it into sync
        getDataPromise();

        jasmine.clock().tick(200);

        expect(resolvedValue).toBe(12);
    });

    it('jquery promise', function () {
        // This is async, but I'd like to turn it into sync
        getDataJQuery();

        jasmine.clock().tick(200);

        expect(resolvedValue).toBe(12);
    });
});
In the test I create a promise and using the clock() I try to make it synchronous. The test on jQuery passes, the one using native Promise fails because internally the browser makes sure that the then callback is always asynchronous.
This test is overly simplified, but assume I don't have access to the promise object (it's deep down in my modules), how can I test this?
One solution would be to have some API that allows me to access to the native setTimeout, say this
    it('native promise', function (done) {
        getDataPromise();

        jasmine.clock().tick(200);

        // This access to the native setTimeout
        jasmine.clock().setTimeout(function () {
            expect(resolvedValue).toBe(12);

            done();
        }, 0);
    });
Or maybe
    it('native promise', function (done) {
        getDataPromise();

        jasmine.clock().tick(200).then(function () {
            expect(resolvedValue).toBe(12);

            done();
        });
    });",piuccio,NONE,2014-11-20 11:57:57+00:00,True,2015-01-23 21:15:16+00:00,64.39,,4,5,2014-11-20 18:59:01+00:00,0.29,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
711,"Feature request: Add ""it.fails"" as opposite of ""it""","Reason:
We had some custom matchers, one of them comparing arrays for approximate equality. Before we updated to Jasmine 1.3, the following test would fail:
it('fails', function() {
  expect([1]).toBeCloseToArray([42]);
}

Now in Jasmine 1.3, our customer matchers could still be used, but never failed! The reason is that they must be registered differently since 1.3. Now, the following test passes (note that the checks succeed both with and without ""not"" !)
it('should fail but does not', function() {
  expect([1]).toBeCloseToArray([42]);
  expect([1]).not.toBeCloseToArray([42]);
  expect([1]).toBeCloseToArray([1]);
  expect([1]).not.toBeCloseToArray([1]);
}

This is very bad, since we continued using those matchers without noticing that they did not work. Of course we had tests for them, but they looked like this, and still passed:
it('compares arrays', function() {
  expect([]).toBeCloseToArray([], 1);
  expect([1, 9]).not.toBeCloseToArray([1, 2]);
  expect([1, 9]).not.toBeCloseToArray([1, 2], 1);
  expect([1, 9]).toBeCloseToArray([1, 2], -3);
}

We also had tests calling jasmine.Matchers.prototype.toBeCloseToArray directly and checking the result. Those also passed, of course, since the function itself was still correct.
If there was a function it.fails, we could add simple smoke tests like this:
it.fails('on non-equal array items', function() {
  expect([1]).toBeCloseToArray([42]);
}
it.fails('on arrays of different size', function() {
  expect([]).toBeCloseToArray([42]);
}

This would ensure that our custom matchers work and are correctly registered with Jasmine.
I looked at the matcher specs of Jasmine's own matchers, but those specs suffer from the same problem, they just call the matcher function and check the return value. It is never tested that they are correctly registered with Jasmine and actually cause tests to fail.",heidemn,NONE,2014-11-21 18:39:31+00:00,True,2014-11-22 22:55:43+00:00,1.18,,2,4,2014-11-21 21:21:38+00:00,0.11,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
713,Support multiple createSpyObj in one call,"I use a lot of constructor-style dependency injection and like to use spy objects in place of those dependencies in my tests. As a consequence, my suites tend to start with a lot of jasmine.createSpyObj calls (one for each injected dependency, plus one for any secondary object I need/want to spy on as a return value from one of those dependencies)
It would save me some typing and improve readability if I could reduce that to one call, something like (note the pluralization of createSpyObjs):
var deps = jasmine.createSpyObjs({
    something: [ ""someMethod"", ""someOtherMethod"" ],
    somethingElse: [ ""yetAnotherMethod"" ],
    // and so on...
});

...and get back one object which contains all the mocks I need. (The keys above would be the names of the spy object, and the values would be the names of the spies in those mocks.)
For purposes of illustration, a trivial (and non-robust) implementation of this would look like:
function createSpyObjs(interfaces) {
    var result = {};
    Object.keys(interfaces).forEach(function (k) {
        result[k] = jasmine.createSpyObj(k, interfaces[k]);
    });
    return result;
}

It's easy enough to add that as a helper function to achieve the above, but it would be nicer still if it came free in the box with Jasmine.
Any chance of getting this built into a future version of Jasmine? I'd be happy to handle the implementation (along with appropriate input-checking and ""you're using it wrong"" warnings), if this is something that project maintainers feel is appropriate to include.",VWoeltjen,NONE,2014-11-26 02:14:36+00:00,True,2015-01-20 00:13:12+00:00,54.92,,2,2,2014-11-26 23:50:46+00:00,0.9,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
714,beforeAll/afterAll methods cause errors with Angular,"I've posted this issue on Angular, but to be honest I'm not sure if it's a problem with Jasmine or a problem on Angular's side. You can see the issue here angular/angular.js#10238
When using beforeAll or afterAll methods, I encounter the following errors when testing with Angular.
TypeError: 'null' is not an object (evaluating 'currentSpec.$modules')
        at workFn (/Users/chesleybrown/Sites/bln-web/app/components/angular-mocks/angular-mocks.js:2323)
        at /Users/chesleybrown/Sites/bln-web/node_modules/karma-jasmine/lib/boot.js:71
        at /Users/chesleybrown/Sites/bln-web/node_modules/karma-jasmine/lib/adapter.js:174
        at http://localhost:9876/karma.js:185
        at http://localhost:9876/context.html:168
    TypeError: 'null' is not an object (evaluating 'currentSpec.$modules')
        at workFn (/Users/chesleybrown/Sites/bln-web/app/components/angular-mocks/angular-mocks.js:2323)
        at /Users/chesleybrown/Sites/bln-web/node_modules/karma-jasmine/lib/boot.js:71
        at /Users/chesleybrown/Sites/bln-web/node_modules/karma-jasmine/lib/adapter.js:174
        at http://localhost:9876/karma.js:185
        at http://localhost:9876/context.html:168
    Expected { 0: HTMLNode, length: 1, prevObject: { 0: HTMLNode, length: 1 }, context: undefined, selector: '.loading-indicator' } to have class 'ng-hide'.
    Error: Expected { 0: HTMLNode, length: 1, prevObject: { 0: HTMLNode, length: 1 }, context: undefined, selector: '.loading-indicator' } to have class 'ng-hide'.
        at /Users/chesleybrown/Sites/bln-web/test/directives/about-product.directive.spec.js:40
        at /Users/chesleybrown/Sites/bln-web/node_modules/karma-jasmine/lib/boot.js:71
        at /Users/chesleybrown/Sites/bln-web/node_modules/karma-jasmine/lib/adapter.js:174
        at http://localhost:9876/karma.js:185
        at http://localhost:9876/context.html:168",chesleybrown,NONE,2014-11-27 02:29:39+00:00,True,2014-11-27 06:04:37+00:00,0.15,,2,1,2014-11-27 06:04:37+00:00,0.15,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
715,jasmine.any() method for matching only simple objects,"I ran into the issue of jasmine.any(Object) returning true for all types of objects including, but not limited to, Arrays. This is of course natural since Javascript Arrays are also Objects, but what if I want to assert that an object is, in fact, a simple object and not an array.
Example:
var foo = {a: 2};
var bar = ['a', 2];
expect(foo).toEqual(jasmine.any(Object)); // -> ok!
expect(bar).toEqual(jasmine.any(Object)); // -> also ok! I'd like it to fail here.

I'm not proposing a change to the jasmine.any(Object) function, but is there a way to extend the behaviour of jasmine.any() to support checking that an object is a simple object and not, for example, an array?
More specifically, what I want to achieve is something like this
var data = {
  name: 'Foo',
  props: {},
  props2: []
};
expect(data).toEqual(jasmine.objectContaining({
  name: jasmine.any(String),         // ok!
  props: jasmine.any(Object),        // should be ok
  props2: jasmine.any(Object)        // should fail here, since props2 is an array
}));

Any ideas how to achieve this without modifying the behaviour of jasmine.any(Object)?",bostrom,NONE,2014-11-27 09:10:50+00:00,True,2015-02-28 00:06:36+00:00,92.62,,3,4,2014-11-29 04:48:29+00:00,1.82,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
716,Jasmine__TopLevel__Suite in error message,"In new version of jasmine we take suite with description Jasmine__TopLevel__Suite
What does mean Jasmine__TopLevel__Suite, why it was introduced and how we should remove it from error message?
Thanks!",maksimr,NONE,2014-11-27 19:30:18+00:00,True,2014-11-29 05:27:40+00:00,1.41,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
717,use object in function not defined,"when i define object in page(not defined in  my js file), my funtion call it, for example。
var testObj = {a :1, b:2};//in my php view page
//myjs
function test() {
return testObj.a;
};
when i write testCase:
describe('test variable', function() {
var testObj = {};
beforeEach(function() {
testObj.a = 1;
});
except(test()).toEqual(1);
});
when i test it, "" Can't find variable""
but base on functon context;
testObj  outer of  test() function.",memoryza,NONE,2014-11-28 08:09:58+00:00,True,2014-11-29 04:45:50+00:00,0.86,,2,1,2014-11-29 04:45:50+00:00,0.86,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
718,Make the Wiki Collaborators-only,"I was searching for documentation on async tests, and the first result on Google was the wiki page for it on this repo.
As you can see, a witty Internet user has ""Defaced"" the page. This is fairly bad, naturally, because it's the first Google result. What I'd recommend to stop this from happening is to restrict editing to collaborators only. This can be done on the settings page.
Thoughts?",basicallydan,NONE,2014-11-28 10:24:28+00:00,True,2014-11-29 03:25:42+00:00,0.71,,3,3,2014-11-28 20:53:47+00:00,0.44,christophetd,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
719,How about a bower configuration support for standalone?,,lastboy,NONE,2014-11-30 14:28:09+00:00,True,2015-01-27 01:53:48+00:00,57.48,,4,3,2014-12-26 01:50:56+00:00,25.47,slopetown,NONE,0,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
720,Need Access to SpyStrategy plan,I'm working on upgrading a jasmine helper called jasmine-stealth to support jasmine 2.x. One of the issues I'm having is accessing the SpyStrategy plan. Adding a function to expose plan would be helpful. Would you be interested in a pull request?,longmatthewh,NONE,2014-12-01 02:48:21+00:00,True,2018-03-30 00:18:01+00:00,1214.9,,7,13,2014-12-01 21:22:20+00:00,0.77,slackersoft,MEMBER,1,0,0,5,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
721,use custom matchers in beforeAll,"Hi,
Thanks for making beforeAll and afterAll available, I was really looking forward to it.
Unfortunately, because I would like to do some sanity checks in the beforeAll, the custom matchers, which I load in beforeEach, aren't loaded yet (because beforeAll is, if I'm correct, called earlier).
example:
beforeAll(function()
{
    setCertainThings();
    expect(certainThings).toMeetMyCustomMatchersCondition();
 } );

I wonder what would be a good solution here, as loading them in beforeAll as well, seems a bit hacky.
Would it be an idea to have something like jasmine.register(matcher).
It would keep the beforeEach a bit cleaner anyways.",lenntt,NONE,2014-12-04 16:22:38+00:00,True,2014-12-17 01:52:35+00:00,12.4,,4,5,2014-12-04 19:05:50+00:00,0.11,Gerg,CONTRIBUTOR,1,2,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
722,Test AngularJS $http promise without mock,"Hi,
I'm creating the testing for an AngularJS / NodeJs application, the front-end application is fully implemented with AngularJS and the back-end is on NodeJS that exposes and API consumed by the AngularJS $http service.
The problem that I'm having is that I have an AngularJS service that calls the NodeJS API with $http (Async Promise) and when I run my Jasmine spec nothing happens, no http calls to the API. I searched and I found that we should mock the response with $httpBackend or Spy but in my case I really want the real call and not a mock since the AngularJS is just a Facade of http calls.
It's possible to call the API without mocking the responses and receive the real responses of the server?
Thanks
Best Regards,
Fábio Correia",fabiodcorreia,NONE,2014-12-04 19:16:35+00:00,True,2014-12-04 20:44:59+00:00,0.06,,2,1,2014-12-04 20:44:59+00:00,0.06,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
723,If I match a stringified object to the original object it passes. Is this the expected behavior?,"Hello there, I just discovered a false positive on my test suite. I was matching a stringified object to the original object, and it was supposed to fail, but as you can see here, it's passing.
var foo = {""bar"": ""hello""};

describe(""foo"", function() {
  // passes
  it(""string toMatch object"", function() {
      expect(JSON.stringify(foo)).toMatch(foo);
  });

  // fails
  it(""object toMatch string"", function() {
      expect(foo).toMatch(JSON.stringify(foo));
  });
});
My question is, is this the expected behavior?",Zequez,NONE,2014-12-04 23:40:03+00:00,True,2014-12-16 19:52:00+00:00,11.84,,2,2,2014-12-05 00:12:34+00:00,0.02,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
724,xdescribes appears to break test reporting,"This produces the expected output in the browser:
describe(""foo"", function() {
  xdescribe(""bar"", function() {
    describe(""baz"", function() {
      it(""does appear"", function() {
        expect(true).toBeFalsy();
      })
    });
  });
});
Whereas the following does not have the HTML report:
describe(""foo"", function() {
  describe(""bar"", function() {
    xdescribe(""baz"", function() {
      it(""does not appear"", function() {
        expect(true).toBeFalsy();
      })
    });
  });
});",chendrix,NONE,2014-12-09 00:09:37+00:00,True,2014-12-09 20:40:59+00:00,0.86,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
725,2.1.3 standalone missing?,I was taking a look at the release page and noticed that the 2.1.3 standalone download is missing. Was that intentional or an oversight?,joshuacc,NONE,2014-12-09 16:44:29+00:00,True,2014-12-09 20:37:54+00:00,0.16,,3,3,2014-12-09 17:29:01+00:00,0.03,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
726,.npmignore should contain at least .sass-cache and .idea,"Sorry, I'm in hurry so I don't provide a pull request. I've downloaded v2.1.3 via npm and it contains directories most users won't need, especially .sass-cache and .idea.
BTW thanks for your work!",hgoebl,NONE,2014-12-11 17:32:30+00:00,True,2014-12-11 20:49:59+00:00,0.14,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
727,Adding a window.onload handler hangs jasmine,"I've a source script which has an assignment statement to window.onload. Whenever I run the test using phantomjs, it just hangs without any output and browser does not exit. To narrow down the problem, I just downloaded fresh copy of jasmine-standalone-2.1.3.zip, unzipped and opened SpecRunner.html in my browser and it worked fine.
I edited SpecRunner.html with the following:
 <script src=""lib/jasmine-2.1.3/boot.js""></script>

  <script type=""text/javascript"">
    window.onload = function() { alert(""onload""); };
  </script>
  <!-- include source files here... -->
  <script src=""src/Player.js""></script>
  <script src=""src/Song.js""></script>
After this if I open SpecRunner.html, it displays nothing. I'm getting the alert though. But jasmine seems to have crashed/hanged.
I'm using Chrome on MAC OS X 10.10.
Can you please help?",venustus,NONE,2014-12-14 04:15:09+00:00,True,2014-12-17 03:23:29+00:00,2.96,,3,3,2014-12-16 01:16:56+00:00,1.88,slackersoft,MEMBER,1,0,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
728,Missing option on jasmine documentation related to running tests,"As far as I can see  in all documentations (all versions) you mention xit and xdescribe are for disabling  particular spec and suite. You forgot to mention that iit and ddescribe allow you to run only this spec or this suite.
Can you please add it because when someone is learning jasmine he is not aware of that functionality and could lose a day to find it out.",ghristov,NONE,2014-12-17 15:45:16+00:00,True,2014-12-17 17:13:34+00:00,0.06,,2,3,2014-12-17 17:13:34+00:00,0.06,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
729,Comparing object with null prototype and objects derived from Object,"Should the following test pass? Currently it fails but IMHO I think it should pass. The reason is both the objects have the same keys. However objA is lacking a hasOwnProperty method which is why I think the test fails. However shouldn't that throw an exception?
How about two objects with null prototypes? The second test should pass right? It's complaining that the object doesn't have hasOwnProperty method which I expected for the first test also. I'm guessing using Object.hasOwnProperty.call(obj, property) should do the trick to make the second test work and pass. However should the first test pass or fail? I'm new to Javascript so I wasn't sure but I'd be happy to work on a PR if required. 😄
describe(""Prototypeless Object"", function() {
    it(""should equal regular obj with same keys"", function () {
        var objA = Object.create(null);
        var objB = {};

        objA['name'] = 'Rohit';
        objB['name'] = 'Rohit';
        expect(objA).toEqual(objB);
    });

    it(""should equal obj with null prototype"", function () {
        var objA = Object.create(null);
        var objB = Object.create(null);

        objA.name = 'Rohit';
        objB.name = 'Rohit';

        expect(objA).toEqual(objB);
    });
});
The test fails with the following failure message:
Failures:
1) Prototypeless Object should equal obj with same keys
  Message:
    Expected { name: 'Rohit' } to equal { name: 'Rohit' }.
  Stack:
    Error: Expected { name: 'Rohit' } to equal { name: 'Rohit' }.
        at Object.<anonymous> (/home/rohit/Code/prototypeless-obj/spec/obj.spec.js:9:22)

2) Prototypeless Object should equal obj with null prototype
  Message:
    TypeError: Object object has no method 'hasOwnProperty'
  Stack:
    TypeError: Object object has no method 'hasOwnProperty'
        at Object.<anonymous> (/home/rohit/Code/prototypeless-obj/spec/obj.spec.js:19:22)

EDIT 1: Added the output of a test run.
EDIT 2: Added one more test case for both objects with null prototype",rohit,CONTRIBUTOR,2014-12-18 05:07:47+00:00,True,2014-12-21 00:49:01+00:00,2.82,,2,4,2014-12-18 21:40:50+00:00,0.69,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
732,beforeAll/afterAll don't work with focused specs,"beforeAll and afterAll will run once per spec (like beforeEach and afterEach) when you use focused specs:
describe('focused spec', function() {
  var passed;

  beforeAll(function() {
    console.log('beforeAll')
    passed = 0;
  });

  afterAll(function() {
    console.log('afterAll')
    expect(passed).toEqual(2);
  });

  iit('should pass1', function() {
    ++passed;
  });

  iit('should pass3', function() {
    ++passed;
  });
});

The output is:
beforeAll
afterAll
FbeforeAll
afterAll
F

Failures: 
1) focused spec should pass1
1.1) Expected 1 to equal 2.
    Error: Expected 1 to equal 2.
        at Object.<anonymous> (/workspace/minijasminenode/spec/focused_spec.js:11:20)

2) focused spec should pass3
2.1) Expected 1 to equal 2.
    Error: Expected 1 to equal 2.
        at Object.<anonymous> (/workspace/minijasminenode/spec/focused_spec.js:11:20)

2 specs, 2 failures
Finished in 0.007 seconds",hankduan,NONE,2014-12-23 19:59:33+00:00,True,2015-01-20 00:21:39+00:00,27.18,,6,13,2014-12-23 20:10:08+00:00,0.01,Gerg,CONTRIBUTOR,1,1,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
733,Double-nested xdescribe breaks entire spec,"This spec doesn't work with default SpecRunner.html on 2.1.3:
describe('1st', function() {
    describe('2nd', function() {
        xdescribe('3rd', function() {
            it('works', function() {
                expect(true).toBe(true);
            });
        });
    });

    it('works', function() {
        expect(true).toBe(true);
    });
});
When I change xdescribe to describe it works fine.",chge,NONE,2014-12-24 15:49:25+00:00,True,2015-01-13 06:19:26+00:00,19.6,,3,3,2014-12-24 18:32:45+00:00,0.11,slackersoft,MEMBER,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
734,Ability to pass stack trace into `fail`,"The current implementation allows an error to be passed into done.fail/this.fail, but it only reads the message from the error:
    this.fail = function(error) {
      var message = 'Failed';
      if (error) {
        message += ': ';
        message += error.message || error;
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message
      });
    };
For framework development and especially for asynchronous code, it would be very useful to allow us to pass in a custom stack trace. For example/one use case, if I have a spec like this:
it('fail', function(done) {
  done.fail('an error');
});
The stack trace does not tell you which line in the spec file failed, making it hard to debug, and I would like to patch it by passing in a custom stack.",hankduan,NONE,2015-01-03 04:41:41+00:00,True,2015-01-12 19:52:19+00:00,9.63,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
735,Possibly confusing failure message by toThrow and toThrowError matchers,"1) Hamming throws error when strands are not equal length
  Message:
    Expected function to throw Error: DNA strands must be of equal length., but it threw Error: DNA strands must be of equal length.

The above failure message is confusing because the two error strings look alike. The actually thrown error is missing a full stop: ""DNA strands must be of equal length"". This is while running jasmine via CLI in node.
IMHO this should give a non confusing error message but I don't know what should be done. On the one hand the full stop could be removed from the error message but then the message is different in style from the others. I think the following output would be better:
1) Hamming throws error when strands are not equal length
  Message:
    Expected function to throw
      Error: DNA strands must be of equal length.
    but it threw
      Error: DNA strands must be of equal length

By splitting the message over multiple lines I think we can remove the full stop from the error message.
Another option, as suggested by @joshuacc, is to surround the error text with quotations.
1) Hamming throws error when strands are not equal length
  Message:
    Expected function to throw ""Error: DNA strands must be of equal length."", but it threw ""Error: DNA strands must be of equal length""

This might be the simplest although splitting onto multiple lines does look nice IMHO. 😁
EDIT ~5 mins: Added suggestion to surround by quotes",rohit,CONTRIBUTOR,2015-01-05 15:23:46+00:00,True,2015-04-09 22:33:24+00:00,94.3,,3,6,2015-01-05 15:25:30+00:00,0.0,joshuacc,NONE,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
737,SpyRegistry clearSpies() puts inherited methods onto target prototype,"One of the issues we're having migrating tests from JSTestDriver with sinon to with Jasmine is that we cannot run our tests in a randomised order.
This is rooted in the use of inheritance and the way in which Jasmine returns spied on function back to their original values (I don't want to get into a debate on composition over inheritance at this stage, I probably agree with you).
What happens is when we have a function on the prototype that comes from a superclass n levels up (we're currently using a variant of resig's Class()), jasmine takes a copy of the original based on it as being a member of the subclass. https://github.com/jasmine/jasmine/blob/master/src/core/base.js#L60
In clearSpies() it returns the value back onto the subclass -
https://github.com/jasmine/jasmine/blob/master/src/core/SpyRegistry.js#L43
This unfortunately hides the superclass behaviour which is breaking our other tests when not run in specific orders.
There are three possible solutions to this.

Check for hasOwnProperty when creating the spy and throw an exception when the property does not exist.
return the function back to the superclass only
do nothing.

I have potential solutions for 1 and 2 and wonder what the community thinks is the best approach before I put in a PR.
option 3 suggests this is not really a problem - and I'd be interested in hearing arguments as to whyu this is the case. Genuinely,
Rich",coderagebbc,NONE,2015-01-11 15:04:20+00:00,True,2016-02-22 22:11:50+00:00,407.3,,3,5,2015-01-12 20:05:27+00:00,1.21,slackersoft,MEMBER,1,0,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
738,"toMatch(""url(./a.png)"") is no match","hi.
css=""url(./a.png)""
expect(css).toMatch(""url(./a.png)"")
// > Expected 'url(./a.png)' to match 'url(./a.png)'.
This behavior is expected?
replaced
expect(css.indexOf(""url(./a.png)"")).toBeTruthy() // passed",59naga,NONE,2015-01-11 20:57:13+00:00,True,2015-01-12 17:59:40+00:00,0.88,,2,2,2015-01-12 06:41:09+00:00,0.41,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
739,Please mention browser support in readme & website,"Thanks for Jasmine.
Can you please add a note?",mightyiam,NONE,2015-01-12 15:54:33+00:00,True,2015-01-12 19:08:20+00:00,0.13,,1,2,2015-01-12 15:55:25+00:00,0.0,mightyiam,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
740,Does jasmine provide `expect`?,sindresorhus/globals#13,mightyiam,NONE,2015-01-12 16:57:50+00:00,True,2015-01-12 18:16:54+00:00,0.05,,2,2,2015-01-12 17:30:52+00:00,0.02,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
741,`they` method to have multiple test cases for a single test,"We have this in our code and it makes it really easy to setup dozens of test for a simple case. I can provide a PR, just wanted to start the discussion here to gather interest.
Basically (our code is ES6, but it's simple enough to backport to ES5):
/**
 * Internal helper for generating the proper function.
 */
function _itMultipleTestsInternal(it) {
    return function(description, cases, fn) {
        if (typeof(description) == 'string') {
            let prefix = description;
            description = function(i, kase) {
                return `${prefix} (${i}) - ""${JSON.stringify(kase)}""`;
            };
        }

        // Determine if `fn` should receive a done parameter.
        let done = fn.length > 1;

        cases.forEach((kase, i) => {
            let tester = done ? (done) => fn(kase, done)
                              : () => fn(kase);

            it(description(i, kase), tester);
        });
    };
}


/**
 * Generates an `it()` test case for every cases passed in the array.
 * @example
 *     let cases = [99, 'hello', NaN];
 *     they('Test numbers', cases, (nb) => {
 *         expect(typeof(nb)).toBe('number');
 *     });
 *     // This is equivalent to:
 *     //     it('Test numbers (1)', function() { expect(typeof(99)).toBe('number'); });
 *     //     it('Test numbers (2)', function() { expect(typeof('hello')).toBe('number'); });
 *     //     it('Test numbers (3)', function() { expect(typeof(NaN)).toBe('number'); });
 *
 * @param description string|Function A prefix string or a function that will receive
 *     a Number (index of the case), and a case value, and return a string of the description
 *     of the test.
 * @param cases Array<Any> An array of values to pass to the function to test.
 * @param fn Function A function that will receive the value of the array for the test,
 *     and a potential `done` function. The `done` function is passed only if `fn` takes
 *     two arguments.
 */
window['they'] = _itMultipleTestsInternal(window['it']);


/**
 * Same as above, but using `fit()` instead of `it()`.
 */
window['fthey'] = _itMultipleTestsInternal(window['fit']);


/**
 * Same as above, but using `xit()` instead of `it()`.
 */
window['xthey'] = _itMultipleTestsInternal(window['xit']);",hansl,NONE,2015-01-12 23:14:03+00:00,True,2015-01-13 00:40:45+00:00,0.06,,2,1,2015-01-13 00:40:45+00:00,0.06,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
742,Multi-line error messages are rendered in a weird order,"The following test:
it('test title', function () {
    jasmine.addMatchers({
        toAAA: function () {
            return {
                compare: function () {
                    return {
                        pass: false,
                        message: 'a\nb\nc\nd',
                    };
                },
            };
        },
    });
    expect(true).toAAA();
});
gives the following output:
Chrome 39.0.2171 (Mac OS X 10.10.1)  test title FAILED
    b
    c
    d
    Error: a
        at Object.<anonymous> (/PATH:column:row)
Chrome 39.0.2171 (Mac OS X 10.10.1): Executed 1 of 1 (1 FAILED) ERROR (0 secs / 0.038 secs)

i.e. lines from the second to the last one are printed first, then Error: and the first line of the message. This reads weirdly, especially if the second line is a continuation to the first. I'd expect the following:
Chrome 39.0.2171 (Mac OS X 10.10.1)  test title FAILED
    Error: a
    b
    c
    d
        at Object.<anonymous> (/PATH:column:row)
Chrome 39.0.2171 (Mac OS X 10.10.1): Executed 1 of 1 (1 FAILED) ERROR (0 secs / 0.038 secs)

I couldn't find any documentation about this behavior at http://jasmine.github.io/2.1/custom_matcher.html
OS X 10.10.1, native Terminal.app, Jasmine 2.1.3 fired via karma 0.12.31 and karma-jasmine 0.3.4, Node 0.10.35 and 0.11.14.",mgol,NONE,2015-01-12 23:50:24+00:00,True,2015-03-02 21:47:48+00:00,48.91,,2,2,2015-01-13 00:24:35+00:00,0.02,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
744,Add marker to indicate that you expect the test fail,From time to time we are developing our protractor/jasmine tests before implementing solution. We miss feature to be able to indicate that we expect the test fail. After desired solution will be implemented test really start failing because test start passing. All what implementer mast to do is remove indicator. Is implementing such thing is possible in jasmine?,jankoprowski,NONE,2015-01-14 10:05:18+00:00,True,2015-01-14 16:08:13+00:00,0.25,,3,2,2015-01-14 15:55:54+00:00,0.24,rohit,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
747,Warn when two tests have the same name.,"Apparently if I use describe and accidentally describe the same string twice, one of the describe calls is overridden.
Jasmine should throw an error and tell me to fix my names. It is bad if you copy and paste one test as a template, and forget to change its name, and wonder why the previous test is failing, only to find out it was overridden.",jacksonrayhamilton,NONE,2015-01-16 02:16:53+00:00,True,2015-01-18 23:07:13+00:00,2.87,,2,3,2015-01-17 02:13:15+00:00,1.0,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
748,toThrow fails on PhantomJS but works good on Chrome and Firefox,"OS: Windows 8.1 x64
Browsers:

Chrome 39.0.2171 (Windows 8.1)
Firefox 35.0.0 (Windows 8.1)
PhantomJS 1.9.8 (Windows 8)

Stack:

node: 0.10.33 (x64)
karma: 0.12.31
karma-jasmine: 0.3.4
jasmine: 2.1.1

The error message:

Error: Expected function to throw { code: 500, name: 'generic error', message: 'error message' }, but it threw { code: 500, name: 'generic error', message: 'error message', line: 9, sourceId: 84165968, sourceURL: 'c:/***/ApiRequest.js', stack: '[object Object]

Expected: SUCCESS
Spec:
      var expectedError = new API.Ws.Errors.ValidationError(
        500,
        ""generic error"",
        ""error message""
      );
      expect(function () {
        ApiRequest.testForLogicalError(response)
      }).toThrow(expectedError);
SUS:
// API.Ws.Errors.ApiLogicErrror.js
var API;
(function (API) {
    var Ws;
    (function (Ws) {
        var Errors;
        (function (Errors) {
            ""use strict"";
            var ApiLogicError = (function () {
                function ApiLogicError(code, name, message) {
                    this.code = code;
                    this.name = name;
                    this.message = message;
                }
                return ApiLogicError;
            })();
            Errors.ApiLogicError = ApiLogicError;
        })(Errors = Ws.Errors || (Ws.Errors = {}));
    })(Ws = API.Ws || (API.Ws = {}));
})(API || (API = {}));

// API.Ws.Errors.ValidationErrror.js
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var API;
(function (API) {
    var Ws;
    (function (Ws) {
        var Errors;
        (function (Errors) {
            ""use strict"";
            var ValidationError = (function (_super) {
                __extends(ValidationError, _super);
                function ValidationError(code, name, message, messages) {
                    _super.call(this, code, name, message);
                    this.messages = messages;
                }
                return ValidationError;
            })(Errors.ApiLogicError);
            Errors.ValidationError = ValidationError;
        })(Errors = Ws.Errors || (Ws.Errors = {}));
    })(Ws = API.Ws || (API.Ws = {}));
})(API || (API = {}));",Maks3w,NONE,2015-01-16 13:20:48+00:00,True,2015-04-10 19:02:59+00:00,84.24,,2,6,2015-01-17 02:21:24+00:00,0.54,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
749,Testing async features that can't receive a done() callback,"I have authored a very simple preCondition instruction for Jasmine 2.0's way of async testing.
I found it necessary for some types of asynchronous features that will complete on their own and won't allow the user to pass a callback where done would be fired, like rendering Google Maps, images or anything else that can change both the DOM and the CSSOM.
While it is utterly possible to re-implement waitsFor, I believe that Jasmine 2.0 direction is more towards stepping away from this idea and instead taking more advantage of done callbacks, like putting one it block as a pre-condition for another.
I would love to receive some feedback from you guys to see if you agree with this approach. It is available here https://github.com/tiagorg/jasmine-precondition and also on NPM.
And if you ever feel like this idea can evolve towards something getting incorporated into the official Jasmine library, I would love to chip in as well :)
With the preCondition it would be possible to do something like: (I can provide a Google Maps example as well)
describe('the preCondition instruction', function () {

  var counter1 = 0,
      counter2 = 0,
      interval;

  beforeEach(function(done) {
    interval = setInterval(function(){
      counter1 += 100;
    }, 100);

    preCondition(function() {
      return counter1 >= 500;
    }, done, 100);
  });

  it('should only get executed when counter1 is 500', function (done) {
    expect(counter1).toBe(500);

    preCondition(function() {
      counter2 += 200;
      return counter2 === 1000;
    }, done, 100);
  });

  it('should only get executed when counter2 is 1000', function () {
    expect(counter2).toBe(1000);
  });

  afterEach(function(){
    clearInterval(interval);
  });
});",themindfuldev,NONE,2015-01-17 23:05:32+00:00,True,2015-01-19 23:59:09+00:00,2.04,,4,5,2015-01-19 23:59:09+00:00,2.04,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
750,fail() should report the stack of a passed in error object,"When you call fail(error), a stack trace is generated where fail() is called, and this gets reported. Since in fail you're looking for an error.message, we should also look for an error.stack, and if present use that in the expectationResult.
    this.fail = function(error) {
      var message = 'Failed';
      if (error) {
        message += ': ';
        message += error.message || error;
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message
      });
    };
Becomes
    this.fail = function(error) {
      var message = 'Failed';
      if (error) {
        message += ': ';
        message += error.message || error;
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        // pass the error object through if it has a stack
        error: error.stack ? error : null
      });
    };
The reason for this change is that I want to report exceptions in promises chains:
describe(""async test"", function() {
  it(""returns data"",function(done) {
    somethingThatReturnsAPromiseButCouldError().then(function(data) {
      expect(data).toBeTruthy();
      done();
    },function(error) {
      fail(error); // stack trace will be here, not inside somethingThatReturnsAPromiseButCouldError()
      done();
    });
  });
});",william-tran,NONE,2015-01-19 01:32:33+00:00,True,2015-01-19 16:46:12+00:00,0.63,,1,1,2015-01-19 16:46:12+00:00,0.63,william-tran,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
751,SpiderMonkey 24 compatibility,"I'm working on a Jasmine runner for the GJS interpreter (whose engine is SpiderMonkey 24) and when it loads the Jasmine core it complains about a few things:
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 481]: anonymous function does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 638]: anonymous function does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 742]: anonymous function does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 995]: function Clock does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 1109]: function DelayedFunctionScheduler does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 1387]: function buildExpectationResult does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 1474]: function FakeDate does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 1437]: function MockDate does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 1686]: anonymous function does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 1764]: function ReportDispatcher does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 2280]: function asymmetricMatch does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 2299]: function eq does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 2223]: anonymous function does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 2760]: function toThrowError does not always return a value
Gjs-Message: JS WARNING: [/Users/fliep/gtk/inst/share/jasmine-gjs/jasmine.js 72]: assignment to undeclared variable getJasmineRequireObj

At several places in Jasmine there's a return statement followed by more code, which is mainly what it's complaining about. The code following the return seems to be just functions, so it's harmless, but it would be nice to get rid of the complaints.
The final line is complaining about a variable that isn't declared with var in requireCore.js.
In addition, Jasmine's timers don't work as expected because jasmineGlobal doesn't get set properly in getJasmineRequireObj(). I think for SpiderMonkey the code should check for the existence of window just like it does for global in node.js.
I'll prepare a pull request for both of these compatibility problems.",ptomato,CONTRIBUTOR,2015-01-20 06:10:31+00:00,True,2015-02-03 03:32:50+00:00,13.89,,3,6,2015-01-23 21:41:01+00:00,3.65,slackersoft,MEMBER,1,2,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
753,Reporter should receive number of specs to be run,"Reporters' jasmineStarted() method is called with an object that looks like this:
{
     totalSpecsDefined: 200
}
However, this isn't an accurate number of specs to be run. For example, if there are focused specs, then there are far fewer run than are reported as defined.
It would be convenient for this object to report the number of specs that are expected to be run - so that a TAP reporter could output a test plan at the beginning of the suite, for example.
An alternative would be to call specStarted() and specDone() for each unfocused spec so the reporter would know the specs were there, but got skipped.",ptomato,CONTRIBUTOR,2015-01-20 06:50:01+00:00,True,2015-03-05 06:09:16+00:00,43.97,,2,3,2015-01-23 20:55:27+00:00,3.59,slackersoft,MEMBER,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
754,Programmatically adding tests?,"Hi,
Just run into a bit of an issue and can't see a way to implement it using jasmine at the moment... was wondering if you could help.
I have a master detail kindof setup in an webapp I'm working on.  It consists of a list of Fields, when you select one you then see a list of options.  I'd like to write a check that for every field the list of options is sorted alphabetically.  I'd also not like to specify all the Fields for two reasons - there is quite a few of them; and that I would like this test to apply to future fields without having to do more work.
So I'd like to generate some tests from a list of these Fields dynamically.  I thought this would be easy in jasmine because it, describe etc are just functions... however the snag here seems to be that I need to load the list of fields asynchronously first.
In a describe I can't provide a done function to make it hang around for the list to come back and in a beforeEach/beforeAll calling it doesnt seem to work... it also wont be called at all unless I already have at least one it.
Is there anyway I can achieve this at the moment?  I'd guess so but it feels like maybe not.",JonnyRa,NONE,2015-01-20 10:21:36+00:00,True,2015-01-20 17:31:28+00:00,0.3,,2,3,2015-01-20 12:52:41+00:00,0.1,JonnyRa,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
755,Ubuntu: `bundle` fails to complete; error while installing the ffi gem,"Maybe this should go in the CONTRIBUTING file:
when running the bundle command on Ubuntu (version: 14.04.1 LTS) it crashes and fails to install the ffi gem because it 'failed to build native gem extension'.
A little google action located this for another project and another Linux distro: wpscanteam/wpscan#92
which for Ubuntu translates to this:
# apt-get install gcc ruby ruby-dev libxml2 libxml2-dev  libxslt1-dev
# gem install ffi
which should now build the required ffi gem without throwing any more errors.
Then rerun the bundle command as described in the CONTRIBUTING.md document.",GerHobbelt,NONE,2015-01-20 23:19:44+00:00,True,2015-01-21 20:55:27+00:00,0.9,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
756,Is it possible to use 'beforeEach(module('app'))' code on separated external file?,"For example:
Testing AngularJS code with the Jasmine.
app_helper.js
   beforeEach(module('adminApp'));

app_test_controller_spec.js.coffee
describe 'TestController', ->
    scope = $location = controller = undefined
    beforeEach inject ($rootScope, $controller, _$location_) ->
        $location = _$location_
        scope = $rootScope.$new()
        controller = $controller 'TestController', {
            '$scope': scope
        }

    it 'should success', ->
        expect(2).toEqual(3)

Currently this code not works.
Is another way to use 'beforeEach(module('app'))' code on separated external file?",joowh85,NONE,2015-01-25 02:35:11+00:00,True,2015-01-26 19:21:38+00:00,1.7,,2,1,2015-01-26 19:21:38+00:00,1.7,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
758,beforeAll gets called multiple times,"Hi,
I am using Jasmine2 with protractor.
When I define a beforeAll like this:
var beforeAllFunction = function(done){
    console.log('before');
    done();
};

fdescribe('test', function () {

    beforeAll(beforeAllFunction);

    it(""this"", function (done) {
        console.log('test');
        done();
    });
});

I get a log like this
before
before
test

my tests rely on beforeAll getting called ONCE and not more. Right now I have a  workaround, but this seems strange.",,NONE,2015-01-27 11:23:28+00:00,True,2015-01-27 13:19:41+00:00,0.08,,2,2,2015-01-27 13:17:55+00:00,0.08,amavisca,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
759,Update to Jasmine Test Framework (JasmineTest) NuGet package,"Currently Nuget only shows JasmineTest version 2.0.0 whereas the Jasmine Github shows 2.1.3 released on December 4th 2014. Please update the NuGet version of JasmineTest to the latest version along with its TypeDefinitions (DefinitelyTyped/DefinitelyTyped#3522).
Thanks",abulhasanlakhani,NONE,2015-01-27 21:14:39+00:00,True,2015-01-27 21:32:36+00:00,0.01,,2,1,2015-01-27 21:32:36+00:00,0.01,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
760,Run `afterAll` and `afterEach` even after spec failure,"I think the afterAll and afterEach should run even if the spec fails. Sometimes its needed to because we might be doing some clean up work inside after and afterEach functions.
Example would be:
Let say I am testing a module which copies a directory recursively into a different directory. Now after the test is over I want to delete the newly created a directory as a cleanup.
Its like in the database world, when you test you manipulate the data inside the tables but when your test finishes you always rollback the changes regardless of failure or success.",gyandeeps,NONE,2015-01-27 22:25:54+00:00,True,2015-01-28 00:06:04+00:00,0.07,,2,2,2015-01-27 23:49:41+00:00,0.06,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
761,toEqual comparison bug,"Expected
[[{
    id_voucher: 1,
    affiliate_mode: 0,
    exclusive_voucher: 1,
    editors_pick: 1,
    caption_1: [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined],
    end_time: '2015-12-17 03:24:00',
    image: '/images/n/notebooksbilliger-de-gutscheincode_logo_2.png',
    cssClass: ['code', 'exclusive', 'editor_pick', 'custom-text'],
    captionCssClass: ['small'],
    specialCssClass: ['special', 'editor-pick'],
    verifiedDiff: false,
    isAffiliate: true,
    isExclusive: true,
    isEditor: true,
    specialTextKey: false,
    expireDiff: 322
}, {
    id_voucher: 1,
    affiliate_mode: 0,
    exclusive_voucher: 1,
    editors_pick: 1,
    caption_1: [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined],
    end_time: '2015-12-17 03:24:00',
    image: '/images/n/notebooksbilliger-de-gutscheincode_logo_2.png',
    cssClass: ['code', 'exclusive', 'editor_pick', 'custom-text'],
    captionCssClass: ['small'],
    specialCssClass: ['special', 'editor-pick'],
    verifiedDiff: false,
    isAffiliate: true,
    isExclusive: true,
    isEditor: true,
    specialTextKey: false,
    expireDiff: 322
}]]
to
equal
[[{
    id_voucher: 1,
    affiliate_mode: 0,
    exclusive_voucher: 1,
    editors_pick: 1,
    caption_1: [undefined, undefined, undefined, undefined, undefined, undefined, undefined],
    end_time: '2015-12-17 03:24:00',
    image: '/images/n/notebooksbilliger-de-gutscheincode_logo_2.png',
    cssClass: ['code', 'exclusive', 'editor_pick', 'custom-text'],
    captionCssClass: ['small'],
    specialCssClass: ['special', 'editor-pick'],
    verifiedDiff: false,
    isAffiliate: true,
    isExclusive: true,
    isEditor: true,
    specialTextKey: false,
    expireDiff: 322
}, {
    id_voucher: 1,
    affiliate_mode: 0,
    exclusive_voucher: 1,
    editors_pick: 1,
    caption_1: [undefined, undefined, undefined, undefined, undefined, undefined, undefined],
    end_time: '2015-12-17 03:24:00',
    image: '/images/n/notebooksbilliger-de-gutscheincode_logo_2.png',
    cssClass: ['code', 'exclusive', 'editor_pick', 'custom-text'],
    captionCssClass: ['small'],
    specialCssClass: ['special', 'editor-pick'],
    verifiedDiff: false,
    isAffiliate: true,
    isExclusive: true,
    isEditor: true,
    specialTextKey: false,
    expireDiff: 322
}]]
Its failing i wrote comparison algorithm which is solving problem:
function compare(a, b) {
    if (typeof a === 'string') {
        return a === b;
    } else if (typeof a === 'number') {
        if (isNaN(a) || isNaN(b)) {
            return isNaN(a) === isNaN(b);
        }
        return a === b;
    } else if (typeof a === 'boolean') {
        return a === b;
    } else if (isDate(a) && isDate(b)) {
        return a.getTime() === b.getTime();
    } else if (isRegExp(a) && isRegExp(b)) {
        return a.source === b.source;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        // check references first
        if (a === b) {
            return true;
        }
        return a.every(function (item, index) {
            try {
                return compare(item, b[index]);
            } catch (e) {
                console.log('recursion problem', e);
                return false;
            }
        });
    } else if (typeof a === 'object' && typeof b === 'object') {
        var equal = [];
        // check references first
        if (a === b) {
            return true;
        }
        try {
            for (var key in a) {
                equal.push(compare(a[key], b[key]));
            }
        } catch (e) {
            console.log('recursion problem', e);
            equal.push(false);
        }
        return equal.every(function (item) {
            return item === true;
        });
        /// compare undefined and nulls and nans
    } else if (a === b) {
        return true;
    }

    return false;




    function isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }

    function isRegExp(value) {
        return Object.prototype.toString.call(value) === '[object RegExp]';
    }
}",,NONE,2015-01-29 10:59:20+00:00,True,2015-01-29 17:20:23+00:00,0.26,,1,1,2015-01-29 17:20:23+00:00,0.26,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
762,why this project named jasmine?,why this project named jasmine?,kimmking,NONE,2015-01-31 12:54:37+00:00,True,2015-01-31 23:34:32+00:00,0.44,,2,1,2015-01-31 23:34:32+00:00,0.44,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
765,Jasmine 2.2 regression - Arrays from different frames are no longer equivalent,"With changes to the eq function in jasmine/src/core/matchers/matchersUtil.js since 2.1, arrays from different frames are no longer equivalent.",juliemr,NONE,2015-02-03 19:46:39+00:00,True,2015-02-04 17:39:27+00:00,0.91,,2,7,2015-02-03 19:49:00+00:00,0.0,infews,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
766,Pretty Printer should be updated to reflect changes in Array comparison.,"While toEqual() has been updated to compare custom properties on arrays. Pretty printer is only looping from 0 to length, this is bound to cause confusion, as you can have unequal values display exactly the same.",jamestalmage,NONE,2015-02-03 21:03:16+00:00,True,2015-02-04 19:05:46+00:00,0.92,,4,6,2015-02-03 21:15:08+00:00,0.01,jwngr,NONE,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
769,v2.2 jasmine.objectContaining doesn't work with Object.defineProperty,"I'm using TypeScript to create classes. The properties are added with Object.defineProperty. When I update from Jasmine 2.0 to 2.2 my test started failing. This same test passes in v2.0.
Here's my test:
var myObject = (function () {
            function myObject(id){
                this.a = ['a','b','c'];
                this.empty = [];
                this._id = id;
                this.update = function(differentT){
                    // pretend this is a real function to spyOn

                }
            };
            return myObject;
         })();
        Object.defineProperty(myObject.prototype, ""id"", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
describe(""Object containing and toHaveBeenCalledWith"", function() {

    it('objectContains matcher with property', function(){
        var t2 = new myObject(444);
        spyOn(test, 'update');
        test.update(t2);
        expect(test.update).toHaveBeenCalledWith(jasmine.objectContaining({ id: 444 }));
    });
});
Is there a workaround or can the equality be improved?
Object.prototype.hasOwnProperty.call(other, property) is false in the expect above
Extra Note: I had about 7 broken tests (of 900) after updating.

expect(myObject.array).toEqual([]) from Knockout observable arrays using the ES5 plugin. had to be changed to myObject.array.length).toBe(0)
or comparing arrays values to splitting it to:
expect(acceptedTypes[0]).toBe(accepts[0]);
expect(acceptedTypes[1]).toBe(accepts[1]);
expect(acceptedTypes[2]).toBe(accepts[2]);

I'm not sure how I feel about those changes breaking my tests.",aligneddev,CONTRIBUTOR,2015-02-04 22:57:16+00:00,True,2016-07-26 16:56:45+00:00,537.75,,3,7,2015-02-05 01:22:15+00:00,0.1,Gerg,CONTRIBUTOR,1,2,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
771,Spy on non–property functions,"Is there a way to spy on a function which is not a property of an object? I'm thinking something like
var foo = function() {
  // awesomize something
}
var spy = spyOn(foo).and.callThrough()",mightyiam,NONE,2015-02-05 17:45:15+00:00,True,2015-02-06 17:12:49+00:00,0.98,,3,10,2015-02-05 19:32:35+00:00,0.07,gyandeeps,NONE,0,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
773,beforeAll and afterAll don't play well with fdescribe,"This test from the docs fails when run in a fdescribe block (jasmine 2.2.0):
describe(""A spec using beforeAll and afterAll"", function() {
  var foo;

  beforeAll(function() {
    foo = 1;
  });

  afterAll(function() {
    foo = 0;
  });

  it(""sets the initial value of foo before specs run"", function() {
    expect(foo).toEqual(1);
    foo += 1;
  });

  it(""does not reset foo between specs"", function() {
    expect(foo).toEqual(2);
  });
});",mvcatsifma,NONE,2015-02-09 09:09:10+00:00,True,2015-03-02 19:43:17+00:00,21.44,,2,1,2015-02-09 18:02:41+00:00,0.37,slackersoft,MEMBER,1,0,0,0,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
774,Specs inside xdescribe are not reported at all,"See http://jasmine.github.io/2.2/introduction.html: xdescribe ""A spec"" contains a spec ""is just a function, so it can contain any code"". This nested spec is completely ignored in Jasmine results:

nested ""it"" is counted in the total number of tests, but appears neither in executed nor in skipped tests, so the numbers don't sum up and cause confusion (""Ran 80 of 81 specs - run all / 80 specs, 0 failures, 3 pending specs"" - so, are there 80 or 81 specs?)
you cannot find the ""it"" text nowhere in the report, only the text of ""xdescribe"" can be seen",Derbeth,NONE,2015-02-09 13:35:14+00:00,True,2015-03-02 19:43:17+00:00,21.26,,2,1,2015-02-11 20:49:18+00:00,2.3,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
778,fail() from reporter appears multiple time in results,"If I fail a suite from reporter like this:
jasmine.getEnv().addReporter({
    suiteStarted: function(result){
       fail(new Error('Suite failed'));
    }
});
I get the error message multiple times, once for every spec as if it was a failed expectation contained in every spec.
1) test1
  Message:
    Failed: test error
  Stack:
    ...
  Message:
    Failed: No element found using locator: ...
  Stack:
    ...
2) test2
  Message:
    Failed: test error
  Stack:
    ...
 .....

I would expect to see a single error message ?",maximnaidenov,NONE,2015-02-12 12:31:06+00:00,True,2015-02-28 00:19:30+00:00,15.49,,2,3,2015-02-12 20:41:36+00:00,0.34,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
779,$injector not resolving required modules.,"Hi Team,
I am writing Unit Test Case using Jasmine for angular, but its not resolving dependency for my module. Could you please let me know if i am doing any thing wrong here.
https://gist.github.com/rahulsahay19/041ca130d187e2a6009e
Thanks,
Rahul",rahulsahay19,NONE,2015-02-14 13:11:05+00:00,True,2015-02-14 15:13:30+00:00,0.09,,3,3,2015-02-14 13:26:01+00:00,0.01,mallowigi,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
780,Error: Unexpected request: GET /api/movies,"Hi,
i am getting the below error when i am running the following code.
Result Message:
Error: Unexpected request: GET /api/movies
Code is updated in the gist link. Just wanted to know whether i am doing anything wrong or something else needs to be configured.
https://gist.github.com/rahulsahay19/041ca130d187e2a6009e
Thanks,
Rahul",rahulsahay19,NONE,2015-02-14 15:16:43+00:00,True,2015-02-14 17:29:32+00:00,0.09,,1,1,2015-02-14 17:29:32+00:00,0.09,rahulsahay19,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
781,Calling expect() when no spec is running doesn't generate any visible errors,"The following code causes Jasmine to throw ""'expect' was used when there was no current spec, this could be because an asynchronous test timed out"". But the suite passes and the error doesn't appear to be logged anywhere:
describe(""Specs that try to expect things after they're done"", function() {
    it(""should cause something to go red"", function (done) {
        done();
        expect(true).toBe(false);
    });
});
(Tested on 2.0.2 with the HTML reporter and 2.2.0 with both the HTML reporter and the stock node.js setup.)
Obviously that's a contrived example. But it corresponds to an async testing mistake that I’ve run into a number of times: writing test code that expects something to be async even though all of the async pieces have been replaced with synchronous mocks. It would be a big help if that error caused the suite to fail, even if Jasmine couldn’t pin the failure on the specific spec that caused it.",sgravrock,MEMBER,2015-02-17 01:08:22+00:00,True,2016-10-15 00:45:33+00:00,605.98,,4,6,2015-02-17 06:13:52+00:00,0.21,slackersoft,MEMBER,2,0,0,1,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
782,jasmine.clock().install() doesn't throw errors when called multiple times,"I believe it should, because when I have 2 tests like this:
it('a', function (done) {
    jasmine.clock.install(); 
    // ... some async code, calling done() when it's finished ...
    jasmine.clock.tick(100); // this runs the async code
    jasmine.clock.uninstall(); // and this doesn't get called (this is a bug in my test)
}

it('b', function () {
    jasmine.clock.install(); 
    // ... init theThing - it will be ready in 2 ticks ...
    jasmine.clock.tick(1);
    expect(theThing.isReady).toBe(false); // normally this would be ok, nut now will fail because of unnecessary ticks (because of bug in the test a)
    jasmine.clock.tick(1);
    expect(theThing.isReady).toBe(true);
    jasmine.clock.uninstall();
}

What happens here? The test a succeeds and b fails. But b fails only because a didn't clean up after itself! This introduces subtle dependencies between tests and makes tests using Jasmine clock a nightmare to debug in big projects.
I know that I should call jasmine.clock.install() from beforeEach, and so on, i.e. I know this isn't a good test. But I would expect the testing framework to do some sanity checks like these for me. And I would expect the test framework to do its best to make each test case independent of each other.
I'm using jasmine 2.2.0.",mik01aj,NONE,2015-02-18 14:31:53+00:00,True,2015-03-27 17:15:38+00:00,37.11,,4,12,2015-02-18 16:20:23+00:00,0.08,infews,CONTRIBUTOR,1,1,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
783,beforeAll is not using the clock correctly,"Hi, I'm using jasmine 2.2.0 and this test fails:
describe('Jasmine Clock', function () {
    beforeAll(function () {
        jasmine.clock().install();
    });

    afterAll(function () {
        jasmine.clock().uninstall();
    });

    it('fails', function (done) {
        jasmine.clock().tick(5 * 1000);
        expect(true).toBe(true);
        done();
    });
});
Fails saying
 FAILED Before All fails
 Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
    at Object.<anonymous> (beforeall.spec.js:15)
 Skipped 0 tests

However using beforeEach instead of All it works fine
describe('Jasmine Clock', function () {
    beforeEach(function () {
        jasmine.clock().install();
    });

    afterEach(function () {
        jasmine.clock().uninstall();
    });

    it('fails', function (done) {
        jasmine.clock().tick(5 * 1000);
        expect(true).toBe(true);
        done();
    });
});
 SUCCESS Before All fails
 Skipped 0 tests

Shouldn't they have the same behaviour?",piuccio,NONE,2015-02-18 16:52:44+00:00,True,2015-02-25 02:59:32+00:00,6.42,,2,1,2015-02-25 00:48:20+00:00,6.33,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
785,BeforeAll does not run for nested describe blocks.,"I have several tests with shared setup
describe( ""First"", function(){
  var foo;
  beforeAll(function (done){
    foo = ""Shared Setup"";
    done();
  });
  describe( ""Second"", function(){
    it(""Has been setup"", function(done) {
      expect(foo).toBe(""SharedSetup"");
    });
  });
 // More tests here
});
my beforeAll callback seems to never get called.",ticviking,NONE,2015-02-20 02:45:26+00:00,True,2015-03-26 22:03:26+00:00,34.8,,3,4,2015-02-20 03:07:21+00:00,0.02,Gerg,CONTRIBUTOR,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
786,expect().toEqual() with arrays fails (sometimes),"When i got a failed test with the message ""Expected [ 1, undefined ] to equal [ 1, undefined ]."" i almost started to doubt myself.
This is easy reproducable with the following code.
var t1 = [1];
t1.length = 2;
expect(t1).toEqual([1, undefined]);
(used jasmine 2.2.0)",Sventric,NONE,2015-02-20 12:29:22+00:00,True,2016-02-22 19:08:48+00:00,367.28,,6,9,2015-02-20 13:24:16+00:00,0.04,Gerg,CONTRIBUTOR,1,1,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
787,jasmine.objectContaining no longer works with inherited properties,"I have many tests that have suddenly started failing in Jasmine 2.2.0. I have written a simple example case below.
Given:
function SomeClass () {}
someClass.prototype.someProp = 'foo'
Test:
var someClass = new SomeClass();
expect(someClass.someProp).toEqual('foo'); // pass
expect(someClass).toEqual(jasmine.objectContaining({ someProp: 'foo' })); // fail
I know why it is failing, since the source changed the comparison conditions from hasKey to the native hasOwnProperty.
Was this change intentional? If so, is it documented anywhere?",Lalem001,NONE,2015-02-20 20:58:17+00:00,True,2015-03-26 21:02:23+00:00,34.0,,3,3,2015-02-21 00:25:53+00:00,0.14,Gerg,CONTRIBUTOR,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
790,Using jasmine.clock() in async specs can cause test pollution,"If an async spec calls done() from a timer that’s run by jasmine.clock(), then that spec’s calls to jasmine.clock.tick() can affect the behavior of following specs. There’s an example in Jasmine’s own test suite. This spec looks like it shouldn’t pass, and indeed it doesn’t when run by itself:

  
    
      jasmine/spec/core/integration/EnvSpec.js
    
    
        Lines 968 to 1037
      in
      8c59875
    
    
    
    

        
          
             it('explicitly fails an async spec', function(done) { 
        

        
          
               var env = new j$.Env(), 
        

        
          
               specDone = jasmine.createSpy('specDone'); 
        

        
          
            
        

        
          
               env.addReporter({ 
        

        
          
                 specDone: specDone, 
        

        
          
                 specStarted: function() { 
        

        
          
                   jasmine.clock().tick(1); 
        

        
          
                 }, 
        

        
          
                 jasmineDone: function() { 
        

        
          
                   expect(specDone).toHaveBeenCalledWith(jasmine.objectContaining({ 
        

        
          
                     description: 'has a default message', 
        

        
          
                     failedExpectations: [jasmine.objectContaining({ 
        

        
          
                       message: 'Failed' 
        

        
          
                     })] 
        

        
          
                   })); 
        

        
          
                   expect(specDone).toHaveBeenCalledWith(jasmine.objectContaining({ 
        

        
          
                     description: 'specifies a message', 
        

        
          
                     failedExpectations: [jasmine.objectContaining({ 
        

        
          
                       message: 'Failed: messy message' 
        

        
          
                     })] 
        

        
          
                   })); 
        

        
          
                   expect(specDone).toHaveBeenCalledWith(jasmine.objectContaining({ 
        

        
          
                     description: 'fails via the done callback', 
        

        
          
                     failedExpectations: [jasmine.objectContaining({ 
        

        
          
                       message: 'Failed: done failed' 
        

        
          
                     })] 
        

        
          
                   })); 
        

        
          
                   expect(specDone).toHaveBeenCalledWith(jasmine.objectContaining({ 
        

        
          
                     description: 'has a message from an Error', 
        

        
          
                     failedExpectations: [jasmine.objectContaining({ 
        

        
          
                       message: 'Failed: error message' 
        

        
          
                     })] 
        

        
          
                   })); 
        

        
          
                   done(); 
        

        
          
                 } 
        

        
          
               }); 
        

        
          
            
        

        
          
               env.describe('failing', function() { 
        

        
          
                 env.it('has a default message', function(innerDone) { 
        

        
          
                   setTimeout(function() { 
        

        
          
                     env.fail(); 
        

        
          
                     innerDone(); 
        

        
          
                   }, 1); 
        

        
          
                 }); 
        

        
          
            
        

        
          
                 env.it('specifies a message', function(innerDone) { 
        

        
          
                   setTimeout(function() { 
        

        
          
                     env.fail('messy message'); 
        

        
          
                     innerDone(); 
        

        
          
                   }, 1); 
        

        
          
                 }); 
        

        
          
            
        

        
          
                 env.it('fails via the done callback', function(innerDone) { 
        

        
          
                   setTimeout(function() { 
        

        
          
                     innerDone.fail('done failed'); 
        

        
          
                   }, 1); 
        

        
          
                 }); 
        

        
          
            
        

        
          
                 env.it('has a message from an Error', function(innerDone) { 
        

        
          
                   setTimeout(function() { 
        

        
          
                     env.fail(new Error('error message')); 
        

        
          
                     innerDone(); 
        

        
          
                   }, 1); 
        

        
          
                 }); 
        

        
          
               }); 
        

        
          
            
        

        
          
               env.execute(); 
        

        
          
             }); 
        

        
          
           }); 
        
    
  


It should fail because each call to jasmine.clock().tick() happens before the setTimeout() call that registers the function that it’s suppose to execute. When the entire suite is run, it passes because of this spec:

  
    
      jasmine/spec/core/integration/EnvSpec.js
    
    
        Lines 811 to 833
      in
      8c59875
    
    
    
    

        
          
           it(""should wait a specified interval before failing specs haven't called done yet"", function(done) { 
        

        
          
             var env = new j$.Env(), 
        

        
          
                 reporter = jasmine.createSpyObj('fakeReporter', [ ""specDone"", ""jasmineDone"" ]); 
        

        
          
            
        

        
          
             reporter.specDone.and.callFake(function() { 
        

        
          
               expect(reporter.specDone).toHaveBeenCalledWith(jasmine.objectContaining({status: 'failed'})); 
        

        
          
             }); 
        

        
          
            
        

        
          
             reporter.jasmineDone.and.callFake(function() { 
        

        
          
               expect(reporter.jasmineDone.calls.count()).toEqual(1); 
        

        
          
               done(); 
        

        
          
             }); 
        

        
          
            
        

        
          
             env.addReporter(reporter); 
        

        
          
             j$.DEFAULT_TIMEOUT_INTERVAL = 8414; 
        

        
          
            
        

        
          
             env.it(""async spec that doesn't call done"", function(underTestCallback) { 
        

        
          
               env.expect(true).toBeTruthy(); 
        

        
          
               jasmine.clock().tick(8416); 
        

        
          
             }); 
        

        
          
            
        

        
          
             env.execute(); 
        

        
          
           }); 
        
    
  


I think this is what’s happening: The call to jasmine.clock().tick() on line 829 indirectly leads to the call to done() on line 821, which in turn causes Jasmine to run the next spec while jasmine.clock().tick() is still executing. Any timers registered during an execution of jasmine.clock().tick() will be run before that execution finishes, if the specified interval is low enough. The result of all that is that the invocation of jasmine.clock().tick() in one spec ends up executing timers registered in another spec even though the mock clock was uninstalled and reinstalled in between.
I can see a few possible ways to fix this:

Change the behavior of the mock clock so that you have to call jasmine.clock().tick() again to run any timers that were registered during a tick. This would bring the mock clock’s behavior more in line with real setTimeout().
Create a new DelayedFunctionScheduler instance each time the clock is installed.
Modify QueueRunner to do a real setTimeout at the end of each async spec.

The catch is that any solution is a breaking change. That’s sort of the point — to break specs that shouldn’t be passing but currently aren’t. The first would, I think, be particularly nasty to inflict on users as part of a Jasmine upgrade, even though it might be the right thing to do if we were starting from scratch. The second and third should at least only break specs that ought to fail. Although it’s a bit indirect, the third option would also have the happy side effect of preventing two specs from being on the call stack at the same time.
The other option is to do nothing to Jasmine itself, work around the problem in the specs, and update the documentation to warn about using the mock clock in async specs.
Thoughts?",sgravrock,MEMBER,2015-02-23 07:01:03+00:00,True,2015-03-15 20:24:06+00:00,20.56,,3,2,2015-03-01 22:32:29+00:00,6.65,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
791,Clarify whether custom matcher message can be DOM node,"In http://jasmine.github.io/2.1/custom_matcher.html#section-Failure_Messages there's no mention whether a custom matcher might return a DOM node inside message. This has always been possible in the past and is still today (https://github.com/jasmine/jasmine/blob/master/lib/jasmine-core/jasmine-html.js#L290). For example imagediff builds on top of this feature.
Please clarify on whether this is still wanted. In this case I'll raise an issue with karma-jasmine to support non-string values inside message.
Please note that for CLI runners with a browser in the back the console output will not be able to render the DOM node.",cburgmer,NONE,2015-02-23 19:57:50+00:00,True,2015-03-04 23:12:00+00:00,9.13,,2,3,2015-02-28 05:35:44+00:00,4.4,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
792,QueueRunner does not use attrs.timer,"In this line https://github.com/jasmine/jasmine/blob/master/src/core/QueueRunner.js#L20 is a typo. It should be this.timer = attrs.timer || {setTimeout: setTimeout, clearTimeout: clearTimeout};. This is how the factory calls it.
Originally reported here with more details: Sanjo/meteor-jasmine#145 (comment)",Sanjo,NONE,2015-02-24 00:04:50+00:00,True,2015-02-25 05:03:16+00:00,1.21,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
793,Not toHaveBeenCalledWith should test against all object properties,"Hello,
I have the following test:
it(""tests if method was executed or not with a certain object argument"", function() {
    var fooSpy = jasmine.createSpy('foo');
    var expectedArg = { any : jasmine.any(String), foo : 'fuu' };

    // Passes as expected
    fooSpy({ any : 'lulz', foo : 'fuu'});
    expect(fooSpy).toHaveBeenCalledWith(expectedArg);

    // Fails as not expected
    fooSpy({ any : 'lulz', foo : 'foo'});
    expect(fooSpy).not.toHaveBeenCalledWith(expectedArg);
});
Shouldn't the second expect pass? The value of any is correct but foo isn't. I would expect toHaveBeenCalledWith to test against all properties in the object. Am I wrong? Is there a better way to do this?",bensampaio,NONE,2015-02-25 12:07:55+00:00,True,2015-02-25 18:23:42+00:00,0.26,,3,4,2015-02-25 12:47:38+00:00,0.03,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
794,How come there is not a single reference about jasmine-node in the README?,"I understand, they are different things, but it would not hurt to mention the jasmine-node package IMO.
Also, collecting a list of getting started with jasmine examples would be nice as well. I could provide some as well.
If anyone is interested, I can get on this 🤘
Cheers!",,NONE,2015-02-28 09:06:17+00:00,True,2015-03-02 22:52:18+00:00,2.57,,1,3,2015-03-02 22:52:18+00:00,2.57,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
795,Why can't you stub a variable.,"I want to be able to stub a variable with Jasmine, to control the state of the test for different scenario's
For example
var foo = false;
if(foo)
console.log('Hey')
stub(window, 'foo').andReturn(true);",vsakaria,NONE,2015-03-01 12:42:18+00:00,True,2015-03-01 16:21:16+00:00,0.15,,2,1,2015-03-01 16:21:16+00:00,0.15,infews,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
796,Ugly error messages from `toHaveBeenCalledWith` when using `jasmine.any`,"Try this test case:
it('aaa', function () {
    var spy = jasmine.createSpy();
    spy('a', {});
    expect(spy).toHaveBeenCalledWith('b', jasmine.any(Object));
});

Result:
FAILED TESTS:
  ✖ aaa
    PhantomJS 1.9.8 (Mac OS X)
      [native code]
  })> ] but actual calls were [ 'a', Object({  }) ].
  Error: Expected spy unknown to have been called with [ 'b', <jasmine.any(function Object() {
      at (...)

Using Jasmine  2.2.1.",mik01aj,NONE,2015-03-02 14:10:49+00:00,True,2015-03-03 21:29:25+00:00,1.3,,2,4,2015-03-02 16:54:12+00:00,0.11,mik01aj,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
797,Cannot find name 'bool'. Jasmine 2.2.0 and TypeScript,"I'm trying to use Jasmine with TypeScript. When I pulled the NuGet Package down I got about 58 errors ""Cannot find name 'bool'."" in the Jasmine.d.ts file. TypeScript stopped using the bool keyword and has swapped to Boolean. Is it safe to find and replace all bool with Boolean? Or is there a more up to date file I can pull?
EDIT: My apologizes, the bool keyword seems to live in the TypeScript Jasmine Test Suite template I downloaded. Please disregard :)",rwildema,NONE,2015-03-02 15:29:32+00:00,True,2015-03-02 15:31:06+00:00,0.0,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
798,Add fdescribe() and fit() to the docs,"Please add the info for fdescribe() and fit() to the documentation. xdescribe() and xit() is already there.
Thanks,
Markus",biegl,NONE,2015-03-05 21:55:04+00:00,True,2015-03-05 23:13:24+00:00,0.05,,2,1,2015-03-05 23:13:24+00:00,0.05,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
799,Documentation for async tests using done,"Hello,
I am having trouble understanding the way to test async calls using jasmine 2.2.
Please could you clarify the execution order if tests when using ""done"" calls:
In this case:
beforeEach(done) {
done();[1]
}
it(""spec 1"", function(done) {
expect something;
});
it(""spec 2"", function() {
expect something;
});
Will it be the case that spec 1 and spec 2 will be executed in arbitrary order after done() [1] is called?
And in the next case will it be that spec 4 will not be executed until done()[2] is called?
beforeEach(done) {
done();[1]
}
it(""spec 3"", function(done) {
expect something;
done();[2]
});
it(""spec 4"", function() {
expect something;
});
Thanks",MarkPaxton,NONE,2015-03-09 12:19:05+00:00,True,2015-03-09 20:16:01+00:00,0.33,,3,5,2015-03-09 20:16:01+00:00,0.33,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
800,expect().toBe­Gre­ate­rTh­an() SyntaxError: illegal character,"SyntaxError: illegal character
expect(homework_03.gl.viewportWidth).toBe­Gre­ate­rTh­an(1);
The arrow points to the ""G' in toBe­Gre­ate­rTh­an",MichaelThompson32214,NONE,2015-03-11 13:52:22+00:00,True,2015-04-10 00:41:53+00:00,29.45,,2,2,2015-03-14 22:06:54+00:00,3.34,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
801,Feature request: Highlight the spec file in stack trace for failed tests,"As a developer
I want to the line in the stack trace for my test/spec code to be highlighted or bold
So that I can quickly find the line in my spec file
It's hard to quickly find validationFieldSpecs with all the Jasmine stack trace information.
Could that line be highlighted or bolded? I suggest if the file name has Spec, Specifications, or Test in it (use a convention). Or the Jasmine stack information could be grayed or given less emphasis than other non-Jasmine (my code).
Example output from my test:
When working with a validation field should validate required and must match when both setup
Expected true to be falsy.
Error: Expected true to be falsy.
at stack (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:1457:12)
at buildExpectationResult (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:1427:11)
at Spec.expectationResultFactory (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:572:12)
at Spec.addExpectationResult (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:321:32)
at Expectation.addExpectationResult (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:516:17)
at Expectation.wrapCompare as toBeFalsy
at Object. (http://localhost:52734/unittests/Specs/Common/validationFieldSpecs.js?bust=1426081842271:73:22)
at attemptSync (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:1764:20)
at QueueRunner.run (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:1752:5)
at QueueRunner.execute (http://localhost:52734/UnitTests/Jasmine/Jasmine.js?bust=1426081842271:1737:8)",aligneddev,CONTRIBUTOR,2015-03-11 13:55:50+00:00,True,2018-01-19 01:42:48+00:00,1044.49,,9,14,2015-03-26 17:05:59+00:00,15.13,slackersoft,MEMBER,1,3,0,5,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
802,beforeAll() behaves as beforeEach() when using focused describe,"Hi there,
first I want to congratulate you for the project. Truly awesome.
Said that, the test below is failing to me. Looks like if beforeAll() was executing before each it() block when using the ""fdescribe()"" for focused execution:
fdescribe(""When using beforeAll()"", function() {
  var count = 0;
  beforeAll(function() {
    count++;
  });

  it(""count should stay at 1"", function() {
    expect(count === 1).toBeTruthy();
  });

  it(""count should stay at 1"", function() {
    expect(count === 1).toBeTruthy();
  });
  console.log('jasmine-version:' + jasmine.version);
});
If I run the same with not focused describe(), it passes. My version as per log is 2.2.0.
Thanks!,
Sergio.",sdcoca,NONE,2015-03-11 14:41:04+00:00,True,2015-03-11 16:44:54+00:00,0.09,,2,2,2015-03-11 16:44:54+00:00,0.09,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
803,CLI Improvements for Node.js,"Couple ideas:

--configure <FILE NAME> - Specify the config json (jasmine.json) from command line (also allow cson)
--coffee - Runs coffee files",jimbol,NONE,2015-03-13 16:27:05+00:00,True,2015-03-26 15:16:19+00:00,12.95,,2,1,2015-03-26 15:16:19+00:00,12.95,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
805,"toHaveBeenCalledWith() failing, although values are the same","I'm trying to verify that a function has been called with specific values.  Unfortunately, although the values are the same, I'm still getting the error:
Expected spy dailyRepeat to have been called with [ 0, 100000, Date(Sat Mar 16 2115 00:00:00 GMT-0400 (Eastern Daylight Time)), Date(Mon Mar 16 2015 00:00:00 GMT-0400 (Eastern Daylight Time)) ] but actual calls were [ 0, 100000, Date(Sat Mar 16 2115 00:00:00 GMT-0400 (Eastern Daylight Time)), Date(Mon Mar 16 2015 00:00:00 GMT-0400 (Eastern Daylight Time)) ].

I mocked out the time, cast it to a Number, and they were both the exact same number.  I also verified that all of the parameter typeofs were equivalent.

Running on Windows 7
Jasmine ~2.1.0
PhantomJS 1.9.8",alexhoneygosky,NONE,2015-03-16 16:21:23+00:00,True,2015-05-12 19:08:07+00:00,57.12,,3,2,2015-03-19 15:56:24+00:00,2.98,mik01aj,NONE,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
806,j$ call without passing the reference into jasmineToString,"I have bunch of test failures after upgrading to 2.2.1 jasmine-core and did a git bisect against 2.2.0 and 2.2.1 releases, bisect ended up showing the culprint to be commit:
1c6f4ef
Error i get from karma run is:
ReferenceError: Can't find variable: j$
So, without knowing more about about jasmine codebase, i'm quite confident to assume that the error is in this line:
https://github.com/jasmine/jasmine/blob/master/lib/jasmine-core/jasmine.js#L2405",rasjani,NONE,2015-03-17 13:55:16+00:00,True,2015-03-18 20:13:23+00:00,1.26,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
807,"When beforeEach times out, test cases should not execute","I would consider this a bug, but I'm happy to hear other opinions. Here's a quick example test case:
describe('my test', function() {

    beforeEach(function(done) {
      console.log('test start beforeEach');
      setTimeout(function () {
        console.log('test stop beforeEach');
        done();
      }, 4000)
    });

    it('test test one', function() {
      // I don't think this should ever be executed.
      console.log('test test one started');
      expect(true).toBe(false);
    });
});
I find it confusing that the it block is still executed, even though the test has already timed out.",juliemr,NONE,2015-03-17 20:43:28+00:00,True,2017-06-19 20:49:31+00:00,825.0,,6,4,2015-03-18 20:29:01+00:00,0.99,slackersoft,MEMBER,2,0,0,2,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
808,Discussion: shouldn't timer mocking be discouraged?,"I wrote many tests for async code with promises, and I ran into test pollution issues a few times (and those are hard to debug). Now I'm refactoring my tests to use the done() callback whenever possible, and this turns out to be a much more reliable method. Mocking setTimeout may break because:

some library might store its own reference to setTimeout (which will not be mocked),
setTimeout is not the only mechanism of asynchronous scheduling (from es6-promise: there are: BrowserMutationObserver and MessageChannel in browser and process.nextTick in Node)
JavaScript is a language where threads are never interrupted, and calling tick()is like interrupting the current thread. Imho this can lead to very frustrating problems with tests.

Shouldn't the documentation warn about this?",mik01aj,NONE,2015-03-18 11:25:06+00:00,True,2015-03-27 00:51:57+00:00,8.56,,2,3,2015-03-18 20:34:30+00:00,0.38,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
809,A very strange issue with jasmine clock (which can be worked around by empty describe or it blocks),"I have a test suite with around 60 tests. Recently I started refactoring them to use the done callback instead of the jasmine mocked clock, and after I changed some of the tests to use done, the next ones that were still using the timer, started to fail. So I got 6 failing tests. Then I started some experimenting, and I found out that if I put this at the beginning of my test suite:
describe('x', function () {
    it('a', function () {});
    it('b', function () {});
    it('c', function () {});
    it('d', function () {});
    it('e', function () {});
});

...the tests pass. What is more, when I remove just one it, one of those timer-based tests fails again. And so on. It's like one empty it fixes one broken timer-based test.
Btw, I found that the same is true for describe:
describe('a', function () {});
describe('b', function () {});
describe('c', function () {});
describe('d', function () {});
describe('e', function () {});
describe('f', function () {});

...is also enough.
I can't share my code right now, but I'm saving the current state in Git so I'll be able to reproduce it in the future.",mik01aj,NONE,2015-03-20 15:20:20+00:00,True,2015-10-28 19:26:57+00:00,222.17,,2,4,2015-03-26 17:37:01+00:00,6.09,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
811,Expectations in a global beforeAll and afterAll will not work,"Currently the topSuite in Env doesn't have the ability to handle expect calls itself. In order to support this, the topSuite needs:

to be added to the currentlyExecutingSuites so that Env will properly detect and delegate calls to expect to it
to receive an expectationFactory and expectationResultFactory upon construction in order to track the expectations

Env additionally needs to do the following when the treeProcessor completes:

report the result from topSuite to the reporter in the jasmineDone event
call clearResourcesForRunnable with the topSuites id
pop the topSuite from the currentlyExecutingSuites

HtmlReporter and JsApiReporter need to make the failures from jasmineDone available to the user.
Lastly, all the libraries using this (viz. jasmine-gem, jasmine-npm, and jasmine-py) need to consume the information presented in jasmineDone as well.",slackersoft,MEMBER,2015-03-27 23:10:05+00:00,True,2016-09-07 23:02:17+00:00,529.99,,5,10,2015-10-01 10:23:42+00:00,187.47,provegard,NONE,1,1,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
812,Print failure summary on specDone,"Jasmine prints the result on jasmineDone, in case of a failure, need to wait until all the specs finish execution to see the failure summary.
It would be better, if we can find the failure trace on SpecDone. Depends on the failure message, can terminate the test manually and fix the problem instead of waiting for long time to see the output.",enotha,NONE,2015-03-30 09:44:00+00:00,True,2015-03-30 15:05:30+00:00,0.22,,2,1,2015-03-30 15:05:29+00:00,0.22,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
813,Setup and Teardown misbehavior with focused specs ,"When focusing specs with fdescribeor fit, setup and teardown functions beforeAll and afterAll acts like beforeEach and afterEach, running once per spec instead of once per suite. When focus are removed the functions works as expected.
This spec reproduces the issue (with jasmine v2.2.1)
fdescribe(""A spec using beforeAll and afterAll"", function() {
  var foo;

  beforeAll(function() {
    foo = 1;
  });

  afterAll(function() {
    foo = 0;
  });

  it(""sets the initial value of foo before specs run"", function() {
    expect(foo).toEqual(1);
    foo += 1;
  });

  it(""does not reset foo between specs"", function() {
    expect(foo).toEqual(2);
  });
});",diegossilveira,NONE,2015-03-30 14:49:51+00:00,True,2015-03-30 15:05:29+00:00,0.01,,2,2,2015-03-30 15:05:29+00:00,0.01,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
814,Add support for spec suite dependencies,"Would it be possible to add a feature whereby you can specify dependencies for each suite of tests. This would allow the ability to test a specific test suite without knowing what prerequisite tests need to come before it.
for e.g,
You'd be able to run a single spec file ""supportSpec.js"" and have it's dependencies run before it.
supportSpec.js
describe(""customer support should work"", ['login'], function(){
  // Tests to go here
});

loginSpec.js
describe(""login should work"", ['registration'], function(){
  // Tests to go here
});

registrationSpec.js
describe(""registration should work"", function(){
  // Tests to go here
});

I understand this might require some significant changes.  Is this in any way a proposed or even thought-about feature? I couldn't find any reference to such a feature on the issue trackers.",drewzh,NONE,2015-03-31 14:24:10+00:00,True,2015-03-31 14:58:16+00:00,0.02,,3,2,2015-03-31 14:41:32+00:00,0.01,Gerg,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
816,beforeEach does not wait on beforeAll,"In our pages, we use <ng-controller=""ctrlName as vm""> and then use the pattern
ng-model=""vm.something"".  We use services to communicate between controllers
so nothing is dependent on the state of $scope.
When unit testing controllers we therefore need a reference not to scope
but the controller itself so we would like to do this:
describe('When users does something', function() {
    var ctrl;

    beforeAll(function() {
        module['theModule'];
        inject(function($controller) {
            ctrl = $controller('theController', { $scope: {} });
        });
    });

    beforeEach(function() {
        ctrl.state = whatever;  //setup specific actions for specific test case
    });

    it('check the result', function() {
        expect(ctrl.value).toBe('something');
    });
});

While we would like to do that we can't.  The issue appears to be that beforeEach
is called prior to resolution of beforeAll (inbeforeEach, ctrl is null).
Instead we find that we have to do this pattern:
...
    beforeEach(function() {
        module['theModule'];
        inject(function($controller) {
            ctrl = $controller('theController', { $scope: {} });
        });
        //Can't use ctrl here, it is null.
    });

    it('check the result', function() {
        ctrl.state = whatever;  // This doesn't belong here.
        expect(ctrl.value).toBe('something');

        describe('', function() {
            beforeEach(function() {
                ctrl.state = theNextThing;      //Works fine down here
            }
            it('check the next result', function() {
                expect(ctrl.value).toBe('better');
            });
        }
    });
...

So we're both taking the action and checking the result in the same place on the
first level of test but in nested tests we can follow the desired pattern.
Should we care?  Are we doing something wrong with beforeAll()?  Is there a
way to wait asynchronously on the creation of ctrl in beforeEach
(or for that matter, beforeAll) and then take the action there?
Thank you.
angular: 1.3.15
jasmine: 2.2.1
karma: 0.12.31
karma-cli: 0.0.4",jdenekat,NONE,2015-04-02 18:33:15+00:00,True,2015-04-06 19:58:58+00:00,4.06,,2,8,2015-04-02 19:48:20+00:00,0.05,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
819,toThrowError doesn't consider inheritance,"toThrowError is very useful, but I think it works incorrectly with custom error classes.
function PirateError(message) {
    this.message = 'Arrggghhhh! ' + message;
}
PirateError.prototype = new Error();

describe('custom try/catch', function() {
    it('works fine in tests', function() {
        try {
            throw new PirateError();
        } catch (error) {
            expect(error).toEqual(jasmine.any(Error));
            expect(error).toEqual(jasmine.any(PirateError));
            expect(error instanceof Error).toBeTruthy();
            expect(error instanceof PirateError).toBeTruthy();
        }
    });
});

describe('toThrowError', function() {
    it('considers error inheritance', function() {
        expect(function() {
            throw new PirateError('Blow me down!');
        }).toThrowError(PirateError);
    });
});
Result:
Expected function to throw PirateError, but it threw Error.",chge,NONE,2015-04-08 11:49:21+00:00,True,2015-04-09 22:38:31+00:00,1.45,,2,2,2015-04-08 22:09:04+00:00,0.43,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
820,How to use jasmine with official node.js debugger?,"Hello all javascript hackers!
Just create sample rake app and run
jasmine:install
jasmine:examples
jasmine:ci
5 test are successfull
After it, adding debugger; in to spec file PlayerSpec.js like this
describe(""Player"", function() {
  var player;
  var song;

  beforeEach(function() {
    player = new Player();
    song = new Song();
  });

  it(""should be able to play a Song"", function() {
    debugger;
    player.play(song);
    expect(player.currentlyPlayingSong).toEqual(song);

    //demonstrates use of custom matcher
    expect(player).toBePlaying(song);
  });

  describe(""when song has been paused"", function() {
    beforeEach(function() {
      player.play(song);
      player.pause();
    });

    it(""should indicate that the song is currently paused"", function() {
      expect(player.isPlaying).toBeFalsy();

      // demonstrates use of 'not' with a custom matcher
      expect(player).not.toBePlaying(song);
    });

    it(""should be possible to resume"", function() {
      player.resume();
      expect(player.isPlaying).toBeTruthy();
      expect(player.currentlyPlayingSong).toEqual(song);
    });
  });

  // demonstrates use of spies to intercept and test method calls
  it(""tells the current song if the user has made it a favorite"", function() {
    spyOn(song, 'persistFavoriteStatus');

    player.play(song);
    player.makeFavorite();

    expect(song.persistFavoriteStatus).toHaveBeenCalledWith(true);
  });

  //demonstrates use of expected exceptions
  describe(""#resume"", function() {
    it(""should throw an exception if song is already playing"", function() {
      player.play(song);

      expect(function() {
        player.resume();
      }).toThrowError(""song is already playing"");
    });
  });
});

, run jasmine:ci
All sucessfull, but debugger is not running, why?
It looks, that in usual case, we must use something like this:
$ node debug file.js
But how to use it with jasmine ?
With the best regards, Ruslan.",rusikf,NONE,2015-04-09 08:12:25+00:00,True,2015-04-09 17:59:00+00:00,0.41,,2,1,2015-04-09 17:59:00+00:00,0.41,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
821,"add a global ""custom matcher registration""-method","I've seen that this was already request in #721 and it was denied to implement it.
But as I'm quite sure that there are several people having the same issue, I'm asking again to implement a method to register a new matcher globally.
""Why?"" you're may asking: The reason is simple. It's really painful to add a matcher over and over again, if you want to use it in several beforeAll methods - it simply adds more boilerplate code.
Why not add the possiblity to add matchers to a global list like the default matchers are?
And even more horrible: If I want to use the ""jasmine-matchers"" library, there is no way to access and register the matchers at all from the outside.
So please: Think again about adding a global matcher registration method.
Thank you. :)",GFriedrich,NONE,2015-04-09 13:33:05+00:00,True,2015-04-09 17:43:49+00:00,0.17,,3,5,2015-04-09 17:43:49+00:00,0.17,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
822,Calling done() multiple time inside a single test scope leads to unpredictable behavior,"I've started using Jasmine 2.1.3 for some async tests, and found the done() a really helpful future.
In one of my tests, I accidentely called done() twice:
describe('Some random async tests', () => {
  it('should not be passing', (done) => {
    //done();
    setTimeout( () => {
      expect(true).toBe(false);
      done();
    },
    200
    );
  });

  it('should be passing1',(done) => {
    setTimeout(
      () => { done(); },
      200
    )
  });
  it('should be passing2',(done) => {
    setTimeout(
      () => { done(); },
      200
    )
  });
  it('should be passing3',(done) => {
    setTimeout(
      () => { done(); },
      200
    )
  }); 
);
When in 'it should not be passing', the first done() is commented out, things work as expected: 3/4 tests succeed and the failing test is 'it should not be passing'.
However, if you allow the 'it should not be passing' to call done(), then later (timeout) make an invalid expect and call done again, the test runner reports 3/4 tests failed and the failing test is 'it should be passing2'.
I've debugged my tests for countless hours and doubted my entire code base as every time I commented out any 'it should be passing' test that was failing, one other test that was working before would now randomly start failing.
Agreed, developers should not call done() multiple times in a single test, but when they do it would be nicer to inform them of their mistake than to report a false negative on another random test.",janvanderhaegen,NONE,2015-04-10 23:54:49+00:00,True,2015-04-16 20:15:48+00:00,5.85,,2,3,2015-04-16 20:15:48+00:00,5.85,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
823,toThrowError does not handle a function call with an argument ...,... which is odd. Write now the function has to be wrapped inside another function for it to work. Will there be a fix in the near future?,lokeb,NONE,2015-04-14 12:57:11+00:00,True,2015-05-12 00:33:49+00:00,27.48,,5,6,2015-04-16 20:33:27+00:00,2.32,slackersoft,MEMBER,2,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
824,question about done() in beforeAll/afterAll,"From http://jasmine.github.io/2.0/upgrading.html#section-Asynchronous_Specs, it is pointed out that it/beforeEach/afterEach can take a done() callback. However, from experimenting, it feels like beforeAll/afterAll will take this callback too. Is this supported behavior? If so, would you please specify in the docs?
For example:
describe('test', function() {
  var x = [];
  beforeAll(function(done) {
    setTimeout(function() {
      x.push('beforeAll');
      done();
    }, 100)
  });

  beforeEach(function(done) {
    setTimeout(function() {
      x.push('beforeEach');
      done();
    }, 100)
  });

  it('before/after all', function() {
    console.log('result: ', x);
  });
});
prints
result:  [ 'beforeAll', 'beforeEach' ]",hankduan,NONE,2015-04-15 18:34:09+00:00,True,2015-04-16 20:21:44+00:00,1.07,,2,1,2015-04-16 20:21:44+00:00,1.07,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
825,feature request: toHaveBeenCalledWith and call count,"In situations where I want to test spy's I'm finding the existing assertions a bit awkward.
firstly, toHaveBeenCalledWith is ambiguous as to whether it means ""has been called once and it was called with"" or ""it was last called with"" or ""it was called at some point with"".
I had expected the first as the most useful for testing, then the 2nd as a little useful and closer to the english but was surprised by the last. I guess it makes sense because of the toHaveBeenCalled matcher. Maybe that confusion was just me..
When would you want to check something had been called with x at some point? I'm using reset, but then I might be fooled into thinking I had a good enough test with
spy.reset();
test();
expect(spy).toHaveBeenCalledWith("""");

where as ideally I want to test that the call count is 1. Would you ever not care how many times a function had been called? So I think that the majority of people using this function probably want to do...
spy.reset();
test();
expect(spy).toHaveBeenCalledWith("""");
expect(spy.calls.count()).toEqual(1);

Furthermore, if what I am testing tests twice I am left with assertions that don't look great
// I care about ordering
spy.reset();
test();
expect(spy.calls.count()).toEqual(2);
expect(spy.calls.argsFor(0)).toEqual([""1""]);
expect(spy.calls.argsFor(1)).toEqual([""2""]);

// I don't care about ordering
expect(spy.calls.count()).toEqual(2);
expect(spy).toHaveBeenCalledWith(""1"");
expect(spy).toHaveBeenCalledWith(""2"");

So, I'm wondering about better syntax, something like the below ?
expect(spy).toHaveBeenCalled.once.with(""1"")
expect(spy).toHaveBeenCalled.first.with(""1"");
expect(spy).toHaveBeenCalled.second.with(""1"");

or
expect(spy.calls.first()).toHaveBeenCalledWith(""1"")
expect(spy.calls.second()).toHaveBeenCalledWith(""2"")

so what do you think? the main thing is I am finding in the wild quite messy assertions in some instances and lovely clean ones in others. Thanks.",lukeapage,NONE,2015-04-17 14:26:26+00:00,True,2015-04-20 07:52:44+00:00,2.73,,4,4,2015-04-19 10:59:12+00:00,1.86,lukeapage,NONE,0,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
826,Clock uninstall doesn't work if spy is added on setTimeout after installation,"See the following block:
describe('clock calls', function () {
    beforeEach(function () {
        jasmine.clock().install();
    });

    afterEach(function () {
        jasmine.clock().uninstall();
    });

    it('', function () {
        spyOn(window, 'setTimeout');
    });
});

it('', function () {
    // window.setTimeout is still non-native
})
If a spy is added on window.setTimeout after clock().install();, the clock().uninstall() doesn't uninstall on window.setTimeout.
I also noted that adding the spy before clock installation works with expected behavior, though.",chrisirhc,NONE,2015-04-17 22:11:21+00:00,True,2015-09-24 22:55:15+00:00,160.03,,4,13,2015-04-20 20:17:55+00:00,2.92,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
829,Async timeouts while writing sync specs,"Hello,
I get error Error: 'expect' was used when there was no current spec, this could be because an asynchronous test timed out while I am writing synchronous specs and 100% sychronous code.
Log:
Failures:
1) RadioKit.Data.Interface #getQuery if one argument is passed and it is valid but there's no such query encountered a declaration exception
1.1) Error: 'expect' was used when there was no current spec, this could be because an asynchronous test timed out

I am using jasmine 2.2.1 and gulp to compile coffeescript to JS prior to execution.
  describe ""#hasQuery"", ->
    instance = null

    beforeEach ->
      instance = new RadioKit.Data.Interface({ authUserName: ""123"", authPassword: ""123"" })

    describe ""if no argument is passed"", ->
      it ""throws an error"", ->
        expect ->
          instance.hasQuery()
        .toThrow()

    describe ""if one argument is passed"", ->
      describe ""but it is invalid"", ->
        describe ""because it contains something different than a string"", ->
          it ""throws an error"", ->
            expect ->
              instance.hasQuery(123)
            .toThrow()

      describe ""and it is valid"", ->
        describe ""but there's no such query"", ->
          it ""returns false"", ->
            expect(instance.hasQuery(""myQuery"")).toBe(false)

        describe ""and there's such query"", ->
          beforeEach ->
            instance.addQuery(""myQuery"", ""Track"")

          it ""returns true"", ->
            expect(instance.hasQuery(""myQuery"")).toBe(true)",mspanc,NONE,2015-04-20 08:33:59+00:00,True,2015-07-01 01:25:10+00:00,71.7,,5,6,2015-04-20 20:31:54+00:00,0.5,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
830,Cannot perform a 'it' inside another 'it',"Hi everyone,
I recently upgrade to Jasmine 2.0 and my code does not work anymore. Let me explain my problem:
I fill a variable in a beforeAll method, and I use this variable to perform a forEach which contains some 'it'. My code is similar as this:
describe ('Main describe', function() {
    var table;
    beforeAll( function(done) {
        table = anotherScript.method();
        done();
    });

    it(""first it"", function(done) {
        //I perform some actions...
        done();
    });

    table.forEach (function(item) {
        it(""it in the loop"", function(done) {
            //I perform some actions...
            done();
        });
    });
}); 
But my problem is the code read the loop before the beforeAll is executed and at this moment my 'table' variable is empty, so the code never enters in the loop...
Before I upgraded to Jasmine 2.0, I just put my loop in another 'it' like this:
it(""it that contains my loop"", function() {
    describe(""describe that contains my loop"", function() {   
        table.forEach (function(item) {
            it(""it in the loop"", function() {
                //I perform some actions...
            });
        });
    });
});
I had no issue with 'it' inside other 'it' as long as I declare a 'describe', and the code entered in the loop after the beforeAll was performed. Jasmine 2.0 no longer accepts 'it' in another 'it': the code never enters in my second 'it'...
I tried to fill the 'table' variable in a method that returns a promise and perform the main describe only after the promise is fulfilled: but in this case, no specs are found and the script finished.
Have you a solution for this case ?",Aelsa,NONE,2015-04-23 07:27:52+00:00,True,2015-05-12 19:06:21+00:00,19.49,,5,5,2015-04-23 15:16:04+00:00,0.33,mallowigi,NONE,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
831,tobeUndefined() runs out of memory,"If I use tobeUndefined() for some element on webpage , it runs out of memory and crashes.
Following is my test:
it('test for undefined element',function(){
browser.get(""https://builtwith.angularjs.org/"");
expect(element(by.className('myname'))).toBeUndefined();
});
And when I run it , it takes a few minutes and gives me the following:
FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory
Aborted (core dumped)
ALSO
test passes if I use the following
it('test for undefined element',function(){
browser.get(""https://builtwith.angularjs.org/"");
expect(element(by.className('myname'))).toBeDefined();
});",nishakchaudhari,NONE,2015-04-27 17:27:29+00:00,True,2015-05-28 23:44:25+00:00,31.26,,2,6,2015-05-04 23:53:29+00:00,7.27,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
832,BeforeAll only works on first it,"I hoped that what I did in ""beforeAll"" was to continue for all ""its"" other than the ""beforeEach"" which is run again before every ""it"".
For example I thought I could load the ""fixture"" only once and use the same for every ""it"", keeping the changes that every ""it"" did it, because to test the next ""it"" accurate than was done in the previous, currently have to replicate every ""it"" what your anteiror did, what causes my tests grow exponentially, as each ""it"" again has everything that was done in the ""it"" Previous else to want to test it and that depends on all the above process has worked.",roger-russel,NONE,2015-04-27 21:10:20+00:00,True,2015-09-24 21:28:21+00:00,150.01,,3,3,2015-05-04 23:17:26+00:00,7.09,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
833,Missing SpecRunner.html file ,"Hi, I have recently started learning Jasmine. Most tutorials advise to edit ""SpecRunner.html"" file run the tests. But I am unable to find this file in root folder or anywhere else ? Where can I found this file ? Thanks",punit11,NONE,2015-04-28 01:58:53+00:00,True,2015-10-15 19:37:06+00:00,170.73,,6,7,2015-04-28 15:26:11+00:00,0.56,Gerg,CONTRIBUTOR,1,1,0,3,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
834,"Custom ""chain"" keywords.","Does Jasmine offer any methods to add a custom chain?
For example:
// currently you can negate the result 
// of any expectation using the ""not"" keyword
expect(true).not.toBe(false);    // test passes
But, how would I go about doing something like this:
// I want to add my own ""or"" keyword, for example.
expect('Hello Jasmine').toMatch(/hello/i).or.toMatch(/jasmine/i);",nbish11,NONE,2015-04-28 13:57:23+00:00,True,2015-09-24 21:05:34+00:00,149.3,,2,2,2015-04-28 21:01:49+00:00,0.29,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
835,Why does jasmine.HtmlReporter() need the user to define each function??,"I'm talking about this:
var env = options.env || {},
      getContainer = options.getContainer,
      createElement = options.createElement,
      createTextNode = options.createTextNode,
      onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},
      onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},
      addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,
      timer = options.timer || noopTimer,
      results = [],
      specsExecuted = 0,
      failureCount = 0,
      pendingSpecCount = 0,
      htmlReporterMain,
      symbols,
      failedSuites = [];

Why is the user supposed to pass all these in??",dopatraman,NONE,2015-04-29 18:52:14+00:00,True,2015-09-24 21:15:46+00:00,148.1,,3,2,2015-04-29 19:44:18+00:00,0.04,Gerg,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
837,"Weird Issue, all tests fails on adding an extra it, or xit to a describe","I have a set of tests described under one ""describe"" which all pass without an issue. But the moment I add another ""it"" section, all other tests start to fail. Not only that but even when it is ""xit"", all other tests start to have problems. The only way to get the tests to work, is to remove or comment out the section completely. This is the most unusual behavior that I have seen ever.",lokeb,NONE,2015-04-30 11:16:08+00:00,True,2015-04-30 11:50:53+00:00,0.02,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
838,Testing a function that has a callback and a return value,"How do I test a function that has a callback and an immediate return value? Using 'done', ignores the test for the return value, and only considers the tests in the callback function.",lokeb,NONE,2015-05-02 05:40:44+00:00,True,2015-09-24 21:06:34+00:00,145.64,,2,1,2015-05-04 23:54:20+00:00,2.76,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
839,The jasmine page cannot be scrolled in Safari and Chrome on OS X 10.10,"I'm using jasmine 2.3, the previous version seems doesn't have this issue.
After clicking on a specific test, sometimes the page can be scrolled.",zhangkaiyulw,NONE,2015-05-03 05:02:20+00:00,True,2015-05-28 19:25:26+00:00,25.6,,2,3,2015-05-13 23:37:47+00:00,10.77,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
840,Specs with xit or no function are no longer reported as pending,"The docs say that xit and functionless specs will be marked as pending which is currently not the case. It seems both of these are disabled and not reported on. The docs currently suggest that xit specs and xdescribe suites will not be reported on at all.
Should the docs be updated to clarify that only specs with a call to pending are actually reported as pending and others are hidden?
My view is that functionless specs should still be reported as pending since they have not be explicitly disabled and represent an unfinished (i.e. pending) test rather than one that is purposely hidden.",benjaminjosephw,NONE,2015-05-04 12:15:42+00:00,True,2015-05-07 20:47:37+00:00,3.36,,4,4,2015-05-07 13:36:04+00:00,3.06,nickmccurdy,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
841,"toHaveBeenCalledWith(param1, undefined) is not considered equivalent to toHaveBeenCalledWith(param1)","IMHO these two cases are functionally the same, and should be treated as such (i.e. a test should not fail if you declare toHaveBeenCalledWith(param1) but the function is called with (param1, undefined).",settinghead,NONE,2015-05-04 18:16:22+00:00,True,2015-05-12 16:48:02+00:00,7.94,,2,1,2015-05-12 16:47:59+00:00,7.94,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
842,Async reporter hooks,"See angular/protractor#1938
We want to be able to respond asynchronously to test failures. For instance, taking a screenshot of the browser in selenium webdriver when an end-to-end test fails. We can't do this in afterEach or afterAll since those functions don't have access to the pass/fail state of the spec. Nor can we do it reliably in the reporter, since specDone and suiteDone assume synchronous execution.
To address this problem, an optional done callback could be added to reporter functions. Here's an example of how we could apply it to specDone:
jasmine.getEnv().addReporter({
  specDone: function (result, done) {
    if (result.failedExpectations.length === 0) {
      return done();
    }
    browser.driver.takeScreenshot(function (data) {
      // write out screenshot data to a file
      done();
    });
  }
});
The behavior would be similar to an async spec in that if the reporter hook takes 1 or no arguments, it is assumed to be synchronous; but if there are 2 arguments, it becomes an asynchronous reporter hook.
Would any owners be interested in accepting this as a PR? If so, I'll look into crafting it.",ksheedlo,NONE,2015-05-04 23:18:22+00:00,True,2018-01-29 21:48:59+00:00,1000.94,,10,12,2015-05-14 00:34:48+00:00,9.05,slackersoft,MEMBER,1,0,0,8,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
844,using common CSS class names on Jasmine DOM elements can cause unintended behavior,"I'm a relative new-comer in the field of front-end web dev, and there is no other comp sci / programming field in which I'm more experienced. (But hear me out anyway, ha ha.)
While working on a student project, I noticed something about Jasmine which you might consider a ""bug"" which causes unintended DOM interactions between Jasmine's part of the DOM and the app-that's-being-tested's part of the DOM.
And this bug does not have to exist at all; you can painlessly avoid it.
So, what is this problem?
Well, I first noticed a specific case of this bug when I saw some of Jasmine's text appearing in one of the app's divs on a student project I was working on — the words ""Spec List"" and ""Failures"" appeared on top of what should have been in my app's .menu div. This occurred whenever a specification failed.
I have reproduced a case of this bug here:
http://codepen.io/prather-mcs/pen/bdVrdN
(this Pen is loading all necessary Jasmine assets from here)
When you un-comment the test expect(false).toBe(true);, then you will see the bug happen: the app's CSS for .menu is affecting the position of Jasmine's DOM elements that also have class .menu
I'm sure you want to always keep Jasmine's information down in Jasmine's part of the document.
So that's a specific case where .menu is colliding.
But I think the general problem you would want to fix is the creation by Jasmine of DOM elements with such commonly-used class-names as these:

.bar
.menu
.results
.summary
.banner

In summary, the Issue is this:
While none of Jasmine's CSS rules in jasmine.css change how the app appears, style rules in the tested app which affect any class name that jasmine.css also uses can cause Jasmine's DOM content to be styled in un-intended ways, including causing it to jump right out of Jasmine's part of the page and onto the app's part of the page.

I would be happy to get credit for fixing this bug -- I would go to the jasmine-html.js code that creates DOM Nodes and ensure that all CSS class names are unique (enough) by giving them slightly new names, such as changing code that would add the class .menu to a DOM Node to actually add the class .jasmine-menu instead. Then I would make corresponding changes to jasmine.css as well.
However, I have not contributed to this project before, and have only been looking into the code-base for the first time this week.
I'm thinking that there are people with seniority and authority who would probably have a better idea of how to name the CSS classes than I have, and they would have a better idea of the best Jasmine app code to write to efficiently implement the fix as well.
With that being said, if you would allow me to write a fix and create a Pull request to fix this bug, I would like to get some credit contributing to open source....",prather-mcs,CONTRIBUTOR,2015-05-05 22:38:04+00:00,True,2015-05-18 21:28:34+00:00,12.95,,2,3,2015-05-07 22:08:56+00:00,1.98,nertzy,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
845,ReferenceError: pending is not defined,"Inside of one of my tests, based on an environmental condition, I am trying to call pending() as described here. I'm getting a ""ReferenceError: pending is not defined"" error.",JZ-at-TP,NONE,2015-05-07 01:22:46+00:00,True,2015-05-07 01:29:05+00:00,0.0,,1,1,2015-05-07 01:29:05+00:00,0.0,JZ-at-TP,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
846,"Attributes set on the ""this"" keyword inside root beforeAll can no longer be accessed inside describe block","Hey, thank you guys so much for maintaining this project! It has helped me out so much! I love Jasmine's ""this"" keyword. While doing some tests and upgrading from Jasmine version 2.2.1 to 2.3.0, I noticed my tests no longer passed because of a change that was made in the way the ""this"" keyword can be used. I want to understand why this change was made, and if the Jasmine team as well as people using Jasmine would support reverting this change. Take for example the following code:
beforeAll(function() {
    this.attr = 1;
})

describe('Testing root beforeAll', function() {
    it('should be able to access ""attr""', function() {
        expect(this.attr).toEqual(1);
    });
});
Note that in the test we are setting an attribute on the ""this"" keyword inside a beforeAll function that executes on the root level. Executing this test in version 2.2.1 (both the standalone and npm versions) shows the test as passing. However, in version 2.3.0 the test fails.
Let me explain my argument for why this should be changed to work in the latest version of Jasmine. In Jasmine versions 2.2.1 and 2.3.0 I've noticed that inside any describe block you can access attributes on the ""this"" keyword that were set in the beforeAll function of that describe block, regardless of the nesting level inside the block from which you attempt to access those attributes. It only seems logical that the same rules would apply to beforeAll functions on the root level that set attributes on the ""this"" keyword.
Why is this a big deal? Normally you could just use global variables, or put the beforeAll function inside your describe block, and then you could access the attribute just fine. This doesn't work for me though because I chose to use helper files to avoid redundancy in my code. Inside the helper file a beforeAll on the root level initializes attributes on the ""this"" keyword so they can be accessed by the tests. Since the beforeAll no longer works this way, my only alternative (while still allowing me to keep the same testing framework) is using the beforeEach, which will run before every single it block. Considering that there will be over 100 it blocks in my code, the beforeEach will be run dozens of times, making my test code more inefficient. As such, this appears to be a poor solution. So I'm hoping we could get the previous functionality back. :)
Thank you to all who have read my post. Please comment and let me know what you think.",joswhite,NONE,2015-05-07 23:47:19+00:00,True,2015-05-11 17:30:24+00:00,3.74,,4,10,2015-05-08 15:02:55+00:00,0.64,trsrm,NONE,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
847,unused CSS classes? dead code?,"I'm currently writing a fix for Issue 844 :
#844
In this process, I think I've found some CSS classes that are essentially ""dead code"" because I can't find any JavaScript code in the codebase that ever applies them. I'm referring to lines 258–288 here:

  
    
      jasmine/src/html/_HTMLReporter.scss
    
    
         Line 258
      in
      426eebe
    
    
    
    

        
          
           //--- Results menu ---// 
        
    
  


The SCSS code there compiles to dead code in jasmine.css, lines 43–48:

  
    
      jasmine/lib/jasmine-core/jasmine.css
    
    
         Line 43
      in
      426eebe
    
    
    
    

        
          
           .jasmine_html-reporter.showDetails .summaryMenuItem { font-weight: normal; text-decoration: inherit; } 
        
    
  


Basically, I can't find any JavaScript in the whole code base that ever refers to CSS classes showDetails or summaryMenuItem. I know that code can still refer to things implicitly, like when you invoke forEach or invoke a for..in loop, however these class names are located in CSS, which as far as I know doesn't really have any programmatic constructs for looping or otherwise accessing implicitly — we always have to explicitly name the CSS class in JS to apply them, right?
(You could also get a class name in JS by querying a DOM element and then accessing its classList property and then accessing the returned array-like object, and in that case you would also have gotten a CSS class in your JavaScript without ever naming it explicitly — but the class would have to be explicitly set in the HTML, and that's not applicable in this case, because Jasmine constructs all of its HTML programmatically.)
And I can't find DOM elements with these class names (.showDetails, .summaryMenuItem) ever appearing in the browser document .
So I'm really thinking that these style rules are dead wood left over from a time when they were used, but are not used any more.

My questions are:

have I said something wrong above?
can I just take out this dead CSS in the other fix I'm working on, then submit a pull request to fix both 844 and this Issue at once?
or should I just make the most atomic of commits, with one that removes the dead CSS, and then one that fixes 844 (my fix in 844 is to make ""unique enough"" names for the CSS that Jasmine uses)

edit/update
I'll take them out while I'm developing, and see if all specs still pass. I probably should have done that before opening Issue, in addition to the code reasoning I did.",prather-mcs,CONTRIBUTOR,2015-05-10 20:19:25+00:00,True,2015-05-11 18:13:29+00:00,0.91,,2,2,2015-05-10 22:43:47+00:00,0.1,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
850,Test order no longer maintained since 2.3.0,"I am not quite sure this is an issue but without documentation explicitly stating otherwise (at least that I could find) it could be a logical expectation that test declaration order would be maintained. It appears since 2.3.0 the declared order for tests is no longer preserved:
it('a', function (done) { console.log('a'); setTimeout(done, 100); });
it('b', function (done) { console.log('b'); setTimeout(done, 100); });
it('c', function (done) { console.log('c'); setTimeout(done, 100); });
it('d', function (done) { console.log('d'); setTimeout(done, 100); });
it('e', function (done) { console.log('e'); setTimeout(done, 100); });
it('f', function (done) { console.log('f'); setTimeout(done, 100); });
it('g', function (done) { console.log('g'); setTimeout(done, 100); });
it('h', function (done) { console.log('h'); setTimeout(done, 100); });
it('i', function (done) { console.log('i'); setTimeout(done, 100); });
it('j', function (done) { console.log('j'); setTimeout(done, 100); });
it('k', function (done) { console.log('k'); setTimeout(done, 100); });
it('l', function (done) { console.log('l'); setTimeout(done, 100); });
it('m', function (done) { console.log('m'); setTimeout(done, 100); });
it('n', function (done) { console.log('n'); setTimeout(done, 100); });
it('o', function (done) { console.log('o'); setTimeout(done, 100); });
it('p', function (done) { console.log('p'); setTimeout(done, 100); });
it('q', function (done) { console.log('q'); setTimeout(done, 100); });
it('r', function (done) { console.log('r'); setTimeout(done, 100); });
it('s', function (done) { console.log('s'); setTimeout(done, 100); });
it('t', function (done) { console.log('t'); setTimeout(done, 100); });
it('u', function (done) { console.log('u'); setTimeout(done, 100); });
it('v', function (done) { console.log('v'); setTimeout(done, 100); });
it('w', function (done) { console.log('w'); setTimeout(done, 100); });
it('x', function (done) { console.log('x'); setTimeout(done, 100); });
it('y', function (done) { console.log('y'); setTimeout(done, 100); });
it('z', function (done) { console.log('z'); setTimeout(done, 100); });

// 2.1.0: a b c d e f g h i l k l m n o p q r s t u v w x y z
// 2.2.0: a b c d e f g h i l k l m n o p q r s t u v w x y z
// 2.3.0: a z c d e f g h i j k l m b o p q r s t u v w x y n
// 2.3.1: a z c d e f g h i j k l m b o p q r s t u v w x y n",JasonCust,NONE,2015-05-13 19:04:55+00:00,True,2015-05-13 21:47:34+00:00,0.11,,2,3,2015-05-13 19:23:41+00:00,0.01,slackersoft,MEMBER,1,0,0,1,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
852,jasmine.any() without argument fails with unhelpful error message,"Using jasmine.any() is not correct, as it should be jasmine.anything() or jasmine.any(ConstructorHere).  However, the error message is not very helpful in telling you this.  We suggest checking for undefined in any() and giving a more descriptive error message.  This is the error that we get when using jasmine.any():
TypeError: Cannot read property 'name' of undefined
    at Object.j$.fnNameFor (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:151:16)
    at Any.jasmineToString (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:2416:33)
    at PrettyPrinter.format (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:1597:31)
    at PrettyPrinter.StringPrettyPrinter.emitArray (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:1668:12)
    at PrettyPrinter.format (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:1615:16)
    at Object.pp (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:1734:25)
    at Object.compare.result.message (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:2995:124)
    at Expectation.wrapCompare [as toHaveBeenCalledWith] (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:1395:30)
    at Object.<anonymous> (http://localhost:3000/assets/behaviors/hit_report_histogram_spec.self-7425606b3113ffbe282f01272fad4b19d49158a116726d0eaba8a85b3f0aa4de.js?body=1:25:26)
    at attemptSync (http://localhost:3000/assets/jasmine.self-9b30f2f3d16490c8b6cf33d9f21ef71b5634060fdf39ac2e47477d0327021b8e.js?body=1:1790:24)

This is our spec:
describe('Unicorn', function() {

  beforeEach(function(){
    spyOn(Chartist, 'Bar');
    callMyMethod();
  });

  it('creates a new Chartist.Bar object', function() {
    expect(Chartist.Bar).toHaveBeenCalledWith(
      jasmine.any(),
      {
        labels: ['1901-01', '1901-02', '1901-13'],
        series: [
          [4, 18, 0]
        ]
      }
    );
  });
});
@mbildner
Jasmine version: 2.3.4
Jasmine rails version: 0.10.8",danfinnie,CONTRIBUTOR,2015-05-14 18:04:45+00:00,True,2015-05-18 21:26:59+00:00,4.14,,2,1,2015-05-14 18:38:47+00:00,0.02,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
853,feature request: toHaveBeenCalledOnce,"I find myself doing: expect(searchModel.clearSearchCallback.calls.count()).toEqual(1); a lot to make sure a method has been called, but only one time.
It'd be great if there was a toHaveBeenCalledOnce method.
Thanks!",aligneddev,CONTRIBUTOR,2015-05-15 16:31:54+00:00,True,2015-06-06 04:10:20+00:00,21.49,,2,1,2015-05-29 21:40:40+00:00,14.21,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
855,Pending vs disabled,"Hi,  I know there's been some discussion of pending vs disabled specs (#840).  I was slightly surprised to discover that disabled specs are not reported (a least in jasmine-npm) so I raised an issue at jasmine/jasmine-npm#45, but i understand this is perhaps the intended behaviour.
Currently I think xit marks as pending and xdescribe marks as disabled.  It would be good if they did the same thing. If it's clear what the behaviour should be I could (try to) work up a pull request.
To my mind, pending is more useful. I'm not sure what the use-case is for disabling specs and not having them show up in reporting?",ljwall,CONTRIBUTOR,2015-05-17 14:48:20+00:00,True,2015-08-03 22:02:21+00:00,78.3,,3,4,2015-05-28 19:19:47+00:00,11.19,slackersoft,MEMBER,1,1,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
857,support for JSX?,"I added .JS.JSX files in my Rails app to test React, all of my Jasmine specs are now failing. Are there any setup or ways to ignore .JSX files from my test suite.",ramyathulasingam,NONE,2015-05-18 23:30:38+00:00,True,2015-05-18 23:35:53+00:00,0.0,,2,2,2015-05-18 23:35:53+00:00,0.0,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
858,Identify the step number were jasmine + protractor test failed,"I am developing tightly coupled Protractor + Jasmine automation system with our test cases management system.
Steps in test procedure also documented in test scripts, when ever protractor test cases fails, I want to identify in which step this is failed and reported in XML
example Test expected like this
@Step1 login_page.enterUserName('user1');
@step2 login_page.enterPassword('password');
@Step3 home_page = login_page.selectLogin();
If this test failed @ step2, this should be reported in XML ,any thought for implementing this ?
Regards, Rayees",rayeesnp,NONE,2015-05-19 17:47:37+00:00,True,2015-05-19 19:22:28+00:00,0.07,,2,6,2015-05-19 19:22:28+00:00,0.07,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
859,Error: Spies must be created in a before function or a spec,"1) tracks that the spy was called
A spy
Error: Spies must be created in a before function or a spec
at http://localhost:9126/base/node_modules/jasmine-core/lib/jasmine-    
core/jasmine.js?578a1e5ff14db21b04e2d6db7fd0eda37042440c:687

My Test code should be ok, so I am out of knowledge where the root cause for this error could be. I already re-installed karma-jasmine.
describe 'A spy', ->
  foo = undefined
  bar = null
  beforeEach ->
    foo = setBar: (value) ->
      bar = value
      return
    spyOn foo, 'setBar'
    foo.setBar 123
    foo.setBar 456, 'another param'
    return
  it 'tracks that the spy was called', ->
    expect(foo.setBar).toHaveBeenCalled()

This is from the devDependencies section of my package.json:
..
""jasmine"": ""^2.3.1"",
""jasmine-core"": ""^2.3.4"",
""karma"": ""^0.12.32"",
""karma-chai"": ""^0.1.0"",
""karma-chai-plugins"": ""^0.5.0"",
""karma-chrome-launcher"": ""^0.1.12"",
""karma-coffee-preprocessor"": ""^0.2.1"",
""karma-firefox-launcher"": ""^0.1.4"",
""karma-html2js-preprocessor"": ""^0.1.0"",
""karma-jade-preprocessor"": ""0.0.11"",
""karma-jasmine"": ""^0.3.5"",
""karma-mocha"": ""^0.1.10"",
""karma-ng-html2js-preprocessor"": ""~0.1.0"",
""karma-ng-jade2js-preprocessor"": ""^0.1.2"",
""karma-ng-scenario"": ""~0.1.0"",
""karma-phantomjs-launcher"": ""^0.1.4"",
""karma-requirejs"": ""~0.2.1"",
""karma-script-launcher"": ""~0.1.0"",
""karma-spec-reporter"": ""0.0.19"",
..",meshfields,NONE,2015-05-20 12:05:26+00:00,True,2015-05-30 00:46:48+00:00,9.53,,2,3,2015-05-29 21:56:33+00:00,9.41,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
860,How to test throw without actually throw ? like spyOn.,"Here is my spec
expect(function() {
  throw new Error('testing error');
}).toThrow();

But how can I test it without throw the error ? like the spyOn way.",lili21,NONE,2015-05-21 05:00:38+00:00,True,2015-05-21 05:02:03+00:00,0.0,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
861,is it possible to run only one file by command? ,"for example:
i have several files, but in developing, i may just run one of them by jasmine, as so far, it seems jasmine will run all the files.  i want to know if there is a way to run a file by format like this: jasmine aFileSpec.js",shoyer2010,NONE,2015-05-22 09:30:27+00:00,True,2015-05-25 18:01:24+00:00,3.35,,2,2,2015-05-22 17:20:59+00:00,0.33,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
862,"""Template.leaderboard.players() is not a function"" in leaderboard-jasmine ","Dear All,
I'm trying to figure out client unit testing on template helper functions. After I cloned and ran the leaderboard-jasmine code (unchanged), I got this error:

Template.leaderboard.players() is not a function

which comes from
// velocity-examples/leaderboard-jasmine/tests/jasmine/client/integration/LeaderboardSpec.js
var players = Template.leaderboard.players().fetch();
After digging a bit here, I changed above line to below:
// velocity-examples/leaderboard-jasmine/tests/jasmine/client/integration/LeaderboardSpec.js
spyOn(Template.leaderboard.__helpers, 'players')
which resulted in another error:

players() method does not exist

I have seen the 2nd usage in the Telescope repo, so it should have worked. Does anyone have had similar experience and sorted it out?",totorokk,NONE,2015-05-25 00:54:03+00:00,True,2015-05-28 20:42:56+00:00,3.83,,2,1,2015-05-28 20:42:56+00:00,3.83,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
863,Issue with angular.mock.inject method,"I am using karma/jasmine and i have the following jasmine test case .
'use strict';

describe('companyService', function() {

var $httpBackend, companyService;

beforeEach(angular.mock.module('myApp'));

beforeEach(angular.mock.inject(function($httpBackend , companyService ) {
    $httpBackend = $httpBackend;
    companyService = companyService;
}));

it('should return a promise for getCompany function', function() {
    expect(typeof companyService.getCompany('foobar').then).toBe('function');
}); 

});

for some reason the execution doesn't enter the angular.mock.inject(function($httpBackend , companyService ) {  code block . Because of this i am getting the following error when i try to access getCompany() method .
    minErr/<@C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/bower_components/angular/angular.js:63:12
    loadModules/<@C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/bower_components/angular/angular.js:4138:15
    forEach@C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/bower_components/angular/angular.js:323:11
    loadModules@C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/bower_components/angular/angular.js:4099:5
    createInjector@C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/bower_components/angular/angular.js:4025:11
    workFn@C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/node_modules/angular-mocks/angular-mocks.js:2425:44
    TypeError: companyService is undefined in C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/test/company/Compa
nyServiceSpec.js (line 15)
    @C:/Users/userone/Documents/myAppPkg/myApp/WebApiRole/test/company/CompanyServiceSpec.js:15:16

if this got something to do with a missing of a dependency , how do i test (isolate) the missing dependency . The only error i get is the undefined error which is not exactly helping me to find the rootcause . I have used karma start --log-level debug but it doesn't tell you much about the issue . If anyone can help me to pinpoint the issue rootcause it would be much appreciated .",mal90,NONE,2015-05-26 11:42:23+00:00,True,2015-09-24 21:22:07+00:00,121.4,,4,9,2015-05-28 21:10:05+00:00,2.39,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
865,Allow filtering of specs when tests being run,"Currently, by using a custom boot.js file a specFilter can be used to select which tests should be run.  The problem is that this filtering happens when tests are being first registered with Jasmine, rather than when they are being run.  This means that creating a single page interactive test runner is impossible as it is not possible to filter tests based on user input without refreshing the page.",keirlawson,NONE,2015-05-26 15:39:18+00:00,True,2015-10-01 17:38:15+00:00,128.08,,2,5,2015-05-29 21:35:21+00:00,3.25,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
866,Add setImmediate support to jasmine.clock,"The code I am testing is leveraging setImmediate() to defer a function call. It would be nice to use Jasmine's clock to fast-forward over the delay similar to how I would use it to fast-forward over a setTimeout(fn, 0) call.",Aaronius,NONE,2015-05-26 19:55:48+00:00,False,,,,4,6,2015-05-28 21:30:49+00:00,2.07,slackersoft,MEMBER,1,0,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
867,toHaveBeenCalledWith Can't Match,"For some reason toHaveBeenCalledWith is unable to match some calls to my spy in one oddball test even though the calls and expectations are identical. I'm making two calls to the same method with different parameters and then in the test I check to see if that same method was called two separate times with the two different sets of parameters. The first expectation passes and the second expectation fails every time.
The test in question:
it('removes the transform on feed and globalMenuWrap', function() {
      expect(utility.setPrefixedStyle).toHaveBeenCalledWith($m('#feed, .globalMenuWrap'), 'transform', '');
      expect(utility.setPrefixedStyle).toHaveBeenCalledWith($m('.sideNav'), 'transform', '');
});

The code that is most definitely getting executed:
global.requestAnimationFrame(function(){
      $m(document.body).removeClass(""showSideNav"");
      utility.setPrefixedStyle($m('#feed, .globalMenuWrap'), 'transform', '');
      utility.setPrefixedStyle($m('.sideNav'), 'transform', '');
});

The resulting failure log which makes no sense:
Expected spy setPrefixedStyle to have been called with
[ ({ length: 0, prevObject: ({ 0: HTMLNode, context: HTMLNode, length: 1 }), context: HTMLNode, selector: '.sideNav' }), 'transform', '' ] 

but actual calls were

[ ({ 0: HTMLNode, 1: HTMLNode, length: 2, prevObject: ({ 0: HTMLNode, context: HTMLNode, length: 1 }), context: HTMLNode, selector: '#feed, .globalMenuWrap' }), 'transform', '' ], 
[ ({ length: 0, prevObject: ({ 0: HTMLNode, context: HTMLNode, length: 1 }), context: HTMLNode, selector: '.sideNav' }), 'transform', '' ].

As you can see from the above print out, the calls are actually identical and toHaveBeenCalledWith seems to be unable to match anything past the first call made to the spy.
As a workaround, I also tried using argsFor(1) but this also failed in even more bewildering way. Here is what that test looks like:
it('removes the transform on sideNav', function() {
      expect(utility.setPrefixedStyle.calls.argsFor(1)).toEqual([$m('.sideNav'), 'transform', '']);
});

And here is the bewildering failure log:
Expected 
[ ({ length: 0, prevObject: ({ 0: HTMLNode, context: HTMLNode, length: 1 }), context: HTMLNode, selector: '.sideNav' }), 'transform', '' ] 
to equal 
[ ({ length: 0, prevObject: ({ 0: HTMLNode, context: HTMLNode, length: 1 }), context: HTMLNode, selector: '.sideNav' }), 'transform', '' ].",johnnyshankman,NONE,2015-05-28 16:29:12+00:00,True,2015-09-24 21:25:46+00:00,119.21,,3,7,2015-05-28 16:46:15+00:00,0.01,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
868,Jasmine + .swf (jasmine.yml?),"Rails 4, Backbone + Marionette, Jasmine 2.1.3
I have added the DataTables TableTools plugin to our Rails app, and am trying to test that a certain callback gets called when the user attempts to export a PDF and Excel file. However, the TableTools plugins relies of Flash (a .swf file) for this functionality.
I am able to successful check that the event in question gets called when the user prints using the plugin, which does need the Flash functionality. However, when running the tests, the event does not get called when I try to export a PDF of Excel file.
I imagine the problem could be because I need to add the assets/copy_csv_xls_pdf.swf to jasmine.yml, but I don't know if this is the right approach.
Is what I am trying to do even possible using Jasmine?",NavyAnt24,NONE,2015-05-28 21:08:47+00:00,True,2015-05-29 21:29:06+00:00,1.01,,2,1,2015-05-29 21:29:06+00:00,1.01,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
870,Jasmine using anonymous instead of Object,"Hello All,
I have a test that it is checking that the content of two objects is equal, this test used to work in jasmine 1.3 but it doesn't work in Jasmine 2.x, I don't understand what ""anonymous"" means, this is the first time that I have encounter this issue with the framework, any help is greatly appreciated
Expected [ anonymous({ request: '321455' }) ] to equal [ Object({ request: '321455' }) ]",alxdg,NONE,2015-05-29 21:08:50+00:00,True,2015-09-24 21:08:47+00:00,118.0,,2,2,2015-05-29 21:21:23+00:00,0.01,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
872,.toHaveBeenCalledWith and modified objects,"The actual problem happens thanks to object references—I realize it's not a bug, but it really looks like that from the first sight. Probably you have a solution or some advice for that.
describe('spy issue', function() {
    var foo = {};
    function injectAndCall(prop, val, cb) {
        foo[prop] = val;
        console.log(foo);
        cb(foo);
    };

    it('spy issue', function() {
        var mySpy = jasmine.createSpy('test');

        injectAndCall('a', 0, mySpy);
        injectAndCall('b', 1, mySpy);

        expect(mySpy).toHaveBeenCalledWith({ a: 0 });
        expect(mySpy).toHaveBeenCalledWith({ a: 0, b: 1 });
    });
});
The response is:
Expected spy test to have been called with [ Object({ a: 0 }) ] but actual calls were [ Object({ a: 0, b: 1 }) ], [ Object({ a: 0, b: 1 }) ].
If you check the console, however, you'll get:
{ a: 0 }
{ a: 0, b: 1 }

May be this could be solved with deep-cloning arguments for spies?
This example is quite easy, but this also could happen when foo has a reference to another object inside, and the latter in its turn is a subject to modifications.",shamansir,NONE,2015-06-01 09:45:11+00:00,True,2016-02-16 23:01:14+00:00,260.55,,3,5,2015-06-01 10:05:57+00:00,0.01,shamansir,NONE,1,1,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
873,beforeAll called before beforeEach from the parent describe,"I have just encountered something which I think is an issue. Let's have the following simple test:
describe('level 1', function () {
    beforeEach(function () {
        console.log('Level 1 beforeEach');
    });

    describe('level 2', function () {
        beforeAll(function () {
            console.log('Level 2 beforeAll');
        });

        it('test 1', function () {
            console.log('Test 1');
        });

        it('test 2', function () {
            console.log('Test 2');
        });
    });
});
I would expect that console output would be:
Level 1 beforeEach
Level 2 beforeAll
Test 1
Level 1 beforeEach
Test 2

However, the actual output is:
Level 2 beforeAll
Level 1 beforeEach
Test 1
Level 1 beforeEach
Test 2

I am not sure if this behavior is expected but it strikes me as not obvious and it is definitely not documented.",ondrejhanslik,NONE,2015-06-02 08:53:26+00:00,True,2015-06-05 03:25:22+00:00,2.77,,12,20,2015-06-05 03:25:22+00:00,2.77,slackersoft,MEMBER,1,1,0,10,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
875,Is there a way to get a handle of the spec name in the AfterEach block ?,"Hi Team,
We can perform jasmine.getEnv().currentSpec.description to get the name of the test in the AfterEach block in Jasmine 1 version for protractor but doesn't work when switching to jasmine2 framework in Protractor.
I see a closed story here: #611.
The scenario specifically where I would use is to capture screenshot with file name containing the spec name.
Is it possible to bring back the deprecated feature or provide a different mechanism that I can include in every spec file in the afterEach block to capture screenshots with the filename containing the spec name.",raghavan85,NONE,2015-06-10 22:38:36+00:00,True,2015-06-11 21:39:31+00:00,0.96,,2,2,2015-06-11 21:40:40+00:00,0.96,raghavan85,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
876,Is there a standard for object method tests in Jasmine?,"i.e., testing new List()).add(), FooCollection.index (static methods)
is it('List#add""...)
or
it(""List.add""...)
preferred?",bingomanatee,NONE,2015-06-12 16:50:00+00:00,True,2015-06-12 19:52:04+00:00,0.13,,2,1,2015-06-12 19:52:04+00:00,0.13,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
877,Execute a single spec process out of the top specs tree,"Hi all,
Correct me if I'm wrong but,
even though I'm passing the suites Ids to the ""execute"" method the reporter still process the entire specs tree.
Specifying the specFilter or the suites IDs - ends with updating the spec status = ""disabled"" on the SpecDone phase, but what about the entire lifecycle?
Currently there's no method for setting the top level suite NOR controlling of which suite to be run.
I did an ugly hack messing up with the topSuite children.
Can you please give a way of executing a single / multi specs?
Thank you",lastboy,NONE,2015-06-14 12:27:10+00:00,True,2015-10-15 23:53:02+00:00,123.48,,2,6,2015-06-30 15:06:42+00:00,16.11,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
878,Improved Documentation,"introduction.html contains almost the entirety of the Jasmine documentation with no form of navigation.
It would be very very useful to have at minimum a table of contents so that it is easy to jump to specific sections of the documentation when needed.",alex-dow,NONE,2015-06-15 20:47:31+00:00,True,2015-06-30 15:19:08+00:00,14.77,,2,1,2015-06-30 15:19:08+00:00,14.77,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
880,Not running all tests,"I'm on 2.2.0 and typically when I have more than 10 tests, it will only run the first 10 and not the others. Most of my tests are doing api calls which take a little while. If I remove the api calls it works fine with more tests. I can't figure out why though I believe it has something to do with the timeout function. I know if I remove the if statement where it's checking for maximumSpecCallbackDepth in clearStack(), it's fine.
I'm running this in a Nashorn environment with a custom reporter and using jasmine.clock().install();.
Has anyone else experience this or have any idea what it may be?",wejrowski,NONE,2015-06-20 00:36:07+00:00,True,2016-02-23 23:59:11+00:00,248.97,,4,10,2015-06-30 15:23:22+00:00,10.62,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
881,Feature Request: Merge `describe` description with the same name ,"It could be helpful for storing specs in different files:
theme-a/
    sub-theme.spec.js 
    another-sub-theme.spec.js 
theme-b/
    sub-theme.spec.js 
    another-sub-theme.spec.js 

where sub-theme.spec.js contains:
describe('theme-a', function() {
    describe('sub-theme', function() {
         // specs
    });
});
and another-sub-theme.spec.js contains:
describe('theme-a', function() {
    describe('another-sub-theme', function() {
         // specs
    });
});
so in the end in the output they are combined in:
theme-a
    sub-theme
        ...specs...
    another-sub-theme
        ...specs...",shamansir,NONE,2015-06-20 18:34:25+00:00,True,2015-06-21 21:12:35+00:00,1.11,,2,2,2015-06-21 21:12:35+00:00,1.11,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
882,Expectations in async function are not asserted,"Context
Expects declared in asynchronous function are not asserted.
Environment
Protractor 1.6.1 (which packs Jasmine 2.1.1)
Request 2.53.0
Example
    var request = require('request');
    describe('async test', function() {
        it('should verify after done', function(done) {
                var options = {
                        url: 'http://www.google.com',
                        method: 'GET',
                        json : {},
                        headers: {
                            'Accept':'*'
                        }
                };

                request(options, function(error, message, body) {
                    expect(true).toEqual(false);

                    done();
                });
        });
    });
The outcome of this test is successful (but it clearly should fail). But when I replace the done invocation with setTimeout(done, 1000), it fails.",jeroenvekemans,NONE,2015-06-23 10:14:23+00:00,True,2015-08-01 16:03:50+00:00,39.24,,2,2,2015-07-01 06:56:50+00:00,7.86,ljwall,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
883,I'd like to be able to run the Jasmine project specs in the browser without needing Ruby,"In my first pull request, I went through the steps of getting Ruby working (http://geekswithblogs.net/Aligned/archive/2015/06/03/my-github-pull-request-for-jasmine-experience.aspx), but now I have a new computer and don't want to do it again :-). However, I still have a desire to contribute.
I think it'd also help lower the entry boundary for others to contribute.
I'd like to do grunt serve from the command line, then browse to the url and run the tests in the browser and debug.
I started last night, but I don't know enough to get it working. Should this use express? Is ""serve"" a good name for the grunt task?",aligneddev,CONTRIBUTOR,2015-06-30 15:59:30+00:00,True,2019-03-26 00:57:06+00:00,1364.37,,7,9,2015-07-31 21:47:36+00:00,31.24,slackersoft,MEMBER,2,2,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
884,"runnableLookupTable is added to, but never used - causes memory increase for no reason","The 'runnableLookupTable' is created and added to, but never used. This causes un-required memory increases.
Is there any reason I shouldn't put in a PR to remove this?",lostthetrail,NONE,2015-07-01 17:13:07+00:00,True,2015-09-24 21:31:37+00:00,85.18,,2,2,2015-07-01 23:41:30+00:00,0.27,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
885,Document fail() function,"Found this by looking through github issues and it's really useful, however as far as I can see it isn't mentioned anywhere in the public-facing documentation.",keirlawson,NONE,2015-07-03 19:40:28+00:00,True,2015-07-12 08:59:25+00:00,8.55,,2,2,2015-07-12 07:15:03+00:00,8.48,ljwall,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
886,Spies and promises,"They don't work from promises callbacks for some reason:
    validateToken: function () {
        var options = {
            url: this.appOptions.exAuthUrl,
            data: {
                method: 'validateToken',
                token: this.get('token')
            }
        };
        return Promise.resolve($.get(options)).then(function (obj) {
            if (obj.status === ""OK"") {
                return true;
            } else {
                throw new Error(""Invalid token"");
            }
        });
    }

       describe(""when calling validateToken"", function () {
            var successMock, errorMock;
            beforeEach(function () {
                model.set('token', 'testtoken');

                successMock = jasmine.createSpy('success');
                errorMock = jasmine.createSpy();
            });

            it(""Should resolve promise if response is correct and status OK"", function (done) {

                model.validateToken().then(function (data) {
                    console.log('success');
                    successMock();
                }).catch(function () {
                    console.log('err');
                }).finally(function () {
                    console.log('don');
                    done();
                });

                jasmine.Ajax.requests.mostRecent().respondWith({
                    status: 200,
                    responseText: '{""status"": ""OK"", ""response"": ""text""}'
                });


                expect(successMock).toHaveBeenCalled();
            });
      });
Gives me following:
'success'
'don'
Expected spy success to have been called.
Jasmine 2.3.4",asvetliakov,NONE,2015-07-07 01:34:04+00:00,True,2015-09-25 00:08:25+00:00,79.94,,3,6,2015-07-08 21:38:21+00:00,1.84,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
887,Add before and after hooks,"Hi,
Any possibility of adding before/after hooks? i do understand there's a beforeEach/afterEach that runs before/after executing every spec, but what i'm looking for is a hook that's executed before/after all the specs.
Regards.",lvaldovinos,NONE,2015-07-09 15:21:49+00:00,True,2015-07-09 16:06:31+00:00,0.03,,2,2,2015-07-09 16:06:31+00:00,0.03,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
888,Spies leak into other specs,"My team is using Jasmine-core 2.3.3.  We recently had an issue where a spy in one test leaked into another test.
From what I understand, a spy that is set up in a test automatically gets removed after the test has completed.  Developers do not have to do anything manual in order to remove a spy.
Why would a spy from one test leak into another?  What could I be doing wrong?",hackingbeauty,NONE,2015-07-09 17:42:26+00:00,True,2015-10-15 23:31:38+00:00,98.24,,3,8,2015-07-09 17:46:40+00:00,0.0,r4j4h,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
889,Disable Jasmine's fdescribe() and fit() based on environment,"Posted on Stack Overflow: http://stackoverflow.com/questions/31304447/disable-jasmines-fdescribe-and-fit-based-on-environment
Cross posting here in case anyone has any ideas on how to solve this...",guyellis,NONE,2015-07-09 20:29:52+00:00,True,2015-07-16 19:18:06+00:00,6.95,,2,1,2015-07-16 19:18:06+00:00,6.95,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
890,"Bug in timeouts, jasmine 2.3.1, protractor 2.1.0","When I have a few test cases and one of the test fails because of timeout , all the subsequent tests fail because of timeout. If I increase the timeout for the failing test and make that test case pass, no subsequent test case fails. All work fine. Why subsequent test cases use timeout specified for previous test case?
Below is my spec file:
'use strict';
describe('page', function() {
beforeEach(function() {
console.log('------- in before each');
});
afterEach(function() {
console.log('------- in after each');
});
it('test 1',function() {
return browser.get('https://docs.angularjs.org/api');
});
it('test 2',function() {
return browser.get('https://angularjs.org/');
},100);
it('test 3',function() {
return browser.get('https://docs.angularjs.org/tutorial');
});
it('test 4',function() {
return browser.get('https://docs.angularjs.org/misc/contribute');
});
});
below is my conf file:
exports.config = {
seleniumAddress: 'http://localhost:4444/wd/hub',
specs: ['todo-spec.js'],
capabilities: {
'browserName': 'firefox',
},
framework: 'jasmine2',
};
So test 2 fails and test 3 and test 4 also fail.
If test 2 passes then test 3 and test 4 pass .
Also I observed that this problem occurs if using afterEach in suite. If we are not using afterEach , everything works fine.
@slackersoft",nishakchaudhari,NONE,2015-07-09 22:11:49+00:00,True,2015-09-24 21:45:12+00:00,76.98,,2,4,2015-07-31 21:55:07+00:00,21.99,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
891,update glob dependency to latest,"Having problem running jasmine in strict mode on node 0.10, 0.12 and JXcore SM. Didn't test with io.js but pretty sure the result would be the same
save given script below into 'test.js'
require('jasmine');

npm install jasmine
node --use-strict test.js
error:
node_modules/jasmine/node_modules/glob/glob.js:323
    function next(exists, isDir) {
    ^^^^^^^^
SyntaxError: In strict mode code, functions can only be declared at top level or immediately within another function.

updated node-glob to latest and there is no problem left.",obastemur,CONTRIBUTOR,2015-07-14 23:36:00+00:00,True,2015-07-16 19:10:21+00:00,1.82,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
893,No tests displayed in spec window,"Hi,
I've added Jasmine 2.2.0 via Nuget to my project angular project which is hosted in Visual Studio. When I run the SpecRunner I don't see the specs list but only the title. If I inspect the page I can see that all the specs are there but not displayed. Can you please help?",DennisNerush,NONE,2015-07-17 22:01:37+00:00,True,2015-10-04 20:40:42+00:00,78.94,,2,9,2015-08-03 20:48:56+00:00,16.95,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
894,Only show output for exclusively run test,"When I run a test exclusively using fit or fdescribe, the reporter will log all of my tests alongside the exclusively ran test. Is it possible to only show the output for the exclusively ran test? This would be useful for debugging when the user has lots of tests.",OliverJAsh,NONE,2015-07-20 14:22:45+00:00,True,2015-09-01 04:49:48+00:00,42.6,,2,3,2015-07-31 22:55:25+00:00,11.36,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
895,Unable to install clock when using non-native timing functions,"The check introduced in d137b83 to ensure that jasmine.clock().install() is called on native timing functions seems a little over zealous. I'm working on a project at the moment that patches the timeout functions to show developers warnings when they forget to use clock e.g.
window.setTimeout = function () {
  console.warn('setTimeout() has been called under test, use jasmine.clock() to stub out the timing functions');
}
Sadly now I get the following error message. ""Error: Jasmine Clock was unable to install over custom global timer functions."". Would it not be better to see if clock.install() has been called twice and then raise the error?
Here's a Jasmine test suite exhibiting the problem I'm seeing.
http://jsbin.com/kagixozaze/edit?js,output",aron,NONE,2015-07-20 15:38:39+00:00,True,2015-08-03 18:59:02+00:00,14.14,,2,1,2015-08-03 18:59:02+00:00,14.14,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
896,describe should throw when it receives a function that expects a `done` callback.,"I spent half an hour debugging this.
describe('stuff', function (done) {
    it('works good', function () {
        myHttp.get(url).then(function (response) {
            expect(response.data.length).toBeGreaterThan(10000);
        }).then(done, fail);
    });
});

I got an error in some other unrelated test, with no stacktrace (because async), and had to fire up a debugger to understand what's happening. And it was just a simple mistake.
(In case you still didn't notice: I put done in describe instead of it.)
I believe this wouldn't be hard to do (as you already look at the arguments of the function given in it) and would save other programmers from mistakes like this.",mik01aj,NONE,2015-07-23 10:25:52+00:00,True,2015-10-27 21:13:57+00:00,96.45,,4,5,2015-09-01 20:44:44+00:00,40.43,slackersoft,MEMBER,1,0,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
897,"Log object without ""..."" in properties","I'm trying to debug the location of a property in my object, which has a nested structure. When I log it in the test, I get the object, but most of the property values are ""..."" instead of their actual values. How can I log the full object with all its values so that I can properly debug?",davidlmiller21,NONE,2015-07-27 15:41:06+00:00,True,2015-08-01 00:16:05+00:00,4.36,,2,3,2015-07-27 18:58:27+00:00,0.14,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
898,Specs are executed before async beforeAll completes,"We're using nested describe with beforeAll that does async calls, e.g.
describe('test suite', function(){
   beforeAll(function(done) {
       // login.... 
      // then wait for url  ...
      .then(function(){
          done();
       });
   }, 20000);

   describe('verify bla', function() {
          it('should bla....', function() {

         });
   });
});
From the sample code above, the it spec gets executed before beforeAll calls done.
We are using jasmine v2.3.4.
Thanks.",mocsharp,NONE,2015-07-27 16:57:50+00:00,True,2015-07-27 20:01:02+00:00,0.13,,2,4,2015-07-27 17:45:03+00:00,0.03,ljwall,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
899,Disable Exception Catching,"I'm using jasmine with webpack which combines my source files into a single file and generates source maps so that when there's an error I know where it is. Unfortunately with Jasmine (and the lack of source map support) when there's an error the HTML test runner swallows the bug and shows it in the DOM with the compiled file and line numbers. If there were a way to disable Jasmine's error catching, the browser would translate the file/line numbers using the source map so I'd know where it is. Without this I have literally no idea even which file the bug is originating from. How do I turn off exception catching?",geddski,NONE,2015-08-01 20:20:50+00:00,True,2015-08-01 20:24:14+00:00,0.0,,1,1,2015-08-01 20:24:14+00:00,0.0,geddski,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
900,Parameterized tests in Jasmine,"Is it possible to add this extremely useful feature to Jasmine? Something like in neckbeard, but native:
var Ʊ = require('neckbeard-node.js');                      
describe('spec which loops', function() {
  describe('Here is some functionality', function() {
    Ʊ.iterate('first', 'second', 'sum')
     .where(   3,       3,        6,
               10,      4,        14,
               7,       1,        8
     );
     Ʊ.loop('#first plus #second is #sum', function(first, second, sum) {
       expect(first+second).toEqual(sum);
     });
  });
});",ctapobep,NONE,2015-08-04 18:36:21+00:00,True,2015-08-04 18:57:52+00:00,0.01,,3,2,2015-08-04 18:57:52+00:00,0.01,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
901, SpyOn getterTypeError: setting a property that has only a getter ,"Hi friends
i am using es6 with babeljs
Store.js
var _allPackages = [];

class Store() {
   get allPackages() {
        return _allPackages;
    }
}

export default new Store();

View.js
import Store from './store';

class View() {
   convertPackages() {
       Store.allPackages.forEach() {}
   }
}

export default new Store();

In unit test
import Store from './store';
import View from './store';

describe('View')
spyOn(Store, 'allPackages').and.returnValue([]);

it causes an issue * TypeError: setting a property that has only a getter*
How can i use sponOn in this case. Thnaks !",lovedota,NONE,2015-08-07 06:03:16+00:00,True,2015-08-07 16:35:50+00:00,0.44,,2,1,2015-08-07 16:35:50+00:00,0.44,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
903,RequireJS Shim doesn't seem to be working correctly when loaded into Jasmine,"https://jsfiddle.net/so2z3gvy/5/
The issue here is that the shim for ""olLayerSwitcher"" doesn't seem to be working when ran through Jasmine.
This is a distilled implementation of a project I am trying to write using RequireJR and Jasmine.
The OpenLayers3 library is AMD-capable. I am able to load the library through require and it tests out fine in Jasmine as being defined. However, the olLayerSwitcher OpenLayers3 plugin is not AMD so I am using a shim to load it. It requires that ""ol"" be a variable that it then updates with functionality.
While this works when loading the application itself in a browser in the same configuration I'm using in this fiddle, it doesn't seem like it works properly using Jasmine.
The Spec runner here is a hybrid of what the Jasmine-maven plugin creates (my project is a java project and I test on build) and what I was able to cobble together to get Jasmine to load in jsfiddle properly.
So the question here is: Why is it that this works outside of Jasmine? It seems like Jasmine is not allowing RequireJS shimming to work properly.",isuftin,NONE,2015-08-09 02:13:44+00:00,True,2015-09-22 10:23:56+00:00,44.34,,2,1,2015-09-21 20:23:51+00:00,43.76,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
904,Configuration option pointing to location of jasmine.json,As far as our build process it is inconvenient to depend on the standard location of the jasmine.js file. Global environment variable doesn't work well either because it is global and we have more than one project that needs testing. So can you add an option to specify where jasmine.js is via a command line argument? Thank you.,zpdDG4gta8XKpMCd,NONE,2015-08-11 08:08:35+00:00,True,2015-10-28 19:11:22+00:00,78.46,,2,2,2015-09-01 05:19:09+00:00,20.88,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
905,jasmine.clock().tick() bug with nested setTimeout(),"I think, this simple test describes the issue
describe('Jasmine clock', function () {
  beforeEach(function () {
    jasmine.clock().install();
    jasmine.clock().mockDate();
  });

  afterEach(function () {
    jasmine.clock().uninstall();
  });

  it('has bug with nested setTimeout()', function () {
    var calls = [
      false, // before timer 1
      false, // timer 1
      false, // before timer 2
      false  // timer 2
    ];

    var startTime = Date.now();

    setTimeout(function () {
      calls[1] = true;
      expect(Date.now() - startTime).toBe(2000); // Success

      setTimeout(function () {
        calls[3] = true;
        expect(Date.now() - startTime).toBe(3000); // Fail with actual = 2000
      }, 1000);
    }, 1000);

    calls[0] = true;
    expect(calls).toEqual([true, false, false, false]); // Success

    jasmine.clock().tick(2000);
    expect(calls).toEqual([true, true, false, false]); // Fail with actual = [true, true, false, true]

    calls[2] = true;
    expect(calls).toEqual([true, true, true, false]); // Fail with actual = [true, true, true, true]

    jasmine.clock().tick(1000);
    expect(calls).toEqual([true, true, true, true]); // Success
  });
});",UnikZ,NONE,2015-08-17 11:14:12+00:00,True,2015-09-01 04:36:51+00:00,14.72,,3,3,2015-08-29 00:16:36+00:00,11.54,ryanswood,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
907,"with my custom reporter,when run first,jasmine can find the files i will test,but when run second,null file found?how can i solve this problem?","var jasmine = new Jasmine();
console.log(""aaaaa"",jasmine);
try {
jasmine.loadConfig({
""spec_dir"": ""/opt/app/cafbot.yunos.com/test"",
""spec_files"": [
""/ui/*.js"",
""/ui/transform/.js"",
""__/animation/.js"",
""/layout/*.js""
],
""helpers"": [
""helpers//*.js""
]
});
console.log(""bbbbb"");
} catch (e) {
console.log(e);
}
                    var myCustomReporter = {
                        jasmineStarted: function(suiteInfo) {
                            passedCount = 0;
                            failedCount = 0;",byrhuwei,NONE,2015-08-18 11:17:40+00:00,True,2015-09-22 19:16:21+00:00,35.33,,2,1,2015-09-22 19:16:21+00:00,35.33,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
909,Create a spy once for all functions of same class,"To create two spies on functions of same class i do this:
spyOn(mockFooService, 'function1');
spyOn(mockFooService, 'function2');

Can i do something like this?
 spyOn(mockFooService, [
        'function1',
        'function2'
    ]);

Or maybe create spy on all functions of class like this:
spyOn(mockFooService)",rstm,NONE,2015-08-21 09:05:38+00:00,True,2015-10-28 19:37:31+00:00,68.44,,2,2,2015-09-22 19:22:02+00:00,32.43,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
910,jasmine.any() should warn on incorrect use,"Hello, I'm about average stupid and I accidentally did
expect(spy).toHaveBeenCalledWith(jasmine.any())
This gives a cryptic error Cannot read property 'name' of undefined and then jasmine hides the line numbers and just references the expect line in the test.
Anyway after 30 minutes of debugging I ended up in the code for jasmine.any() and realized it crashes like that if not given an argument. I figured out I should use jasmine.anything() but maybe someone else could be spared the headache :) Thanks for a great framework.",JDaance,NONE,2015-08-24 08:22:50+00:00,True,2015-08-24 17:02:21+00:00,0.36,,2,1,2015-08-24 17:02:21+00:00,0.36,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
911,Callback on timed out tests,"Hi
Would it be possible to add a callback to a test timeout event?
I'm running a test which works fine on my machine but times out on CI server. Because there are no exceptions I don't know what's going wrong, but I was thinking about keeping track of the test state and then in case of timeout, log the state, the last successful action or the callback I'm waiting for.
I can implement it in my tests with a setTimeout(() => { log(...) }, jasmine.DEFAULT_TIMEOUT_INTERVAL - 100); but maybe you guys could add a cleaner solution to jasmine.
Something like
describe('Timeout', () => {
   onTimeout(() => {
      console.log(details);
   });
   it('timesout somewhere', () => {});
});

What do you think?",piuccio,NONE,2015-08-28 08:47:06+00:00,True,2016-09-27 01:06:40+00:00,395.68,,3,2,2015-10-04 19:17:58+00:00,37.44,slackersoft,MEMBER,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
912,Allow me to pass a reason to `xit`,"It seems I have no way to pass a reason, if I use xit. It would be great to do this to get rid of the No reason given warning. Can we use a reason as a third param? xit('should foo', fooFn, 'ignore this')",donaldpipowitch,NONE,2015-08-28 09:41:25+00:00,True,2015-10-15 16:22:12+00:00,48.28,,3,3,2015-09-02 01:56:17+00:00,4.68,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
913,toHaveBeenCalledWith creates confusing output when used with single number argument,"Let's say you have a mock with a function like
var myMock = { doStuff = jasmine.createSpy('myMock.doStuff')}

and put that into a service that calls:
myMock.doStuff(2)

and then expect
expect(myMock.doStuff).toHaveBeenCalledWith(10)

jasmine creates the following error message:
Expected spy timeout.cancel to have been called with [ <circular reference: Object> ] but actual calls were [ <circular reference: Object> ].

If you use strings or more than one number argument everything gets printed fine. If the mock gets called with the expected value the test passes, so it seems to be just a formatting issue with the failure message.",SanityResort,NONE,2015-08-28 14:25:18+00:00,True,2015-10-05 12:15:47+00:00,37.91,,2,2,2015-10-04 01:54:00+00:00,36.48,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
914,[docs][improvement] including jasmine-ajax in commonJS environment,"Hello,
It took me a while to figure out that you can simply do npm install jasmine-ajax, then:
var anyName = require('jasmine-ajax');

describe('Jasmine is awesome because', function() {
   beforeEach(function() {
      // use as described in the docs
      jasmine.Ajax.install();
   });

  it('installs jasmine.ajax as a global', function() {
     jasmine.Ajax.stubRequest('/another/url').andReturn({
        ""status"": 200,
        ""contentType"": 'text/plain',
        'responseText': 'immediate response'
      });
  });
});

If you browserify this and include it in a html page (or run it with karma & karma-browserify) it works as expected. No need to download and include the mock-ajax.js file in the helpers directory. Yipee. Isn't this worth mentioning in the docs?",mediafreakch,NONE,2015-08-28 20:41:06+00:00,True,2015-08-28 20:47:37+00:00,0.0,,1,1,2015-08-28 20:47:37+00:00,0.0,mediafreakch,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
915,jasmine.clock().tick() sets Date to destination for all interim events,"Here's a simple test that demonstrates the problem.
describe('mocking time', function(){
  beforeEach(function() {
    jasmine.clock().install();
    jasmine.clock().mockDate(
      new Date(2015, 4, 20)
    );
  });

  afterEach(function() {
    jasmine.clock().uninstall();
  });

  it('sets time correctly for interim functions', function(){
    var actualTimes = [];
    setTimeout(function() { actualTimes.push(Date().getTime()); });
    setTimeout(function() { actualTimes.push(Date().getTime()); }, 1);
    jasmine.clock().tick(1);
    expect(actualTimes).toEqual([1432105200000, 1432105200001]);
  });
});
The failure we see is:
Expected [ 1432105200001, 1432105200001 ] to equal [ 1432105200000, 1432105200001 ].
The culprit is obvious. Here's the code from that link:
mockDate.tick(millis);
delayedFunctionScheduler.tick(millis);
I don't see any reason for mockDate.tick() to exist. Instead you want something like mockDate.advanceToMillis() that can be called somewhere around this line.",ryanswood,NONE,2015-08-29 00:13:15+00:00,True,2015-12-22 23:19:37+00:00,115.96,,7,7,2015-09-01 03:33:39+00:00,3.14,ClayShentrup,NONE,1,1,0,4,['has Tracker story'],False,False,False,False,False,False,False,False,True,False,False,False,False,False,False
916,.toThrow isn't async,"it('should not create a complete account', function(next) {
      expect(function() { 
        setTimeout(function() {
          throw new Error(); 
        });
      }, 1).toThrowError(Error);
});

Result
> api@1.0.0 test /var/www/api
> node test/run.js

Started
function () { 
        setTimeout(function() {
          throw new Error(); 
        });
      }
/var/www/api/test/controllers/TestSpec.js:36
          throw new Error(); 
                ^
Error
  at [object Object]._onTimeout (/var/www/api/test/controllers/TestSpec.js:36:17)
  at Timer.listOnTimeout (timers.js:110:15)

If you add this to line 3102 in jasmine-core/jasmine.js:
console.log('threw? ', threw);

You get this
threw? false",CodeOtter,NONE,2015-08-31 21:43:22+00:00,True,2015-09-01 04:47:10+00:00,0.29,,2,1,2015-09-01 04:47:10+00:00,0.29,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
917,"Error: ""Cannot read property 'appendChild' of undefined"" (2.3.4)","This happens occasionally (about once every three test runs), and only seems to affect Chrome browser.
I have traced the problem down to this line in jasmine-html.js (line 114, version 2.3.4):
symbols.appendChild(createDom('li', {
'symbols' is null at this point - it seems like the html report page has not been initialised yet. It seems to happen when there are nested ""describes"" in my test, and they each have a ""beforeEach()"", but I'm not sure if this is related.

If I let the debugger go, the test output looks like this:",danielalexiuc,CONTRIBUTOR,2015-09-01 02:14:52+00:00,True,2015-09-24 19:59:50+00:00,23.74,,2,1,2015-09-16 18:53:31+00:00,15.69,CharlieHess,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
918,Negative zero values in array,"I'm having an issue writing a test for an array which can contain negative values of zero. This:
expect([-0]).toEqual([0]);
fails, as does this:
expect([-0]).toBe([0]);
I understand the logic outlined in #579, but unless I'm missing a better way of writing this test this seems like a much more common case that someone actually wanting to distinguish between 0 and -0.",Aciho,NONE,2015-09-01 16:17:58+00:00,True,2015-10-28 21:37:45+00:00,57.22,,2,2,2015-09-22 19:31:45+00:00,21.13,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
920,Feature: Combinatorial and Pairwise unit test generators,"One of the best new features in NUnit is combinatorial test case generation using their Combinatorial and Pairwise attributes.
The All Pairs algorithm has been shown to significantly improve combinatorial test coverage without the large blow out in number of combinations that an exhaustive combinatorial test generator incurs.
NUnit Parameterized Tests

PairwiseAttribute - Source code - This is very useful!
CombinatorialAttribute - Source code

I'm sure they would be flattered if you used their algorithms.
I imagined Jasmine test generators would be implemented using this code pattern for V1:
  genAllPairs({ field1: [va1, val2], field2: [val3, val4] ... }).forEach(function(tuple) {
  it(""with "" + JSON.stringify(tuple), function() {

  });

  genAllCombinations({ field1: [va1, val2], field2: [val3, val4] ... }).forEach(function(tuple) {
  it(""with "" + JSON.stringify(tuple), function() {

  });

And then perhaps a V2 version that can cope with larger number of combinations and can yield a result before all tuples are all generated ...
  git( new AllPairs({ field1: [va1, val2], field2: [val3, val4]), function(tuple)  {
     it(""with "" + JSON.stringify(tuple), function() {

     });
  });

Now AllPairs() is a stateful iterator class used to generate a test case tuple sequence that the new Jasmine git method consumes.
You'd then want to also add fgit (focus) and xgit (exclude). You could also run each tuple over a gdescribe() test suite.
These code patterns are just my brainstorming.  Your experience and understanding of the Jasmine framework may dictate otherwise.",tohagan,NONE,2015-09-08 01:43:44+00:00,True,2015-09-24 16:09:32+00:00,16.6,,2,1,2015-09-24 16:09:32+00:00,16.6,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
921,Test suite won't contain failedExpectations on spec failure,"I've been looking into creating custom reporters to perform sanity checks within a single page application. To perform those checks I've created several specs within one suite and was going to use custom reporter to collect errors from each suite and send them to back-office application on suiteDone callback.
However I faced an issue with that: It seems latest version of jasmine won't contain failed expectation in suite results when it finishes. To demonstrate what I mean I created a simple jsfiddle based on the examples from here.
Take a look at suiteDone callback to see what happens. It will log the result object inspecting which will show no errors during suite execution. But if you look at specDone callback result you'll see that the spec is actually failed.
Not sure if it's something that I'm missing or an issue with the code.",RomanKapitonov,NONE,2015-09-08 16:15:16+00:00,True,2015-10-28 21:39:14+00:00,50.22,,2,2,2015-09-24 17:22:06+00:00,16.05,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
922,Jasmine fails tests when their afterEaches fail,"I'm all for jasmine failing the suite when an afterEach fails, and probably even failing the test is appropriate, but no indication is given that the error was really in the afterEach, and this is very confusing.
http://jsfiddle.net/6k7a5v34/2/
Input:
describe('foo', function() {
    afterEach(function() {
        expect(true).toBe(false);
    });

    it('bar', function() {
        expect(true).toBe(true);
    });
});
Output: Jasmine reports an issue with foo bar
Desired output: Jasmine reports an issue with foo bar's afterEach",voltrevo,NONE,2015-09-11 02:03:04+00:00,True,2015-10-28 21:29:24+00:00,47.81,,2,2,2015-09-24 17:07:14+00:00,13.63,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
923,How to use async/await with Jasmine?,"Hi, how can I use async/await with Jasmine? Is this supported somehow? I'd like to do
it('should run test', async function() {
    browser.get('https://duckduckgo.com/');
    $('#search_form_input_homepage').sendKeys('jasmine');
    $('#search_button_homepage').click();

    let title = await browser.getTitle();
    expect(title).toBe('foo');
  });

Instead of
  it('should run test', function(done) {
    browser.get('https://duckduckgo.com/');
    $('#search_form_input_homepage').sendKeys('jasmine');
    $('#search_button_homepage').click();

    browser.getTitle().then(function(title) {
      expect(title).toBe('foo');
      done();
    });
  });

Do I need to do that manually like here?",donaldpipowitch,NONE,2015-09-11 06:40:29+00:00,True,2015-09-24 17:24:11+00:00,13.45,,17,30,2015-09-11 07:10:24+00:00,0.02,donaldpipowitch,NONE,1,1,0,15,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
926,Testing Jasmine Plugins,"I'm trying to write a plugin for Jasmine that allows you to return a promise from a spec and will pass or fail that spec depending on whether or not the promise is fulfilled or rejected.
Of course, I want to write tests to make sure that my plugin works correctly, and to be thorough, I need to make sure that tests fail when the promise is rejected... so how do I make a test pass when I need to make sure that a test ""successfully fails""? Essentially I'm using Jasmine to test functionality I'm adding to Jasmine.
I'm attempting to grab your solution from nodeDefineJasmineUnderTest.js but there are a few requires in there that reference your src files, which I don't have access to.
I also tried this in my tests
var jc = require('jasmine-core');
var env = new jc.Env();
but that env ends up only being a function and not having env.describe or env.it or anything like that on it, like what you use in your own specs. Can you help me out?",joezimjs,NONE,2015-09-23 15:51:45+00:00,True,2015-10-05 22:13:44+00:00,12.27,,2,10,2015-10-02 04:34:09+00:00,8.53,joezimjs,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
928,jasmineToString,"I notice this discussion in the Google Group forum.
In particular I agree with André's comment:

shouldn't their custom toString be preferred over the recursive pretty print?

I have expectations like the following:
expect(res).not.toBeDefined();
where res is expected to be undefined but if this fails then it will be an instance of immutable-js List.
Is the expectation here that immutable-js should define jasmineToString() functions for all their types?",myitcv,CONTRIBUTOR,2015-09-25 16:26:35+00:00,True,2015-09-25 18:47:14+00:00,0.1,,2,3,2015-09-25 17:01:55+00:00,0.02,myitcv,CONTRIBUTOR,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
931,"ability to configure ""already been spied upon"" behavior","currently I get errors if I try to re-spy upon a function.
this makes my code stateful - which is a serious issue for me.
I need to remember if this is a spy or not.
for example: if I decide to have a default spy after written a lot of tests,  I now need to modify the code in all tests from spyOn(object,'myMethod') to object.myMethod.... seems redundant to me.
It would be nicer if it worked similar to jquery wrapper..
$('div') and $($('div')) - give the same result.
spyOn(obj,'myMethod') should simply return the spy if spy already exists.",guy-mograbi-at-gigaspaces,CONTRIBUTOR,2015-09-27 09:14:27+00:00,True,2016-02-18 19:40:55+00:00,144.44,,2,1,2015-10-23 21:02:31+00:00,26.49,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
933,"Passing ""this"" to beforeAll / beforeEach / it","There is a strange issue with this, which can be seen here:
http://plnkr.co/edit/04GzjcMez6YhTroJ3HS6?p=preview
The problem is, that this passed to beforeAll seems different from this passed to other methods. Check console output to see the object details:
Inited:  Object {counter: 1}
appSpec.js:22 Before:  Object {} <- where is ""counter 1""?
appSpec.js:34 Test 1:  Object {}
appSpec.js:14 Disposing  Object {counter: 1}
appSpec.js:10 Inited:  Object {counter: 2}
appSpec.js:22 Before:  Object {countObj: null}
appSpec.js:43 Test 2:  Object {countObj: null}
appSpec.js:14 Disposing  Object {counter: 2}",mc0re,NONE,2015-09-28 11:31:30+00:00,True,2015-12-07 17:39:14+00:00,70.26,,2,4,2015-09-29 19:18:37+00:00,1.32,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
934,Email Jasmine test reports.,"Hi,
I was wondering if there is a module or a tutorial that would actually send email notifications after the test has been executed. If possible, it would be great to send the exact report as an email.
Please let me know.
Thanks,
Uday",udayas8451,NONE,2015-09-28 17:31:30+00:00,True,2015-09-29 19:02:24+00:00,1.06,,2,1,2015-09-29 19:02:24+00:00,1.06,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
935,Can't call `execute` twice?,"When I try to call execute more than once it seems the beforeEach aren't called again? How can I run Jasmine more than once? (Note: I wait for onComplete before running again.) The tests won't change, just the environment where they are executed. I use jasmine-npm, but re-new the JasmineRunner doesn't seem to work.
I currently use a dirty hack where I copy my test files for every new JasmineRunner.",donaldpipowitch,NONE,2015-09-30 08:25:25+00:00,True,2015-10-05 22:09:41+00:00,5.57,,2,1,2015-10-05 22:09:41+00:00,5.57,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
936,expected and actual value in passed result object,"Currently, when a spec fails, the failedExpectation object contains the expected and actual values. However when the spec passes, the passedExpectation object omit these two.
Why?
There is a need for me(and maybe for others) to expose this information in official reports both for failed and passed specs. Also this is extra information that is available and that reporters could choose to ignore for passed spec if they want to.",ravikumars,NONE,2015-10-01 15:06:43+00:00,True,2016-10-14 23:56:27+00:00,379.37,,3,4,2015-10-01 16:23:19+00:00,0.05,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
937,[Feature Request] Allow an async spec to be marked as pending,"It would be great to allow an asynchronous spec to be marked as pending, in the same way that it can be marked as failed with done.fail e.g.
it('takes a while but is pending', function(done) {
  setTimeout(function() {
    done.pend();
  }, 100);
}
Specifically, this is coming up here: angular/jasminewd#27 (comment).",juliemr,NONE,2015-10-02 19:58:09+00:00,True,2017-03-08 00:34:31+00:00,522.19,,4,5,2015-10-03 15:54:13+00:00,0.83,slackersoft,MEMBER,1,0,0,2,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
938,Help spread adoption by providing guides how to integrate with node.,"The top result for ""jasmine node"" is https://github.com/mhevery/jasmine-node
Which is more than 1 year old and defaults to 1.x version of Jasmine.
Shall I use https://github.com/jasmine/jasmine-npm then?
Either way - some notes / some clarification would be helpful.

In fact I hate making decisions (I hate thinking) and it is easier to use ___ instead.
(not being fussy, just offering some feedback from top of my head)",stefek99,NONE,2015-10-06 19:58:25+00:00,True,2015-10-26 21:55:49+00:00,20.08,,2,4,2015-10-08 20:58:08+00:00,2.04,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
939,Errors raised in spec files outside of describe blocks cause spec files not to run,"Hey, is anybody else getting this or this is specific to a project my company is working on?
Let's say we have this file:
describe 'Sagamore.Model', ->
  beforeEach ->
    @model = new Sagamore.Model

  describe '#parse', ->
    beforeEach ->
      @resp = {
        'a': 1
        'hasOne?': true
      }

    it 'removes ""?"" from keys', ->
      response = @model.parse(@resp)

      expect(response.hasOwnProperty('hasOne'))
        .toEqual true
      expect(response.hasOwnProperty('hasOne?'))
        .toEqual false
Contents are not important. It runs perfectly, test passes, etc. We have 867 specs in our project and all of them pass.
The problem is that if you add a line
throw Error()

to the beginning of this file, this and 12 other specs do not get run at all. Jasmine says that 854 (note the changed number) specs are passing, 0 failures.
Is it a bug? Is it something on our side? It caused us a problem where we had about 100 specs not being run without us noticing for a week because of an error inside a spec file outside of a describe block.",cbrwizard,NONE,2015-10-08 14:39:19+00:00,True,2018-01-26 19:01:48+00:00,841.18,,4,5,2015-10-12 17:59:23+00:00,4.14,slackersoft,MEMBER,2,1,0,0,"['feature request', 'has Tracker story', 'ready for work']",False,True,False,False,False,False,False,False,True,True,False,False,False,False,False
940,No way to use a before() statement? Any plugin available?,"I would need a before() method.
Imagine a login that is done only at the startup.
I found a way to do it, but I would prefer to have a method before().",bitliner,NONE,2015-10-08 16:45:58+00:00,True,2015-10-08 16:51:54+00:00,0.0,,2,4,2015-10-08 16:47:18+00:00,0.0,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
941,Memory leaks because of closures,"Hi, this is the first issue that I am creating after almost 2 years of usage of your extraordinary testing framework for JavaScript. I am using it mainly for testing AngularJs code and I love it, it enables me to test every peace of my code and with the BDD syntax every test simply becomes part of my code documentation.
Recently after some extensive debugging, reading and analysing your source code I finally found out why I was experiencing memory leak problems. The problem was that the running tests were not able to finish because of the build up memory consumption in the browser caused by improper garbage collection.
This problem was reported by lot of people and I documented it recently in this StackOverflow question.
What I found out is that the reason for it was the improper cleanup after each test which is never mentioned anywhere even in the AngularJs testing guide.
Example:
describe('Test suite', function() {
  var a, b;

  beforeEach(function() {
    // init heavy objects
    a = new Array(10000).join('x');
    b = new Array(10000).join('y');
  });

  // NOTE: often forgotten cleanup
  afterEach(function () {
    a = null;
    b = null;
  });

  it('spec1', function() {
    // spec code..
  });

  // other specs and inner suites ..
});
If the needed cleanup is forgotten because jasmine builds up a tree from all registered suits and each suites containes references to his beforeEach, afterEach.. functions which contain references to the describe function closure which holds references to the 'a' and 'b' variables, the large objects that are referenced by that variables won't be GC-ed until Jasmine stops the execution.
We can't say that this is an issue with Jasmine, the problem is because this information is not well transferred to all the developers using this great framework. The question is how we can improve this? Is there a better way that enables easy access to the defined variables in every inner spec, suite, function.. as this one but without caring for the cleanup which is almost always forgotten?
My idea for a workaround was to define only one 'container' object (ex. 'suite') which is nulled in an afterEach block and attach all variables there. This in the same time reduces the code length and keeps us safe from forgetting some defined variable.
Example:
describe('Test suite', function() {
  var suite = {};

  beforeEach(function() {
    // init heavy objects
    suite.a = new Array(10000).join('x');
    suite.b = new Array(10000).join('y');
  });

  // NOTE: often forgotten cleanup
  afterEach(function () {
    suite = null;
  });

  // other specs and inner suites ..
});",saskodh,NONE,2015-10-11 13:03:13+00:00,True,2015-12-07 17:42:03+00:00,57.19,,7,9,2015-10-12 16:26:23+00:00,1.14,ragaskar,CONTRIBUTOR,1,2,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
943,Implement spies for get/set functions on accessor properties,"I think it would be useful to extend spyOn (or add another method, like spyOnGetter) to spy on the getter or setter function of an accessor property. Currently there is no way to spy on the following get functions, because Jasmine currently can only spy on functions that are properties, and not on functions that are set/get accessor functions of a property:
Object.defineProperty(obj, ""dynamicFoo"", {
    configurable: true,
    get: function() {
        return Math.random();
    }
});

var obj = {
    get dyanmicBar() { return Math.random(); }
}

It seems like the core functionality could be implemented using defineProperty to rewrite the property with a spy for its get or set method.
The current code is
this.spyOn = function(obj, methodName) {
    ...
    var spy = j$.createSpy(methodName, obj[methodName]);
    obj[methodName] = spy;
}

The code could handle accessor functions with a third argument (either ""get"" or ""set"") like so:
this.spyOn = function(obj, methodName, accessType) {
    ...
    var desc = Object.getPropertyDescriptor(obj, methodName);
    if(desc[accessType]) { // ""get"" or ""set"" exists on the property
        var spy = j$.createSpy(methodName, desc[accessType]);  

        desc[accessType] = spy;

        Object.defineProperty(obj, methodName, desc);
    }
}

However, I'm not sure how this would break existing assumptions. For example, in my sample code above, createSpy is given the property name, but the property is not being spied on; rather, one of the property's accessor functions is being spied on. This change would require eliminating the assumption that a function being spied on is a property of an object, and instead writing logic that admits the possibility that a spied function could be a get or set function within an object property.",apsillers,NONE,2015-10-16 12:49:53+00:00,True,2016-11-04 21:37:29+00:00,385.37,,24,26,2015-10-28 01:30:56+00:00,11.53,StanleyGoldman,NONE,1,2,0,20,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
944,beforeEach(...) skips error when using function references,"If I use a function reference in my beforeEach(...), and that function throws an error, the test continues to execute as-if there was no problem. In some cases, this skips the it(...) blocks from executing altogether without throwing any indication that something wrong happened.
ie. a case like this:
var myVariable;

beforeEach(setupMyTest);

it('Should be equal to ""fail"" string', function () {
  expect(myVariable).toEqual('fail');
});

///

function setupMyTest () {
  myVariable = fail;
}

Where-as if I use a function block, the error is echoed to console and shows the tests as failed:
var myVariable;

beforeEach(function () {
  myVariable = fail;
});

it('Should be equal to ""fail"" string', function () {
  expect(myVariable).toEqual('fail');
});

I use the first pattern for writing tests because it is much cleaner to read and follow, when there is a large series of tests. But there are cases where a bug goes undetected as a result of the error being silenced.",mpiasta-ca,NONE,2015-10-16 21:07:36+00:00,True,2016-09-27 01:04:33+00:00,346.16,,3,2,2015-10-27 18:50:58+00:00,10.91,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
945,Increase the maximumSpecCallbackDepth or make it configurable,"I've spent a couple of days chasing an issue with maximumSpecCallbackDepth. It either should be configurable or at least, when the currentSpecCallbackDepth is getting reset to 0 (
  
    
      jasmine/lib/jasmine-core/jasmine.js
    
    
         Line 657
      in
      141fd91
    
    
    
    

        
          
           currentSpecCallbackDepth = 0; 
        
    
  

) the user should be notified about this (for example: ""Please increase the maximumSpecCallbackDepth or split your test on smaller chunks).
Otherwise, somebody else will spend more days on debugging this issue.
Related issue: #366",NameFILIP,NONE,2015-10-19 20:11:43+00:00,True,2016-10-14 16:38:48+00:00,360.85,,5,9,2015-10-23 22:42:15+00:00,4.1,slackersoft,MEMBER,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
947,"If fail() or pending() called within beforeEach block, spec should be skipped","To my mind if a spec is marked as pending or failed in a beforeEach block I would not expect the test to then be executed, but currently it is.  Is this the expected/desirable behaviour?",keirlawson,NONE,2015-10-20 14:08:15+00:00,True,2015-10-26 19:14:50+00:00,6.21,,2,1,2015-10-26 19:14:50+00:00,6.21,slackersoft,MEMBER,1,0,0,0,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
948,Spying on a function that is defined using a getter causes PhantomJS to crash,"TypeError: setting a property that has only a getter.
Now you might think that this is an issue for PhantomJS to resolve, but it is not. Your own tests run on Node, which in this case has the same issue but fails silently instead.
In the end, it means that you cannot spy on a function or constant that has been declared using only a getter. Depending on the environment, it either fails silently (possibly providing false test results) or fails by hanging the process.",StephanBijzitter,CONTRIBUTOR,2015-10-21 10:14:12+00:00,True,2015-10-26 23:30:14+00:00,5.55,,2,1,2015-12-07 17:07:40+00:00,47.29,amilligan,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
950,Specifications generator,"Hi! I'm new to jasmine and I love it!
Was wondering if it was possible to generate some auto-generated markdown (or any format) specifications? Each describe block would be a new dummy entry like :
## Some instance .

- shall handle some specific case ...
- shall handle some generic case ...
- shall throw an error when ...
Thanks for your help!",jsamr,NONE,2015-10-21 17:54:31+00:00,True,2015-10-21 21:16:12+00:00,0.14,,2,1,2015-10-21 21:16:12+00:00,0.14,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
952,--watch option for fast iteration during TDD?,"First, apologies if this has been asked before but a search for 'watch' in github and google don't turn up anything relevant.
Mocha has a --watch mode that re-runs tests when something changes.  Karma also does something similar, in fact Karma's default mode is to stay in a watch mode unless you specify 'single run.'  This makes TDD easy as you can write your tests first, see them fail, then as you save code tests start passing.
I can approximate this functionality with chokidar and gulp/grunt, but was surprised this doesn't seem to be built-in.",thom-nic,NONE,2015-10-23 17:39:25+00:00,True,2015-10-23 20:45:10+00:00,0.13,,2,2,2015-10-23 20:45:10+00:00,0.13,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
959,Testing the property of an undefined object,"In the process of testing a REST API with the following code :
describe('GET /', function() {
    it('should respond with 200', function(done) {
        request(options, function(error, response, body) {
            expect(response.statusCode).toBe(200);
            done();
         });
     });
});

If the webservice is down, or the requested address is wrong, the response is not defined, all tests are skipped and jasmine fail with :
TypeError: Cannot read property 'statusCode' of undefined
If this situation I would expect jasmine to just report :
Expected undefined to be 200.
Is jasmine failing this way by design ? And then how can I best prevent jasmine to completely fails in this situation ?
Or
Shouldn't jasmine just report ""expected undefined  something"" in case we are reading the property of an undefined object ?",Tetraib,NONE,2015-10-26 19:46:14+00:00,True,2015-10-26 20:43:42+00:00,0.04,,2,2,2015-10-26 20:43:42+00:00,0.04,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
960,Feature to retry failed tests,"Is there the possibility for Jasmine to add an option to retry failed tests to de-flake?
i.e. if my test suite has 3 tests: A, B and C.
If B failed, but A and C passed, Jasmine will rerun B to see if it passes (it will retry only the failed tests up to a specified number of times).
This would help with Protractor tremendously. (i.e. angular/protractor#1190). I would be willing to create a PR for this if owners think this feature fit within jasmine.",hankduan,NONE,2015-10-28 23:32:46+00:00,True,2017-04-14 21:15:53+00:00,533.9,,12,13,2015-11-13 16:17:20+00:00,15.7,joaoffalcao,NONE,1,0,0,9,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
961,"Cannot call createSpyObj with only name, not list of methods","jasmine.createSpyObj throws if you don't pass it any method names: 
  
    
      jasmine/src/core/base.js
    
    
         Line 113
      in
      375a6f9
    
    
    
    

        
          
           if (!j$.isArray_(methodNames) || methodNames.length === 0) { 
        
    
  


Why was this behavior added? My use case is that I'd like to ensure that a specific parameter was passed through to another function.  For instance:
function iCallThings(a, b) {
  a(b);
}

a = jasmine.createSpy('a');
b = jasmine.createSpyObj('b', []);

iCallThings(a, b);
expect(a).toHaveBeenCalledWith(b);
AFAIK, this test would work if it weren't for Jasmine checking the length of the array passed as the second argument to createSpyObj.  A solution right now is to do something like b = {'b': true}, but I'd prefer to use createSpyObj.  I'm fine with having to pass an empty array but I'd like to not have to pass a non-empty array.
I can send out a PR for this if you agree that it'd be a positive change.",danfinnie,CONTRIBUTOR,2015-10-30 15:31:44+00:00,True,2015-11-02 19:35:32+00:00,3.17,,3,4,2015-10-30 16:33:44+00:00,0.04,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
962,Is jasmine really BDD?,"Jasmine is a Behavior Driven Development testing framework for JavaScript.

Is this really true?
As far as I know BDD means the usage of a feature description language, for example gherkin which we can use to describe features in a human readable form. These descriptions have very high abstraction level, use words from ubiquitous language (DDD), for example:
Scenario: Wilson posts to his own blog
  Given I am logged in as Wilson
  When I try to post to ""Expensive Therapy""
  Then I should see ""Your article was published.""
As you can see they don't contain any (javascript) code, so the implementation is independent from the feature description. You can do it on any programming language using any programming style.
By running the tests we translate the feature descriptions into running tests by the usage of step definitions. These step definitions are reusable and contain low level code like fixtures, assertions, etc. and they are reusable. So I can say that
Scenario: Gabriel tries to post to Wilson's blog
  Given I am logged in as Gabriel
  When I try to post to ""Expensive Therapy""
  Then I should see ""You don't have the permissions to post here""
And I can reuse the step definition of the When I try to post to ""Expensive Therapy"" part.
A clean separation of these 2 abstraction levels is important not just because the reusability, but because the human readability and the ensurance of  loose coupling between the feature descriptions and the code. So we don't have to touch the feature descriptions if only the implementations changes, but the supported features remain the same.
Ofc. jasmine could be used for writing these step definitions, just as any unit testing framework.",inf3rno,NONE,2015-10-30 20:43:33+00:00,True,2015-10-30 20:45:41+00:00,0.0,,2,4,2015-10-30 20:45:40+00:00,0.0,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
963,calling jasmine.execute multiple times in node,"Is it possible to call jasmine.execute multiple times with different files.
I have a use case where I want to run tests serially.
When I attempt to do this it appears to just run the first set over again.
var Jasmine=require(""jasmine"");
var jasmine=new Jasmine();
jasmine.execute([""test/testBasic.spec.js""]);
jasmine.execute([""test/testBasic2.spec.js""]);
jasmine.execute([""test/testBasic3.spec.js""]);
jasmine.execute([""test/*.spec.js""]);

Output:
Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one
Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one
Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one
Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one

The tests log the file name and I see only the first file being called four times.
If I change the order in index.js to:
var Jasmine=require(""jasmine"");
var jasmine=new Jasmine();
jasmine.execute([""test/*.spec.js""]);
jasmine.execute([""test/testBasic.spec.js""]);
jasmine.execute([""test/testBasic2.spec.js""]);
jasmine.execute([""test/testBasic3.spec.js""]);
```.
I see:

Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one
Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one
Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one
Started
./Volumes/DataDrive/jasminetest/test/testBasic.spec.js two
/Volumes/DataDrive/jasminetest/test/testBasic.spec.js one
./Volumes/DataDrive/jasminetest/test/testBasic2.spec.js threee
F/Volumes/DataDrive/jasminetest/test/testBasic3.spec.js four
F
Failures:


second test secondtestIt
Message:
Expected true to be false.
Stack:
Error: Expected true to be false.
at Object. (/Volumes/DataDrive/jasminetest/test/testBasic2.spec.js:8:16)


third test Suite third test
Message:
Expected true to be false.
Stack:
Error: Expected true to be false.
at Object. (/Volumes/DataDrive/jasminetest/test/testBasic3.spec.js:8:16)
Message:
Expected 'one' to equal 'seven'.
Stack:
Error: Expected 'one' to equal 'seven'.
at Object. (/Volumes/DataDrive/jasminetest/test/testBasic3.spec.js:9:17)


4 specs, 2 failures
Finished in 1.001 seconds
So it calls the first file 3 times and then calls all four.",donniev,NONE,2015-10-31 14:30:21+00:00,True,2016-09-28 00:55:20+00:00,332.43,,5,4,2015-11-30 19:42:39+00:00,30.22,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
964,Jasmine cannot work in Atom Electron environment,"When I try to run Jasmine under Electron, it fails with error:
jasmine.js:28 Uncaught ReferenceError: exports is not defined
Looking at source code, I can suppose that the problem is in mixed node.js/browser environment.
How to reproduce:
set -e
git clone https://github.com/atom/electron-quick-start
cd electron-quick-start
wget https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip
unzip jasmine-standalone-2.3.4.zip
cp SpecRunner.html index.html
npm install
npm start
And then look at developer console by pressing Ctrl-Shift-I",skupr,CONTRIBUTOR,2015-11-02 16:47:09+00:00,True,2016-03-27 04:29:08+00:00,145.49,,3,3,2015-11-14 01:01:38+00:00,11.34,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
966,"Add dddescribe, iiit for suites, specs that should always run","While I am isolating a test using ddescribe in scenario-change-username.js I also have to use it in scenario-login.js so that the user is logged in.
It would be nice to use something like dddescribe in the login file, (for want of better nomenclature).
``dddescribewould be immutable, and this case, the login test would always run, even when otherddescribes` are used.",F1LT3R,NONE,2015-11-03 17:09:13+00:00,True,2015-11-13 22:33:24+00:00,10.23,,2,1,2015-11-13 22:33:24+00:00,10.23,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
967,Way to export spec tree?,"Hi,
I would like to export a tree of the Jasmine specs, is this possible?
When I use karma-spec-reporter I can output the specs as they run, making a tree like:
MyModule
  someFunction()
    when foo == bar
      returns 'true'
    when foo == baz
      returns 'false'

This is really useful and I would like to use this information to describe my modules outside of running the tests. Is there any way I can simply parse the specs in Jasmine and somehow get at that information? I assume that Jasmine creates some kind of tree somewhere of what it has to run.
Thanks,

Gavin",gavD,NONE,2015-11-09 17:39:00+00:00,True,2015-11-14 01:30:38+00:00,4.33,,2,2,2015-11-14 01:30:38+00:00,4.33,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
968,Error in example usage in introduction page,"This seems wrong:
  it(""The 'toBeCloseTo' matcher is for precision math comparison"", function() {
    var pi = 3.1415926,
      e = 2.78;

    expect(pi).not.toBeCloseTo(e, 2);
    expect(pi).toBeCloseTo(e, 0);
  });",lavie,NONE,2015-11-10 07:49:05+00:00,True,2015-11-30 20:05:57+00:00,20.51,,2,1,2015-11-30 20:05:57+00:00,20.51,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
969,Feature: mock timezone in fake clock,"It would be useful to be able to mock the timezone in the mock clock in a similiar way to https://github.com/Jimbly/timezone-mock or https://github.com/plaa/TimeShift-js
We already use the jasmine clock everywhere and now we will have one test that is using a different mocking framework so we can mock timezones.",lukeapage,NONE,2015-11-10 09:11:42+00:00,False,,,,3,2,2015-11-13 21:36:53+00:00,3.52,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
971,Is there a possibility in jasmine not to override messages from passed expects?,"I am using in my project protractor for my e2e tests with jasmine2 as framework. I am using as well the libraries jasmine2-custom-message and protractor-jasmine2-html-reporter.
I have realised that the message from passed expects would be overridden with the word: Passed.
After a little research I realised that the file that is actually overridden this message is the following:
node_modules/protractor/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js
Specifically the function:
getJasmineRequireObj().buildExpectationResult = function () {
    function buildExpectationResult(options) {
        var messageFormatter = options.messageFormatter || function () {
                },
            stackFormatter = options.stackFormatter || function () {
                };

        var result = {
            matcherName: options.matcherName,
            message: message(),
            stack: stack(),
            passed: options.passed
        };

        if (!result.passed) {
            result.expected = options.expected;
            result.actual = options.actual;
        }

        return result;

        function message() {
            if (options.passed) {
                return 'Passed.';
            } else if (options.message) {
                return options.message;
            } else if (options.error) {
                return messageFormatter(options.error);
            }
            return '';
        }

        function stack() {
            if (options.passed) {
                return '';
            }

            var error = options.error;
            if (!error) {
                try {
                    throw new Error(message());
                } catch (e) {
                    error = e;
                }
            }
            return stackFormatter(error);
        }
    }

    return buildExpectationResult;
};
I wonder if there is a way to override this function (buildExpectationResult), for example in protractor config file. I have already tried that by adding in protractor config file the following.
onPrepare: function () {
    jasmine.buildExpectationResult = function () {
        function buildExpectationResult(options) {
            var messageFormatter = options.messageFormatter || function () {
                    },
                stackFormatter = options.stackFormatter || function () {
                    };

            return {
                matcherName: options.matcherName,
                expected: options.expected,
                actual: options.actual,
                message: message(),
                stack: stack(),
                passed: options.passed
            };

            function message() {
                if (options.passed && !options.message) {
                    return 'Passed.';
                } else if (options.message) {
                    return options.message;
                } else if (options.error) {
                    return messageFormatter(options.error);
                }
                return """";
            }

            function stack() {
                if (options.passed) {
                    return """";
                }

                var error = options.error;
                if (!error) {
                    try {
                        throw new Error(message());
                    } catch (e) {
                        error = e;
                    }
                }
                return stackFormatter(error);
            }
        }

        return buildExpectationResult;
    };
}
But that is not working.
Is there any other way of overriding jasmine functions?",lynchblue,NONE,2015-11-11 15:27:07+00:00,True,2015-11-13 22:29:01+00:00,2.29,,2,2,2015-11-13 09:56:13+00:00,1.77,lynchblue,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
974,Add command line option to run only a subset of the tests,"It could be useful to have options to filter the tests to be run.  Something like these flags supported by mocha:
-g, --grep                     only run tests matching 
-f, --fgrep                     only run tests containing",ggarber,NONE,2015-11-14 22:21:57+00:00,True,2015-11-30 20:23:02+00:00,15.92,,2,1,2015-11-30 20:23:02+00:00,15.92,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
975,restore method for a spy,"I had a look at two following issues, both of them are closed, however I have an example which I believe would benefit from having a restore method (which would bring it back to its original fn).
#683
#236
Please have a look at the following code and comments (assume it's requirejs + marionette):
describe(""MyController"", function () {
    ""use strict"";

    var MyController;

    beforeAll(function (done) {
        require([""path/to/my.controller""], function (Controller) {
            MyController = Controller;
            done();
        });
    });

    it(""should be defined"", function () {
        expect(MyController).toBeDefined();
    });

    describe(""instance"", function () {

        var controller;

        beforeEach(function () {
            controller = new MyController();
            // assume that the controller uses
            // this.listenTo to register an event handler
        });

        afterEach(function () {
            controller.destroy();
            // this destroy unbinds registered event handlers
        });

        it(""should be defined"", function () {
            expect(controller).toBeDefined();
        });

        describe(""method"", function () {

            describe(""onProcessError"", function () {

                it(""should call destroy"", function () {
                    spyOn(controller, ""destroy"").and.callFake(function () {
                        console.log(""spy called""); 
                        // triggers twice
                        // so the registered handlers are not unbinded
                    });
                    controller.onProcessError();
                    expect(controller.destroy).toHaveBeenCalled();
                    // controller.destroy.restore(); 
                    // it would cause the console.log to trigger only once
                    // and the handlers would be removed as usual
                    // but it's quite fragile, you might forget about it
                });

            });

        });

    });

});

I can see two workarounds of the problem described above:

callThrough (which would cause destroy to be called twice in the following example, I believe it's unnecessary and might cause problems if internal implementation of given library does throw an error in such case),
rearrange describe/it statements and create an instance in one it statement and use callThrough to destroy it as usual

Both of these unfortunately do not fit the way I'm arranging the specs. I wasn't able to find any other solution despite going through the docs. I could use sinon, but I'd rather not add any additional  dependencies, jasmine is great enough and only this edge case bothers me. Do you have any suggestions?",emilos,NONE,2015-11-17 09:54:29+00:00,True,2015-12-01 15:10:45+00:00,14.22,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
976,Jasmine Adds additional Object( inside Object( in 2.0+,"I have a method returning
{ name: ""FUBAR -X"", property: ""fubar"", parser: { display: 'Fubar', icon: 'icon-x-fubar', parse: 'parse-fn', factory: 'test' } }

And I try to verify this behavior with:
expect(method).toEqual({ name: ""FUBAR -X"", property: ""fubar"", parser: { display: 'Fubar', icon: 'icon-x-fubar', parse: 'parse-fn', factory: 'test' } });

However Jasmine outputs the following:
Expected Object({ name: 'FUBAR -X', property: 'fubar', parser: ({ display: 'Fubar', icon: 'icon-x-fubar', parse: 'parse-fn', factory: 'test' }) }) 
to equal 
Object({ name: 'FUBAR -X', property: 'fubar', parser: Object({ display: 'Fubar', icon: 'icon-x-fubar', parse: 'parse-fn', factory: 'test' }) }).

As you can see, it has added an additional Object( in the expected part.
If I use angular.equals or JSON.stringify on both it works, but I would prefer to use toEqual.
In 1.3 it was possible just to use isEqual",CThuleHansen,NONE,2015-11-17 14:24:43+00:00,True,2016-09-28 00:53:53+00:00,315.44,,3,4,2015-11-17 17:27:45+00:00,0.13,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
977,Fail a test if no expectations were made,"Is there anything built-in to jasmine to fail a test if no expectations were made in it?
If not, would it make sense to request such a feature? Thanks.",alecxe,NONE,2015-11-18 00:27:21+00:00,True,2015-11-30 22:00:17+00:00,12.9,,3,2,2015-11-30 22:00:16+00:00,12.9,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
978,Passing parameters from Spec to Reporter,"Hello,
I've been working on a custom reporter that I use from Node. I need the reporter to display more details than are returned in the specResult object from a spec. For example, my spec looks like this:
spec
it(""should return parameter values"", function(done) {
    expect(true).toBe(true);
    this.parameter2 = 'anotherValue';
    done();
}, { parameter1:'paramValue' });

reporter
this.specDone = function(result) {
  var parameter1 = null; // how do I get result.parameter1
  var parameter2 = null; // how do I get result.parameter2

  ...
}

I cannot figure out how to pass additional information from a spec to a reporter. In addition to the properties that are currently returned with result (i.e. description, fullName, passedExpectations, failedExpectations, and status), I'd like add two other properties: properties and result. I'm not having any luck in accomplishing this though.
Thank you to the community for any assistance that can be provided. I personally have the opinion that this would be a valuable addition to the Jasmine in general.",paranoid-android,NONE,2015-11-18 12:05:12+00:00,True,2015-12-01 00:50:02+00:00,12.53,,2,1,2015-12-01 00:50:02+00:00,12.53,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
979,Documentation outdated,"The documentation example specifies an onComplete callback, however, when you do that and run the tests, jasmine complains that it's been deprecated. Docs should probably be updated to reflect new API?",adamreisnz,NONE,2015-11-19 18:56:47+00:00,True,2015-12-09 23:16:34+00:00,20.18,,2,1,2015-12-09 23:16:34+00:00,20.18,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
981,Documentation should reflect that toContain can do substring matching,"The documentation for Jasmine states

The 'toContain' matcher is for finding an item in an Array

In practice it also works for matching substrings. (ie. expect('qwerty').toContain('we')) as mentioned by @slackersoft in #738 . If this is an intended feature, I would recommend that it be included in the documentation. Alternatively, if it's not intended and may go away in a future release I would recommend adding a caveat to the docs reflecting that.
Let me know which way the collaborators lean on this and I'd be happy to submit a PR.",ryanwilsonperkin,NONE,2015-11-25 20:52:23+00:00,True,2015-12-09 23:20:51+00:00,14.1,,2,2,2015-12-09 23:20:51+00:00,14.1,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
982,"Link ""this list"" does not work on wiki","On site:
https://github.com/jasmine/jasmine/wiki/A-simple-project
link does not work.
404 error is returned.",Ziemowit,NONE,2015-11-26 21:05:12+00:00,True,2015-12-09 23:27:17+00:00,13.1,,2,2,2015-11-26 21:06:58+00:00,0.0,Ziemowit,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
983,setParams Functionality,"I suggest adding the following to SpyStrategy:
this.setParams = function(obj) {
plan = function () {
var index;
for (index = 0; index < arguments.length; index++) {
obj['arg' + index] = arguments[index];
}
};
return getSpy();
};
The method is called as follows:
var myObj = {};
spyOn(xxx, 'yyy').and.setParams(myObj);
after the method under test runs and calls xxx.yyy(passedArg0, passedArg1)
myObj would look like { arg0: passedArg0, arg1: passedArg1 }
It is especially handy when testing anonymous functions. i.e.
xxx.yyy(function () { ... }) With the existing jasmine code I have to write
spyOn(xxx, 'yyy').and.callFake(function (param) { myMethod = param; }); in order write the unit test for the anonymous function.
Thoughts?",RALifeCoach,NONE,2015-11-26 22:36:05+00:00,True,2016-09-27 01:03:28+00:00,305.1,,3,4,2015-12-10 22:44:57+00:00,14.01,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
984,Get the current Spec,"I've not managed to spot an issue/feature request for this, but I'd really really like to be able to get the current spec from within a running test. this is normally undefined at the start of a test, and would fit the bill perfectly for my use case.
In my tests I'm typically auto-generating some DOM, and I'll use the ID of the spec or the description of the spec to populate some elements that I can then quiz later. This saves me hard coding everything which I prefer but I'm having to do this for each spec definition and then have to maintain the numbers adding new ones which is a pain:
var spec1 = it(""The First Spec"", function() {
    var spec = spec1; // Can now consume spec
});

var spec2 = it(""The Second Spec"", function() {
    var spec = spec2; // I've had a number of times where this was spec1 accidentally... :(
});

Ideally I'd like something like
it(""The Third Spec"", function() {
  var spec = this;
});",IPWright83,NONE,2015-11-27 10:26:03+00:00,True,2016-01-05 22:59:38+00:00,39.52,,2,1,2016-01-05 22:59:38+00:00,39.52,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
985,Karma clock test pollution,"This is similar to a previous issue:
#790
But it seems to be a little more nuanced. I believe the previous issue was solved because the following does work:
  describe(""clock pollution"", function() {
    it(""async with clock"", function(done) {
      jasmine.clock().install()
      setTimeout(function() {
        jasmine.clock().uninstall()
        done()
      }, 2000)
      jasmine.clock().tick(2001)
    })

    it(""async with clock"", function(done) {
      jasmine.clock().install()
      setTimeout(function() {
        jasmine.clock().uninstall()
        done()
      }, 2000)
      jasmine.clock().tick(2001)
    })
  })
But check out the following example when I use promises. I'm using the popular Q library:
  describe(""clock pollution"", function() {
    it(""async with clock"", function(done) {
      jasmine.clock().install()
      Q.delay(2000)
        .then(function() {
          jasmine.clock().uninstall()
          done()
        })
      jasmine.clock().tick(2001)
    })

    it(""async with clock"", function(done) {
      jasmine.clock().install()
      Q.delay(2000)
        .then(function() {
          jasmine.clock().uninstall()
          done()
        })
      jasmine.clock().tick(2001)
    })
  })
I get this weird error:
    clock pollution
      ✓ async with clock
      ✗ async with clock
    Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.

The clocks definitely seem to be polluting each other somehow.
Just for sanity, I tried this one:
  function delay(ms) {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, ms)
    })
  }

  describe(""clock pollution"", function() {
    it(""async with clock"", function(done) {
      jasmine.clock().install()
      delay(2000)
        .then(function() {
          jasmine.clock().uninstall()
          done()
        })
      jasmine.clock().tick(2001)
    })

    it(""async with clock"", function(done) {
      jasmine.clock().install()
      delay(2000)
        .then(function() {
          jasmine.clock().uninstall()
          done()
        })
      jasmine.clock().tick(2001)
    })
  })
And it worked! Argh!! Wtf?!",ccorcos,NONE,2015-12-02 22:30:51+00:00,True,2016-10-14 16:38:48+00:00,316.76,,4,8,2015-12-02 22:49:57+00:00,0.01,ccorcos,NONE,2,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
987,Failing to execute tests using text scripts (Knockout Templates),"I've been struggling with this for a little while now and can't figure it out. I've got some jasmine tests that seem to run fine under the following situations:

Running through wallaby.js in Visual Studio
Running through Karma

If however I run them through a SpecRunner.html then they fail. I've limited the problem down to the Knockout templates that I'm using, not being loaded for some reason through the SpecRunner. So what I'm doing is loading a Knockout custom component, via a synchronous call to go grab the content:
<script id=""Summary"" type=""text/html""> 
    <div class='divider'></div>
    <div class='camera-button'>
        <div class='camera-circle'></div>
        <div class='camera-image'></div>
    </div>
</script>

<!-- This is the Details Tab for a Card -->
<script id=""Details"" type=""text/html"">
    <div id=""details-tab"" class=""details-tab tab-pane active"" data-bind=""component: 'instance-table'""></div>
</script>

<div data-bind=""attr: { id: 'detail_' + id() }"">
    <div class=""detail-card-container""></div>    
        <ul class='nav nav-tabs'>
            <li data-bind='css: { active: $data.template() === ""Summary""}'><a data-toggle='tab' data-bind='click: tabClick'>Summary</a></li>
            <li data-bind='css: { active: $data.template() === ""Details""}'><a data-toggle='tab' data-bind='click: tabClick'>Details</a></li>
        </ul>

        <div class='tab-content' data-bind='template: { name: template }'></div>
    </div>
</div>

So here the last div with the template binding is causing the problem, taking it out fixes my issue, but doesn't help me produce a correct test. Using the following view model:
var vm = { 
   template: ko.observable(""Summary"")
};

When I apply the Knockout bindings to the DOM (which has loaded this custom component) it seems to fail.

Error: Unable to process binding ""component: function (){return { name:componentName} }""
Message: Unable to process binding ""template: function (){return { name:template} }""
Message: Cannot find template with ID Summary

So it looks like the script isn't being loaded for some reason, but I can't understand why the problem only manifests itself when using the SpecRunner.",IPWright83,NONE,2015-12-08 14:24:11+00:00,True,2015-12-08 14:51:41+00:00,0.02,,1,1,2015-12-08 14:51:41+00:00,0.02,IPWright83,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
988,Call Done twice? Docs on async inconclusive,"Hi all!
Udacity front-end program student here and a bunch of us have been confused by the role of the done function.
Specifically, say we use done in a beforeEach. If the accompanying it block doesn't have any async action, do we still need to call it within that it block for a spec to be considered complete?
Several of us have noticed a spec still works if we don't pass in the done function (in the case that it block has no async).
However the documentation language and example seems to indicate that we do need to call done twice in this circumstance. link",ndrewr,NONE,2015-12-09 08:52:20+00:00,True,2015-12-09 18:02:06+00:00,0.38,,2,2,2015-12-09 18:02:06+00:00,0.38,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
989,How to setup a basic Javascript test using Jasmine 2.4.1 (standalone)?,"This is the first time I'm trying to write tests. I have installed jasmine 2.4.1 inside my project using bower:
bower install jasmine --save

I just can't figure out what to do next in order to setup specRunner.html. All the tutorials I found online are focused on previous versions of jasmine, which seem to have the specRunner.html file and a slightly different package structure. The install instructions I found on github are outdated, dating back to version 2.0.0. Also no luck on finding useful info on the github page. Sorry for posting such a basic question, but I just can't find a clear answer after so many hours of searching.
What am I suposed to do next to get the most basic of tests running?",adrian-moisa,NONE,2015-12-09 21:02:32+00:00,True,2015-12-09 22:30:28+00:00,0.06,,2,2,2015-12-09 22:30:28+00:00,0.06,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
991,Jasmine spies do not preserve function arity,"Whether using spyOn to replace an object property whose value is a function, or using .and.callFake to delegate to a supplied function, the resulting spy always has arity (.length) of zero — even if the original function has arity of 1, 4, whatever.
This is irrelevant much of the time but becomes critical when testing libraries that check function arity. Two well-known examples:

libraries which check to see if a done param is defined, in order to determine whether to execute asynchronously. Jasmine itself does this, ironically.
libraries like Express which register ""error-handling middleware"" as being functions with arity 4 (as opposed to the usual 3 or less), and which execute those functions if a truthy value has been passed into a previously-supplied next function (or if an error was thrown during the execution of ""normal"" middleware).

The best spies which substitute for existing functions do so transparently, so that the library is not able to determine the difference between a spy and an original. Jasmine spies would be improved by matching the arity of their originals, reducing the possibility of the framework being tested exhibiting different behavior.",glebec,NONE,2015-12-14 07:48:19+00:00,True,2016-09-28 17:52:46+00:00,289.42,,3,2,2016-02-16 19:07:10+00:00,64.47,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
992,new warnings in bluebird 3.0 and jasmine,"First, this isn't really jasmine's fault, so I understand if you don't think it should be fixed here.
This does seem to be the simplest place to fix it, and bluebird promises are popular...
I can make a pull request for it, but don't want to go through the effort if it's likely to be rejected.
Bluebird has, in 3.0, added a warning flagging cases where a promise is created in a promise handler, but none is returned.
There's a more detailed explanation here .
This warning is triggered whenever promises are handled like this:
it(""should check the promises result"", function (done) {
    returnsAPromise()
    .then(function (res) {
        expect(res).toBe(expectedResult);
    })
    .then(done, done.fail);
});
The warning is easy to turn off, but I like the intent behind it so would like to keep it enabled.
But that means that I need to wrap done and done.fail in a function that returns null everywhere instead of .then(done, done.fail)
.then(function () {
    done();
    return null;
}, function (err) {
    done.fail(err);
    return null;
})
Alternatively, change jasmine so that the done and done.fail functions created in the QueueRunner always return null.
  function once(fn) {
    var called = false;
    return function() {
      if (!called) {
        called = true;
        fn();
      }
      return null;
    };
  }
      next.fail = function() {
        self.fail.apply(null, arguments);
        return next();
      };",marneborn,CONTRIBUTOR,2015-12-15 01:32:11+00:00,True,2016-03-11 17:13:59+00:00,87.65,,4,4,2016-01-26 00:28:34+00:00,41.96,duzun,NONE,1,1,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
993,jasmine examples fails with npm@3,"As the transitive dependency structure for npm 3 is different than with npm 2, the cli jasmine examples command fails with:
Error: ENOENT: no such file or directory, scandir '.../node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/example/node_example/spec/helpers/jasmine_examples'",danielsiwiec,NONE,2015-12-16 05:33:27+00:00,True,2015-12-16 05:39:53+00:00,0.0,,1,1,2015-12-16 05:39:53+00:00,0.0,danielsiwiec,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
994,documentation for toHaveBeenCalledTimes,"Hi
toHaveBeenCalledTimes was recently introduced in jasmine, nice addition btw. It would be nice if it was documented here.",piuccio,NONE,2015-12-16 16:54:12+00:00,True,2015-12-16 20:26:04+00:00,0.15,,4,3,2015-12-16 20:26:04+00:00,0.15,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
996,"spyOn report error: `Expected a spy, but got Function`","code:
    let methods = {
        reportError() {},
        reportOk(which) {}
    };

    beforeAll((done) => {
        spyOn(methods, 'reportError').and.callThrough();
        smartSprite(options.source, options.output, options.retina).then((data) => {
            methods.reportOk('sprite');
            return generateStyle(options.output, options.stylePath, data[0], true, {
                retina: options.retina
            });
        }, (err) => {
            methods.reportError();
            done(err);
        }).then((data) => {
            methods.reportOk('style');
            done();
        }, (err) => {
            methods.reportError();
            done(err);
        });
    });

    it('should generate sprite successfully.', function() {
        expect(methods.reportError).not.toHaveBeenCalled();
        expect(methods.reportOk).toHaveBeenCalledWith('sprite');
    });
jasmine's version is 'v2.4.1'. And error info is Error: Expected a spy, but got Function.",creeperyang,NONE,2015-12-20 07:30:40+00:00,True,2015-12-20 08:40:01+00:00,0.05,,3,3,2015-12-20 08:40:01+00:00,0.05,creeperyang,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
997,jasmine.json docs,"I am trying to wrap jasmine into my project. The project consists of many backends and parts, so it needs to have a rather specific folder structure.
test/
  - php/
    - ... PHP Testing stuff ...
  - node/
    - jasmine.json
    - tests/

Can I use jasmine.json to tell it:

Where my tests are?
How I want them reported?
That I use ES2015/Babel?

Kind regards, Ingwie",IngwiePhoenix,NONE,2015-12-20 22:08:48+00:00,True,2015-12-21 06:11:47+00:00,0.34,,2,2,2015-12-21 06:11:47+00:00,0.34,IngwiePhoenix,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
998,How can I pass multiple capabilities via cmdline?,"I am trying something like -
--capabilities[{browserName=chrome,chrome.chdomeOptions.mobileEmulation.deviceName='Apple iPhone 6'}]
at the same time, I want my tests/methods to read the deviceName at runtime alike browser.params.browserName",allspat,NONE,2015-12-21 11:26:36+00:00,True,2015-12-21 14:26:40+00:00,0.13,,2,1,2015-12-21 14:26:40+00:00,0.13,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
999,Problem trying test window object is defined on async load,"I'm creating a test to check if a window object exists after async load, but I can't detect the object. Below I'm putting my case:
GoogleMapsLoader.js
// Google async initializer needs global function, so we use $window
angular.module('myApp')
  .service('GoogleMapsLoader', ['$window', '$q',
    function($window, $q) {

      var deferred = $q.defer();

      // Load Google map API script
      function loadScript() {
        // Use global document since Angular's $document is weak
        var script = document.createElement('script');
        script.src = '//maps.googleapis.com/maps/api/js?libraries=geometry&callback=initMap';

        document.body.appendChild(script);
      }

      // Script loaded callback, send resolve
      $window.initMap = function() {
        deferred.resolve();
      };

      loadScript();

      return {
        init: function() {
          return deferred.promise;
        }
      };
    }
  ]);
spec.js
describe('Controller: Ctrl', function(){

  var Ctrl, serviceGoogleMapsLoader, w;

  beforeEach(module('myApp'));

  beforeEach(inject(function ($controller, GoogleMapsLoader) {
    w                       = window;
    serviceGoogleMapsLoader = GoogleMapsLoader;

    Ctrl = $controller('Ctrl', {
      GoogleMapsLoader: serviceGoogleMapsLoader
    });
  }));

  it('window.google should be defined', function (done) {
    serviceGoogleMapsLoader.then(function(){
        expect(w.google).toBeDefined();
        done();
    });
  });

});",obetomuniz,NONE,2015-12-21 14:58:02+00:00,True,2016-02-16 23:07:29+00:00,57.34,,2,1,2016-02-16 23:07:29+00:00,57.34,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1001,No stand alone zip file in latest 2.4.1 release,"Unlike other releases, 2.4.1 does not have a jasmin-standalone-2.4.1.zip file.
Newbies like me might have some problems to start :(
https://github.com/jasmine/jasmine/releases
Are there any instructions on how to make a standalone from the source?",nacho4d,NONE,2015-12-22 15:26:25+00:00,True,2015-12-22 22:11:29+00:00,0.28,,2,2,2015-12-22 22:11:29+00:00,0.28,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1002,TypeError: 'undefined' is not a constructor,"Running the jasmine-gem with Jasmine 2.4.0
With a setup similar to the following (in CoffeeScript):
class @Base
  constructor : ( @options ) ->
    @_settings = $.extend( {}, @constructor._defaults, @options )

class @SubClass extends Base
  @_defaults :
    test : true

  constructor : ->
    super

    # ...
And when instantiating the child class in any test (e.g. new SubClass), I get the following error:
TypeError: 'undefined' is not a constructor (evaluating 'new SubClass')

The tests were working fine before with this setup:
class @Base
  _settings : {}

  constructor : ( @options ) -> @init?()

  _setDefaults : ( defaults ) ->
    @_settings = $.extend( defaults, @options )

class @SubClass extends Base
  init : ->
    @_setDefaults
      test : true
Functionally the code works anywhere else. However, for some reason, with the new setup of Base, the tests will always fail with that error, no matter how much I change it around. I've isolated it, updated to the latest Jasmine, and tried as much as I can absolutely think of. I've exhausted all the options I can think of, so I thought I'd drop an issue here and see.
Any help at all would be greatly appreciated! 😄",drewbarontini,NONE,2015-12-23 00:08:41+00:00,True,2016-09-14 23:20:56+00:00,266.97,,2,9,2015-12-24 15:06:28+00:00,1.62,drewbarontini,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1003,"Seeing tests run multiple times, intermittently.","Sometimes when running my tests everything in the describe section gets executed or atleast displayed multiple times on the page. I've just used the info from https://angular.io/docs/ts/latest/testing/first-app-tests.html to set it all up.
This is the TypeScript
import {Hero} from '../app/hero';
describe('Hero', () => {
    it('has name given in the constructor', () => {
        let hero = new Hero(1, 'Super Cat');
        expect(hero.name).toEqual('Super Cat');
    });
    it('has id given in the constructor', () => {
        let hero = new Hero(1, 'Super Cat');
        expect(hero.id).toEqual(1);
    });
    it('has name given in the constructor', () => {
        let hero = new Hero(1, 'Super Cat', 'Claw Scratch');
        expect(hero.power).toEqual('Claw Scratch');
    });
    it('has alter ego given in the constructor', () => {
        let hero = new Hero(1, 'Super Cat', 'Claw Scratch', 'Feline');
        expect(hero.alterEgo).toEqual('Feline');
    });
})
Which spits out this JavaScript
System.register(['../app/hero'], function(exports_1) {
    var hero_1;
    return {
        setters:[
            function (hero_1_1) {
                hero_1 = hero_1_1;
            }],
        execute: function() {
            describe('Hero', function () {
                it('has name given in the constructor', function () {
                    var hero = new hero_1.Hero(1, 'Super Cat');
                    expect(hero.name).toEqual('Super Cat');
                });
                it('has id given in the constructor', function () {
                    var hero = new hero_1.Hero(1, 'Super Cat');
                    expect(hero.id).toEqual(1);
                });
                it('has name given in the constructor', function () {
                    var hero = new hero_1.Hero(1, 'Super Cat', 'Claw Scratch');
                    expect(hero.power).toEqual('Claw Scratch');
                });
                it('has alter ego given in the constructor', function () {
                    var hero = new hero_1.Hero(1, 'Super Cat', 'Claw Scratch', 'Feline');
                    expect(hero.alterEgo).toEqual('Feline');
                });
            });
        }
    }
});
//# sourceMappingURL=hero.spec.js.map
This is my unit-test.html
<html>

<head>
    <title>1st Jasmine Tests</title>
    <link rel=""stylesheet"" href=""../node_modules/jasmine-core/lib/jasmine-core/jasmine.css"">
    <script src=""../node_modules/jasmine-core/lib/jasmine-core/jasmine.js""></script>
    <script src=""../node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js""></script>
    <script src=""../node_modules/jasmine-core/lib/jasmine-core/boot.js""></script>
</head>

<body>
    <script src=""../node_modules/systemjs/dist/system.src.js""></script>
    <script>
    // #2. Configure systemjs to use the .js extension
    //     for imports from the app folder
    System.config({
        packages: {
            'out': {
                'app': {
                    defaultExtension: 'js'
                }
            }
        }
    });
    // #3. Import the spec file explicitly
    System.import('out/unit-tests/hero.spec')
        // #4. wait for all imports to load ...
        //     then re-execute `window.onload` which
        //     triggers the Jasmine test-runner start
        //     or explain what went wrong
        .then(window.onload)
        .catch(console.error.bind(console));
    </script>
</body>

</html>
This is what I see:

It does not always show the tests multiple times.
Bug or my error?
Thanks
S",Steveiwonder,NONE,2015-12-23 10:02:49+00:00,True,2016-09-28 21:35:09+00:00,280.48,,7,7,2016-01-27 20:59:15+00:00,35.46,TheMysticMan,NONE,1,0,0,5,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1004,Test results not reported when teardown is undefined,"When the teardown function is undefined, the test result is not reported.
Failed tests are missed.
describe('not reported suite', function(){
  afterEach(undefined);
  it('failing test case', function(){
    expect(false).toBe(true);
  });
});
In this case it there might be an obvious error, but jasmine should still treat it as an error.
The following example is not that obvious:
describe('not reported suite', function(){
  var tearDown;
  beforeEach(function(){
    tearDown = function(){}
  });

  afterEach(tearDown);

  it('failing test case', function(){
    expect(false).toBe(true);
  })
});
The tests itself run and report their failure, however the teardown execution throws an exception that is caught and not handled, while discarding the test results.
See plnkr.",palortoff,NONE,2015-12-23 16:29:13+00:00,True,2017-02-15 23:19:54+00:00,420.29,,2,1,2016-02-16 23:11:01+00:00,55.28,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1005,Mocking 2nd-level modules,"I want to test a CDN helper function. It is super basic and does only one thing that makes it tricky to test - at least I think so.
var CDN = require(""./GlobalConfig"").config.CDN;
var url = require(""url"");
module.exports = function MakeCDNLink(path) {
    path = path || ""/"";
    if(CDN.enable) {
        return url.format({
            protocol: ""http"",
            host:     CDN.domain,
            pathname: path
        });
    } else {
        return CDN.baseUrl+path;
    }
}
This GlobalConfig module parses a YAML file and puts it's values into a .config property. This property is used to see if we should use a local endpoint (/cdn/...) or remote (http://cdn.example.com/...).
How can I mock this config? I want to test specific behaviors, but not needing to change my current config just to get that thing right.",IngwiePhoenix,NONE,2015-12-24 02:25:57+00:00,True,2016-02-16 23:11:54+00:00,54.87,,2,1,2016-02-16 23:11:54+00:00,54.87,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1007,spy always returns 0 for the length,I need to spy on a callback function which can be called in 2 different ways depending on the number of parameters. Unfortunately the spy function returned by spyOn always returns 0 as the value of its length property regardless of the number of parameters of the original callback. Is there a way to work around this behavior?,mfeingold,NONE,2015-12-25 01:06:28+00:00,True,2016-02-16 23:25:48+00:00,53.93,,3,3,2015-12-30 01:08:45+00:00,5.0,gpiress,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1010,Cleaning up spies after a spy was replaced and then re-spied upon leaves the wrong function in place,"If one does the following:
...
somewhere in the code being tested
    myObject.myFunction = function one() {};
...
it('does something wonderful', function() {
    spyOn(myObject, 'myFunction');
    myObject.myFunction = function two() {}
    spyOn(myObject, 'myFunction');
});
when the cleanup is done, function two() will be left on myObject, rather than the expected one().
This is ultimately due to SpyRegistry.js's #clearSpies function iterating through the spies in the ""wrong"" order.
(pull request on its way)",bodawei,CONTRIBUTOR,2016-01-04 02:59:48+00:00,True,2016-02-16 23:42:08+00:00,43.86,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1012,How do i spy on javascript DOM methods like getBoundingClientRect,,amit1911,NONE,2016-01-11 09:26:30+00:00,True,2016-02-17 00:23:33+00:00,36.62,,2,1,2016-02-17 00:23:33+00:00,36.62,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1013,GreaterThanOrEqual and LessThanOrEqual matchers,"I found myself in the situation many times to check that a number is greater than or equal than another number, or less than or equal to it, so I had to write 2 custom matchers for this.
I've noticed searching on Google, that writing ""Jasmine greater"", it suggests as first option ""Jasmine greater or equal to"", so it seems I'm not the only one to need something like that.
I would propose to add those 2 default matchers in the core. I can also offer my contribution to the project for it.",rullopat,CONTRIBUTOR,2016-01-11 22:15:21+00:00,True,2016-02-17 23:46:15+00:00,37.06,,2,2,2016-02-17 00:24:29+00:00,36.09,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1014,"In console.log, add the current test","It is sometimes difficult to know what console.log relate to.
Would it be possible to add the current test into each console.log?",jehon,NONE,2016-01-12 14:02:58+00:00,True,2016-01-12 17:39:46+00:00,0.15,,2,3,2016-01-12 17:39:45+00:00,0.15,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1016,There could be a better error message if non-funtion is passed to spy.and.callFake(),"I often change from
spy.and.returnValue(someExistingVariable);

to
spy.and.callFake(() => someVariableThatCanBeAssignedLater);

and I sometimes forget to pass a function:
// Triggers error
spy.and.callFake(someVariableThatCanBeAssignedLater);

The error that is returned does not tell me immediately what have I done wrong:
TypeError: 'undefined' is not a function (evaluating 'plan.apply(this, arguments)')

There could be a better error message that would hint the user that what has been passed to callFake is not a function.",jrencz,NONE,2016-01-13 11:37:28+00:00,True,2016-08-15 16:34:53+00:00,215.21,,2,1,2016-02-17 00:40:54+00:00,34.54,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1017,Improving handling of parse errors in test files (running with Node),"I use jasmine with Node like this:
jasmine.loadConfig({
    'spec_dir': 'app',
    'spec_files': [
        '**/**/test.{js,jsx}',
    ],
});

Then, if any of the test files has invalid syntax (possibly because of invalid babel config or anything), I get this stacktrace:
/Users/mikolajdadela/code/lb-react-frontend/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:987
      currentRunnable().addExpectationResult(false, {
                       ^

TypeError: Cannot read property 'addExpectationResult' of undefined
    at Env.fail (/Users/mikolajdadela/code/lb-react-frontend/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:987:24)
    at jasmineInterface.fail (/Users/mikolajdadela/code/lb-react-frontend/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:3423:23)
    at process.<anonymous> (/Users/mikolajdadela/code/lb-react-frontend/jasmineTestSuite.js:20:5)
    at emitOne (events.js:77:13)
    at process.emit (events.js:169:7)
    at process._fatalException (node.js:221:26)

Note that it this big error report never actually mentions the file that caused the parse error.
I'm currently using jasmine 2.4.1.",mik01aj,NONE,2016-01-14 10:57:04+00:00,True,2017-04-11 19:03:19+00:00,453.34,,4,7,2016-02-18 23:32:56+00:00,35.52,slackersoft,MEMBER,1,0,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1018,toHaveBeenCalledTimes doesn't work with 0,"florimon mentioned this problem in #994.
""It is not possible to call toHaveBeenCalledTimes() with the value 0 (zero). This is because the implementation uses ""if (!expected)"" to test whether a value was supplied for the 'expected' argument.
(I know the same can be accomplished with the stanza ""expect(...).not.toHaveBeenCalled()"" but I feel like toHaveBeenCalledTimes() should support this too).""",aligneddev,CONTRIBUTOR,2016-01-14 16:34:00+00:00,True,2016-02-17 18:35:03+00:00,34.08,,2,2,2016-01-14 16:34:18+00:00,0.0,aligneddev,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1019,StringPrettyPrinter throws TypeError when object has constructor with overridden toString method,"Test case:
describe('any', function () {
  it('any', function () {
    var Class = function () {};

    Class.toString = function () {
      return '';
    };

    var a = {};
    a.constructor = Class;
    var b = { foo: 'bar' };

    expect(a).toEqual(b);
  });
});

Result:
TypeError{message: ''null' is not an object (evaluating 'func.toString().match(/^\s*function\s*(\w*)\s*\(/)[1]')', line: 157, sourceId: 211379424, sourceURL: 'http://localhost:9876/absolute/Users/test/node_modules/jasmine-core/lib/jasmine-core/jasmine.js', stack: 'TypeError: 'null' is not an object (evaluating 'func.toString().match(/^\s*function\s*(\w*)\s*\(/)[1]')
    at http://localhost:9876/absolute/Users/test/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?:157
    at http://localhost:9876/absolute/Users/test/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?1791
    at http://localhost:9876/absolute/Users/test/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?:1714
    at http://localhost:9876/absolute/Users/test/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?:1831
    at http://localhost:9876/absolute/Users/test/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?:2705
    at http://localhost:9876/absolute/Users/test/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?:1487

How to fix:
Add additional check to fnNameFor method: https://github.com/jasmine/jasmine/blob/master/lib/jasmine-core/jasmine.js#L156
j$.fnNameFor = function(func) {
    return (func.name || (func.toString().match(/^\s*function\s*(\w*)\s*\(/) || [])[1]) || '';
  };",dmitryshimkin,NONE,2016-01-15 14:38:29+00:00,True,2016-08-15 22:51:43+00:00,213.34,,3,2,2016-02-17 00:49:28+00:00,32.42,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1020,Set up auto-update for jsdelivr,"cdnjs doesn't offer the files necessary for the standalone runner  (trying to file an issue and need this to demonstrate on jsbin), but jsdelivr does. Their latest version of Jasmine is 2.0.0. They have an auto-update feature, instructions here:
https://github.com/jsdelivr/jsdelivr
Thanks for the awesome lib!",erquhart,NONE,2016-01-16 15:37:27+00:00,True,2016-02-17 18:59:02+00:00,32.14,,2,2,2016-02-17 18:59:02+00:00,32.14,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1022,"expect(""1"").toEqual(1) fails","In Javascript:
1 == '1'
true",fjanon,NONE,2016-01-18 20:31:28+00:00,True,2016-01-19 07:23:47+00:00,0.45,,2,1,2016-01-19 07:23:47+00:00,0.45,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1023,selectively callthrough for spyOn,"I have a recursive function that i am testing and spying on
i would like to call the function once to test and subsequent functions calls to stub
so i tried to use callFake to intercept the parameters to see if it is the first call, of which i would call the actual function
however, the spyOn will still spyOn the actual function call within the callFake and enter infinite loop
// infinite loop
var testobj = {
  testing: function(i){
    console.log('inside', i)
  }
}

spyOn(testobj, 'testing').and.callFake(function(i){
  console.log(i)
  if(isFirstCall(i)){
    testobj.testing(0);  // this causes infinite loop as it is not ignored by the spy even though it is within the spy
  } else {
    fakeIt();
  }
});
testobj.testing(1);
expect(testobj.testing.calls.count()).toEqual(1)

should any calls to the spied function within the callFake itself be ignored?",peonmodel,NONE,2016-01-19 03:50:35+00:00,True,2016-01-19 04:36:30+00:00,0.03,,1,1,2016-01-19 04:36:30+00:00,0.03,peonmodel,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1024,testing custom matcher failure case,"Say I want to test the failure case of a custom matcher called toDoCustomMatchy
After a bunch of fiddling I end up with this:
it('fails and stuff', () => {
  let expectationPassed, expectationMessage;

  const expectation = expect(guy);

  expectation.addExpectationResult = (pass,result) => {
    expectationPassed = pass;
    expectationMessage = result.message;
  };

  expectation.toDoCustomMatchy();

  expect(expectationPassed).toEqual(false);
  expect(expectationMessage).toMatch(/Expected guy to custom matchy/);
});
Is there a better way?",atomanyih,NONE,2016-01-19 22:21:05+00:00,True,2016-02-17 00:53:17+00:00,28.11,,3,3,2016-01-19 22:24:53+00:00,0.0,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1025,Improve error messages,"Hi,
Some errors are confusing ex: with spies, toThrow etc.
Ex:
spyOn(obj.list)
// No method name supplied

It's hard to figure out where is the error.
So I'm rewriting errors:
Ex

to

Do you have any suggestions?",dhoko,NONE,2016-01-20 13:28:52+00:00,True,2016-03-18 18:00:51+00:00,58.19,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1027,would be nice if the reporter can be passed as CLI arg,"For instance jasmine --reporter junit.
Of course you need to define some convention for the npm module name of a supported reporter.",timaschew,NONE,2016-01-21 12:13:16+00:00,True,2018-01-26 18:59:17+00:00,736.28,,8,6,2016-01-21 15:46:54+00:00,0.15,aMarCruz,NONE,1,0,0,5,['npm'],False,False,False,False,False,True,False,False,False,False,False,False,False,False,False
1028,Does fail function exist?,"Hi,
I know there has been a lot of discussions over fail, this.fail and similar calls. What surprises me is that there is definitely a fail function (I can call 'fail(""Fail the test"")' from inside ""it"" tests) and I can see it in the source code:
fail: function() {
  return env.fail.apply(env, arguments);
},

but it is not documented and in some cases its existence is denied. What is the status for it? Is it an undocumented/unsupported feature? Is using it a good idea or it may be dropped at some future versions? So far I have seen it in Jasmine 2.2 and 2.4.1
Thanks,
Hajix",hajiz,NONE,2016-01-21 18:35:05+00:00,True,2016-01-21 20:53:33+00:00,0.1,,2,2,2016-01-21 18:46:24+00:00,0.01,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1030,Ability to load tests dynamically and rerun jasmin/reporter,"I am currently trying to run jasmine tests from partials/ components, which are dynamically loaded via ajax. The idea is to have the corresponding reports appended to the Body (html-reporter) for each “view”, while avoiding the page-reload. I am able to run jasmine exactly once. Is there a way to load test suites via ajax and/or clear jasmines html reports/ unload jasmine or reload/reinitialize it when I load dynamic content?
Thanks.",HansHammel,NONE,2016-01-28 12:06:18+00:00,True,2016-02-22 19:50:29+00:00,25.32,,2,1,2016-02-22 19:50:29+00:00,25.32,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1031,Notify reporters on errors when using catchExceptions/throwOnExpectationFailure,"If you set any of the below:
  env.catchExceptions(false);
  env.throwOnExpectationFailure(true);
No reporter is notified in case of failure. I would expect jasmineDone to be executed",adamziel,NONE,2016-01-28 17:22:57+00:00,True,2016-02-18 17:41:36+00:00,21.01,,2,1,2016-02-18 17:41:36+00:00,21.01,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1032,"Jasmine, TypeScript and spyOn","Hi,
I am migrating some tests from JavaScript to TypeScript and I have some issue with spyOn. I have tried
spyOn(fooService, 'fooMethod').and.returnValue();
but it does not work, in the d.ts file the function is declare so I have tried to
jasmine.Spec.spyOn(fooService, 'fooMethod').and.returnValue();
and it does not work as well, the transpiler says Property 'Spec' does not exist on type 'typeof jasmine'.
How can I use the spyOn method?
Thanks a lot for the attention.",blackat,NONE,2016-01-29 14:21:08+00:00,True,2016-02-01 08:58:29+00:00,2.78,,2,4,2016-01-29 14:30:01+00:00,0.01,JoseRoman,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1033,How can I extend the spy API.,"Hi everyone,
i am wondering, since i use promisses a lot. How can I extends the spy API to do something like this:
someSpyObj.someSpyMethod.and.returnRejectPromise()
A workaround is something like this:
var RejectPromise = function () { 
    return new Promise(function (resolve, reject) {
        reject();
    };
}
...
someSpyObj.someSpyMethod.and.returnValue(RejectPromise());

Thanks,
Stefan",,NONE,2016-01-31 12:58:57+00:00,True,2016-02-22 20:09:06+00:00,22.3,,2,1,2016-02-22 20:09:06+00:00,22.3,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1034,Jasmine spec dependency,"In jasmine suite , if we have 10 specs , how can we arrange dependeny specs such that if any dependency specs are failed the jasmine should not execute other specs which has to be executed.
In testNG library which is used for java unit testing where we are using dependency groups or methods attribute on an @test annotation",vivekbrahmadandi,NONE,2016-02-01 12:47:47+00:00,True,2016-02-23 18:28:01+00:00,22.24,,3,2,2016-02-13 03:47:21+00:00,11.62,floverdevel,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1035,"ui-router and transitionTo, jasmine expecting mysterious relative value","Using jasmine (2.4.0) and angular ui-router I'm having an issue
Expected spy transitionTo to have been called with
[ Object({ name: '', url: '^', views: null, abstract: true }), Object({}), Object({ inherit: true, relative: null }) ]
but actual calls were
[ Object({ name: '', url: '^', views: null, abstract: true }), Object({}), Object({ inherit: true, relative:  }) ]
The problem being the relative: null and relative:__ .  I can't figure out the value of relative that Jasmine is looking for, I've tried null, undefined, empty string, empty object, etc.",spiderbites,NONE,2016-02-02 16:46:23+00:00,True,2016-09-28 00:59:35+00:00,238.34,,3,2,2016-02-18 23:50:28+00:00,16.29,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1037,Crash spying on window.history.pushState introduced between 1.3.4 and 1.4.1,"Hi,
We upgraded to 1.4.1 from 1.3.4 via grunt and started getting this error on our test suite. It looks like this:
Summary (1 tests failed)
X the history check
   Error: pushState is not declared writable or has no setter in file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js (line 2008)
   Error: pushState is not declared writable or has no setter
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:2008
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:776
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:3427
       at file:///Users/msartint/the-project/test/spec_bundle.js:118747
       at attemptSync (file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:1886)
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:1874
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:1859
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:697
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:363
       at file:///Users/msartint/the-project/.grunt/grunt-contrib-jasmine/jasmine.js:2479

And the code looks something like this:
describe('the', function() {
  it('history check', function() {
    spyOn(window.history, 'pushState');
...
    expect(window.history.pushState).toHaveBeenCalled();
  });
});

Is there something that changed about how to access this object?
Thanks!",msartintarm,NONE,2016-02-03 06:16:13+00:00,True,2016-09-27 01:02:39+00:00,236.78,,3,2,2016-02-19 00:09:14+00:00,15.75,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1038,How to test for session variables?,"I'd like to test for the value of a session variable.
Right now, this happens:

I have a default session variable: Session.setDefault('alert', null);
I have the test suite click a button which makes the session variable value = true: Session.set('alert', true);
I test for the value of Session.get('alert'); and it comes back with null.

How can I get the correct session variable value after an event takes place?
FYI, I'm using the sanjo:jasmine implementation for Meteor.",bwobst,NONE,2016-02-03 16:28:01+00:00,True,2016-02-22 22:12:31+00:00,19.24,,2,1,2016-02-22 22:12:31+00:00,19.24,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1039,with this and without this,"may i ask? sorry to open new issue.
i just confuse why i have to use this to share variable on a suite.
i just new on unit test, and i work with example on the internet (which not use this).
i stuck then read the intro documentation, realize using this to share variable.
now it work fine, but why i got undefined when not using this.",brutalcrozt,NONE,2016-02-03 20:52:00+00:00,True,2016-02-04 03:45:50+00:00,0.29,,4,8,2016-02-04 03:45:50+00:00,0.29,Gerg,CONTRIBUTOR,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1040,Avoid potential pitfall of forgotten `done` parameter,"With the done syntax for asynchronous tests, it's possible to inadvertently write something like this:
it(""is an async spec"", function() {
  setTimeout(function() {
    expect(true).toBeFalsy();
    done();
  }, 1000);
});
This spec will pass without encountering the expectation. Is there a way that Jasmine could issue some sort of early warning in a case like this?
One way would be to warn if a spec executed no expectations, but that would only solve the problem for specs and not for forgetting the done parameter on a beforeEach(), for example.",ptomato,CONTRIBUTOR,2016-02-03 23:52:09+00:00,True,2016-10-14 16:51:04+00:00,253.71,,6,12,2016-02-04 00:15:56+00:00,0.02,magcius,NONE,1,2,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1043,Include TypeScript typings in the distribution,"Currently, Jasmine users writing in TypeScript need to get the type information from a third-party side channel, such as https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/jasmine/jasmine.d.ts
The means of getting this file into the project are all somewhat inconvenient, especially for novice developers. It also has versioning issues: developers must take extra care to keep the typings file synced with the version of Jasmine they are running.
The best way currently available in the TypeScript ecosystem is to publish typings in the npm distribution. See https://github.com/Microsoft/TypeScript/wiki/Typings-for-npm-packages
Jasmine could do this in one of two ways:

Take ownership of the existing jasmine.d.ts file for each minor version of Jasmine, include that file in the distribution, add a ""typings"" field to the package.json, and also add a test in the release process that ensures that example uses of Jasmine actually type-check.
Produce typings directly from the sources, by including correct type information in the source code and extracting typescript type definitions from it. The most straightforward way is to rename the sources to .ts, introduce a compilation step in the build, and publish the resulting .d.ts files. Another way worth investigation is to use JSDoc type annotations, and a converter like https://github.com/angular/clutz to extract .d.ts files from these. But in this latter case, you need something that type-checks the JSDoc annotations or they'll have no chance of staying correct. (eg. Closure Compiler)

For protractor, we are currently going for the latter approach, and migrating the sources to TypeScript.
I'm curious what the project maintainers think about better supporting TypeScript users, have you heard a demand for that?",alexeagle,NONE,2016-02-07 23:10:33+00:00,True,2016-11-18 19:42:13+00:00,284.86,,3,5,2016-03-01 15:42:26+00:00,22.69,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1045,Using toThrowError testing directive in Jasmine 2.4.1,"I am testing a directive input parameters and throwing new Error() if they are invalid. I am using Jasmine 2.4.1 and Angular 1.4.9
If my directive has templateUrl defined, the exception is recognized by Jasmine because the exception object is instanceof Error.
However, if my directive doesn't have templateUrl defined (because I am creating directive without template), the exception is not recognized by Jasmine, because the exception object is not instanceof Error.
More details here:
http://stackoverflow.com/questions/35010158/using-tothrowerror-testing-directive-in-jasmine-2-4-1",odancik,NONE,2016-02-11 15:21:08+00:00,True,2016-02-19 01:45:18+00:00,7.43,,2,5,2016-02-19 01:45:17+00:00,7.43,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1050,Add getMock() functionality to mock classes (to work with ECMA6/ TypeScript classes),Would be useful when working with angular2/typescript to be able to stub all methods in one go.,vladimir-ivanov,NONE,2016-02-22 15:14:38+00:00,True,2016-11-10 02:01:34+00:00,261.45,,3,9,2016-02-23 22:32:32+00:00,1.3,slackersoft,MEMBER,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1051,HTML Reporter Spec Link Goes Wrong When Base URI Was Set,"In SpecRunner.html, when adding an <base href=""../""> to document, the reporter-generated spec link may looks like this:
<a href=""?spec=prologue%20InstallFunctions()"">InstallFunctions()</a>
when I clicked the link.  browser window jumped to the base URL page
So I think, the specHref function in jasmine-html.js shoud be updated from
    function specHref(result) {
      return addToExistingQueryString('spec', result.fullName);
    }
to
    function specHref(result) {
      var search=addToExistingQueryString('spec', result.fullName);
      var href=search;
      if(document.URL!=document.baseURI){
        href=location.pathname+search;
        if(document.baseURI.indexOf(location.origin+""/"")==-1){
          href=location.origin+location.pathname+search;
        }
      }
      return href;
    }
So that spec link in test result works fine test result under such a circumstance.
P.S.
I didn't considered about browser compatibility of code document.baseURI and location.origin.
Here are two fallback functions to resolve the concerns:
function getBaseURI(){
    var a=this.createElement(""a"");
    a.href="""";
    return a.href;
}
function getOrigin(){
    return this.protocol+""//""+this.host;
}
To make it compatible with old browsers:

use getBaseURI.call(document) instead of document.baseURI
use getOrigin.call(location) instead of location.origin.",fuweichin,NONE,2016-02-23 06:33:19+00:00,True,2016-11-10 01:49:20+00:00,260.8,,2,2,2016-11-10 01:49:20+00:00,260.8,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1052,jasmine repository contains zero-padded file modes,"The jasmine repository is not clean.
""git fsck"" returns the following errors:
Checking object directories: 100% (256/256), done. warning in tree 30e85099c116ada0d0588915567e6ed438d52ed7: contains zero-padded file modes warning in tree a0a1663600be9b6d099bffd067e4452c5a1a37ef: contains zero-padded file modes warning in tree 34b50ab9f16aecca8263830bfe59f5b4333e4501: contains zero-padded file modes warning in tree 90e54d021c732fb81af9989a019c87c4aee3e621: contains zero-padded file modes warning in tree d589297f4654e4a685eac61cce7481437e612b8b: contains zero-padded file modes warning in tree 0cc331339a0f1e685055bbdf1b38a2f647467a44: contains zero-padded file modes warning in tree 0c932084c1f9f2b2dc86a4dc98dcee126b76b644: contains zero-padded file modes Checking objects: 100% (12993/12993), done.
Someone has a clean repository somewhere?
I am not able to clone the project with a recent version of git like 2.7.",nfk,NONE,2016-02-23 13:58:27+00:00,True,2016-11-10 02:13:15+00:00,260.51,,2,3,2016-02-24 10:13:37+00:00,0.84,nfk,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1053,"spyOn(myObject, 'myMethod').with('this argument').andReturn('that');","I would like to set a return value for a spy but only when it is called with a specific argument
spyOn(myObject, 'myMethod').with('this argument').andReturn('that');

This would return nothing
myObject.myMethod('not a recognized argument');

This would return 'that':
myObject.myMethod('this argument');

I couldn't find this brought up in the issues previously. Is this something that I could offer a pull request and add the feature? Am I missing something as to why this has not been implemented already?",bzitzow,NONE,2016-02-23 23:51:08+00:00,True,2016-02-24 00:11:12+00:00,0.01,,2,1,2016-02-24 00:11:12+00:00,0.01,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1054,'and' assertion chainer,"It would be good to have an and chainer which allows for multiple assertions/expectations to be chained into a single statement.
When testing that something has been correctly instantiated, it is common to test that it is neither null nor undefined.
Currently, this must be done like so:
it(""should set someProperty"", () => {
    let someInstance = new SomeClass();

    expect(someInstance.someProperty).not.toBe(null);
    expect(someInstance.someProperty).not.toBe(undefined);
});

There would then be further tests added to ensure that it has the correct value, but this test would usually come first when TDDing.
It would be good to chain the two expect statements into a single statement, like this:
it(""should set someProperty"", () => {
    let someInstance = new SomeClass();

    expect(someInstance.someProperty)
        .not.toBe(null)
        .and.not.toBe(undefined);
});",Jameskmonger,NONE,2016-02-25 12:19:40+00:00,True,2016-03-01 15:09:04+00:00,5.12,,5,4,2016-03-01 06:07:21+00:00,4.74,sinaru,NONE,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1056,Microsoft Edge crashes when using array .toEqual on arrays multiple times,"I recently updated a lot of unit tests from jasmine 1 to 2, and now my tests aren't running on Edge anymore. The UI starts showing then I've got a ""This page is having a problem loading"" page error. After a lot of fiddling, I found that it was caused by calling toEqual with an array (expect(...).toEqual([...])) multiple times (but a very few calls is enough to reproduce the error).
I made a video to illustrate the issue: http://paste.graou.eu/896249ea611b4f80aee3d62e4e44fe4a.webm . In this example I have to refresh two times to crash Edge, but with a lot more tests the issue is reproducible everytime.
Here is the code I used: http://paste.graou.eu/77512d1a469845219357333b78937be3.tgz
I bisected jasmine repository and it looks like a regression from 53b0752 , but I can't explain why. Reverting this commit solves the issue.
Edge version: 20.10240.16384.0 (from a Win10 http://modern.ie VM)
jasmine version: 2.4.1 (tried on master too, same issue)
Is it a known issue? Should I avoid using a modern.ie VM? Am I the only one facing this issue?",BenoitZugmeyer,NONE,2016-02-26 17:29:45+00:00,True,2016-02-29 13:26:39+00:00,2.83,,2,3,2016-02-26 19:32:39+00:00,0.09,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1057,Add .editorconfig for easy code style configuration,Most IDEs and modern editors supports or have plugins for using .editorconfig file. Such file in root project directory describes such things as indentation for different file types. I think it can be very useful for a lot of programmers who have their tools configured by default for using 4 spaces or even tabs to work with Jasmine source code.,kapke,CONTRIBUTOR,2016-02-28 17:14:37+00:00,True,2016-03-02 01:51:33+00:00,2.36,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1060,Cannot read property 'callThrough' of undefined,"Hi, all. Here is my test:
var someObj = require('someObj');
describe('test registerListener.', function() {
    beforeEach(function() {
        spyOn(someObj, 'registerListener').and.callThrough();
        someObj .registerListener();
    });

    it('tracks that the registerListener was called', function() {
        expect(someObj.registerListener).toHaveBeenCalled();
        expect(someObj.registerListener).not.toThrow();
    });
});

I don't know why that I keep getting this error: ""Cannot read property 'callThrough' of undefined"".
But if I get rid of .and.callThrough, everything goes fine.
Any idea?",AnnieCyl,NONE,2016-02-29 09:00:00+00:00,True,2016-03-01 01:44:48+00:00,0.7,,1,2,2016-02-29 09:12:21+00:00,0.01,AnnieCyl,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1063,Jasmine Runs Test Three Times,"I am running Karma/Jasmine/Angular 2.0 tests on my development box. Just recently, Jasmine on my development box decided to start running my tests three times. Yes, exactly three times, every time.
On the first run, everything passes as expected. However, on the second and third pass, all of the same things fail. It always acknowledges that there are 7 tests, but runs 21, and 10 fail (first-grade math out the window)????
This also fails on Travis with SauceLabs. (Note: That links to an older build with 3 tests, but ran 9, and 5 fail???)
I have a screenshot, karma.conf.js file, and one suite which started this whole thing. Any help with be greatly appreciated.

Culprit [TypeScript] (Remove this and problem solved on my dev box):
Full source
describe('From the Conductor Service', () => {
    let arr: Array<ComponentStatusModel> = null;
    let svc: ConductorService = null;

    beforeEach(() => {  
        arr = [/* Inits the array*/];
        svc = new ConductorService();
    });

    describe('when it is handed a container to hold objects which need loaded', () => {
        // More passing tests...

        /// vvvvv The culprit !!!!!
        describe('then when you need to access the container', () => {
            beforeEach(() => {
                svc.loadedContainer = arr;
            });

            it('it should always be available', () => {
                assertIsLocalDataInTheService(arr, svc.loadedContainer);
            });
        });
        /// ^^^^^ End of culprit !!!!!
    });

    // More passing tests...
});

Failing Tests:

Browser Screenshots:
Not sure if this is related, but before all of the errors happen, the Jasmine call stack is smaller (left, observe scrollbar). After the errors start, the stack just gets bigger with repeating calls to the same functions (right, observe scrollbar).

Suite Stack is Wrong:
In my test, the Nanobar and Conductor spec files are totally separate. However, you can see the suites array includes stuff from the Nanobar ans Conductor specs. Somehow Jasmine mashed these two spec files together (after everything started failing), and resulted in my describe() statements not making any sense when published to the console.

Simplified karma.conf.js:
Full source
module.exports = function (config) {
    config.set({
        autoWatch: false,
        basePath: '.',
        browsers: ['Chrome'],
        colors: true,
        frameworks: ['jasmine'],
        logLevel: config.LOG_INFO,
        port: 9876,
        reporters: ['coverage', 'progress'],
        singleRun: true,

        coverageReporter: {
            // Code coverage config
        },

        files: [
            // Loads everything I need to work
        ],

        plugins: [
            'karma-chrome-launcher',
            'karma-coverage',
            'karma-jasmine'
        ],

        preprocessors: {
            'app/**/*.js': ['coverage']
        },

        proxies: {
            // Adjust the paths
        }
    })
}",oliverspryn,NONE,2016-03-01 01:26:47+00:00,True,2016-11-08 00:47:52+00:00,251.97,,4,3,2016-04-24 16:22:54+00:00,54.62,tcpip4000,NONE,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1064,Can't chain 'and.callThrough' with 'and.returnValue' to spy,"Code fails when chaining 'and.callThrough' with 'and.returnValue' to spy.
See below codes. Notice the chaining order causes same test to fail and pass different occasions.
describe('Spy', function () {
    var bar = null;

    beforeEach(function () {
        this.foo = {
            setBar: function (value) {
                bar = value;
                return bar;
            }
        };
        spyOn(this.foo, 'setBar').and.returnValue(52).and.callThrough();
        this.foo.setBar(42);
    });

    // passes
    it(""expect bar to be 42"", function () {
        return expect(bar).toBe(42);
    });

    // fails. return value is 42.
    it(""expect 52 as return value"", function () {
        return expect(this.foo.setBar(42)).toEqual(52);
    });
});
describe('Spy', function () {
    var bar = null;

    beforeEach(function () {
        this.foo = {
            setBar: function (value) {
                bar = value;
                return bar;
            }
        };
        spyOn(this.foo, 'setBar').and.callThrough().and.returnValue(52);
        this.foo.setBar(42);
    });

    // fails. bar is null.
    it(""expect bar to be 42"", function () {
        return expect(bar).toBe(42);
    });

    // passes
    it(""expect 52 as return value"", function () {
        return expect(this.foo.setBar(42)).toEqual(52);
    });
});",sinaru,NONE,2016-03-01 05:53:20+00:00,True,2016-03-01 15:02:15+00:00,0.38,,4,5,2016-03-01 15:02:15+00:00,0.38,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1065,Link to individual tests by id instead of full GWT,"Qunit has a link like: http://localhost:49313/test/unit/index.aspx?testNumber=510
to contrast Jasmine creates links like http://localhost:52734/unittests/tests.aspx?spec=Given%20sort%20model%20when%20sorting%20And%20setting%20the%20sort%20option%20And%20it%20updates%20the%20sort%20option%20should%20set%20orderBy%20to%20ascending
Proposal: Add ids to each test and links like QUnit to reduce query string length.",aligneddev,CONTRIBUTOR,2016-03-01 19:29:14+00:00,True,2016-03-17 16:48:13+00:00,15.89,,2,2,2016-03-17 15:32:35+00:00,15.84,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1066,Edge case for jasmine init using node,"This may be a very unlikely and trivial edge case, but wanted to bring it up.
When running jasmine init within a folder that already has a spec folder it will look for jasmine.json within spec/spec/support/jasmine.json folder.
Granted you likely wouldn't have a spec folder if you were running jasmine init and this may be a bit too trivial.  Felt like sharing.
Laptop:spec user$ jasmine
module.js:341
    throw err;
    ^

Error: Cannot find module '/Users/user/workspace/localrepo/spec/spec/support/jasmine.json'
    at Function.Module._resolveFilename (module.js:339:15)
    at Function.Module._load (module.js:290:25)
    at Module.require (module.js:367:17)
    at require (internal/module.js:16:19)
    at Jasmine.loadConfigFile (/usr/local/lib/node_modules/jasmine/lib/jasmine.js:83:16)
    at runJasmine (/usr/local/lib/node_modules/jasmine/lib/command.js:92:11)
    at Command.run (/usr/local/lib/node_modules/jasmine/lib/command.js:49:7)
    at Object.<anonymous> (/usr/local/lib/node_modules/jasmine/bin/jasmine.js:11:9)
    at Module._compile (module.js:413:34)
    at Object.Module._extensions..js (module.js:422:10)",mcnichol,NONE,2016-03-04 05:27:14+00:00,True,2016-03-04 05:29:34+00:00,0.0,,1,1,2016-03-04 05:29:34+00:00,0.0,mcnichol,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1068,Website hard to read on high-dpi non-retina displays,"For some reason, you specify font sizes in px, instead of using a method that allows scaling.  As a result, unless you're using a Mac, the website is fairly useless, since the code samples are almost unreadable.   Like so:  http://i.imgur.com/veCLXmm.png
You don't see this effect on your Mac because OS X browsers play games with how many pixels per px are rendered.  The rest of us with nice monitors do not get this special treatment.  Text-zoom settings in Chrome do not affect px-specified font sizes, so low-vision people who rely on these settings are unable to use your site.
You may find luck multiplying by .75 and switching to pt, which should allow scaling, or you may consider switching to em/rem, with which most accessibility packages work very well.",khm,NONE,2016-03-05 19:16:54+00:00,True,2016-03-10 17:22:14+00:00,4.92,,2,1,2016-03-10 17:22:14+00:00,4.92,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1069,Enumerate Jasmine Suites and related Spec names,"Hi , I am developing a UI for displaying all the jasmine tests specified in a spec file.
I am looking for some handle in jasmine API which can enumerate all the spec and suite names for me without making any change in the API.
Please let me know if anything available of such sort. For now , I am tweaking in the code by appending a suiteDetails array in to the "" jasmine env"" variable from boot.js and populating it inside the ""getSpecName"" API method which has control to both spec and related suite name.",aggarwalricha,NONE,2016-03-08 21:39:11+00:00,True,2016-03-15 16:20:42+00:00,6.78,,2,1,2016-03-15 16:20:42+00:00,6.78,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1070,Jasmine doesn't seem to like Number.MAX_SAFE_INTEGER for timeouts,"This fails:
beforeEach(function(done) {
  setTimeout(function () {
    done();
  });
}, Number.MAX_SAFE_INTEGER);

describe(""Some thing"", function() {
  it(""should do something"", function() {
    console.log('did something');
  });
});
With Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL",keirlawson,NONE,2016-03-11 16:22:25+00:00,True,2016-09-28 00:46:39+00:00,200.35,,3,1,2016-08-15 16:47:19+00:00,157.02,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1071,Proposal: Mock requestAnimationFrame,"It would be great to have either the MockClock or some other utility have a means of mocking requestAnimationFrame (or rAF as I like to call it).
Motivation
A lot of UI components rely on rAF to avoid synchronous layout and render in sync with the browser's native render cycle. Animation libraries that provide fine-grained control over such animations also lean heavily on the method. Given that jasmine has facilities for mocking dates, timers, and Ajax, I feel functionality to mock rAF is appropriate.
Proposed Implementation
The rAF should act similarly to the way that set{Timeout,Interval} behave when mocked. Specifically it would be nice if it:

Provided the ability to tick() all queued callbacks at once
Provided the ability to tick a certain number of callbacks, e.g. tick(n) where n is the first n callbacks
Supported cancelAnimationFrame
Perhaps as a nice to have, provided a way to retrieve a copy of the array of scheduled callbacks, e.g. if you wanted to validate that there are not pending callbacks.

describe(""Manually Ticking Jasmine's requestAnimationFrame"", function() {
  var rafCallback1, rafCallback2;

  beforeEach(function() {
    jasmine.raf().install();
    rafCallback1 = jasmine.createSpy('rafCallback1');
    rafCallback2 = jasmine.createSpy('rafCallback2');
  });

  afterEach(function() {
    jasmine.raf().uninstall();
  });

  it(""causes all callbacks given within an rAF cycle to be called"", function() {
    requestAnimationFrame(rafCallback1);
    requestAnimationFrame(rafCallback2);
    jasmine.raf().tick();
    expect(rafCallback1).toHaveBeenCalled();
    expect(rafCallback2).toHaveBeenCalled();
  });

  it(""allows for only a certain number of callbacks to be called"", function() {
    requestAnimationFrame(rafCallback1);
    requestAnimationFrame(rafCallback2);
    jasmine.raf().tick(1);
    expect(rafCallback1).toHaveBeenCalled();
    expect(rafCallback2).not.toHaveBeenCalled();
  });

  it(""supports cancelAnimationFrame"", function() {
    var frameId = requestAnimationFrame(rafCallback1);
    requestAnimationFrame(rafCallback2);
    cancelAnimationFrame(frameId);
    jasmine.raf().tick();
    expect(rafCallback1).not.toHaveBeenCalled();
    expect(rafCallback2).toHaveBeenCalled();
  });

  // Nice to have
  it(""can provide a read-only queue of pending callbacks?"", function() {
    requestAnimationFrame(rafCallback1);
    requestAnimationFrame(rafCallback2);
    expect(jasmine.raf().pendingQueue().length).toEqual(2);
    jasmine.tick(1);
    expect(jasmine.raf().pendingQueue().length).toEqual(1);
    jasmine.raf().pendingQueue().shift();
    expect(jasmine.raf().pendingQueue().length).toEqual(1);
    expect(jasmine.raf().pendingQueue()).toEqual([rafCallback2]);
  });
});
I feel like most of the code used behind the clock functionality could be repurposed for this, and either way I am happy to take point on this and would love to discuss this with the team further. Thanks!",traviskaufman,NONE,2016-03-11 22:53:50+00:00,True,2016-09-29 00:58:23+00:00,201.09,,3,4,2016-03-15 11:26:45+00:00,3.52,traviskaufman,NONE,0,1,0,2,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1072,beforeAll() inside xdescribe(),"The code of spec looks like follow
...
xdescribe(""Test 42"", function () {
beforeAll(function () {
.....
// This code is executed in case the scope of tests is disabled with x: xdescribe(....
.....
});
...
It is supposed that if the tests are disabled within xdescribe then ALL executions inside of scope of xdescribe should be disabled as well.
Does it make sense to allow beforeAll be enabled here?",yageev,NONE,2016-03-13 18:51:23+00:00,True,2016-09-27 01:00:57+00:00,197.26,,4,3,2016-04-20 16:22:54+00:00,37.9,ravikumars,NONE,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1073,Feature Request: call real function from callfake,"Hi,
I might have missed some documentation, but there seems to be no easy way to call the original function from a spy's callFake. Example of how this could work:
spyOn(bar, 'foo').and.callFake(function() {
  // Some testing stuff here
  bar.foo.original();
  // Some more testing stuff here
});

I found this could come in handy in some cases. Thoughts?
Thanks,
Vincent",vgrevendo,NONE,2016-03-14 18:00:47+00:00,True,2016-12-02 22:22:21+00:00,263.18,,5,6,2016-05-07 19:04:37+00:00,54.04,sgravrock,MEMBER,2,1,0,2,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1074,Piping a readable to a writable stream yields unexpected results,"When running the following program with node, the contents of the input file are shown in the terminal output:
require('fs').createReadStream('input.txt').pipe(process.stdout);
However when executing the same program with jasmine, nothing is shown. Listening to the data event emitted by the readable stream with on('data', ...) yields no events.
Checking the docs for the node Readable streams:

You can switch to flowing mode by doing any of the following:

Adding a data event handler to listen for data.
Calling the stream.resume() method to explicitly open the flow.
Calling the stream.pipe() method to send the data to a Writable.


So why doesn't this happen when running with jasmine?
Note: Replacing the file stream with any other readable stream, or process.stdout with any other writable stream shows the same behavior.
Note: When wrapping the code in a specification, as follows, the problem persists as well:
it('should output the file', function () {
  require('fs').createReadStream('input.txt').pipe(process.stdout);
});",tdecaluwe,NONE,2016-03-16 19:59:45+00:00,True,2016-09-28 01:04:23+00:00,195.21,,3,1,2016-03-21 07:11:52+00:00,4.47,amavisca,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1075,Pretty print sparse arrays,"Jasmine's pretty printer handles the string indexes of arrays nicely, but I am getting less than desirable results when a number index is used and the array is very sparse.
I ran into this issue due to the the javascript quirk that causes numerical string indexes to be treated the same as number indexes which increases the reported length.
var array = [];
array['200'] = 1;
array['key'] = 2;
console.log(jasmine.pp(array));
[ undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, ..., key: 2 ]
The expected output for this example would be [ 200: 1, key: 2 ].
Dense arrays should almost certainly output the way they do now. Outputting an array's number indexes is usually less readable. As far as I know there is no standard density threshold that qualifies an array as sparse.
One reason this is an issue is that I am getting too much unneeded output, so the qualification could be a reduction in output size. A percentage of undefined values would be the easiest. Estimating the difference in output length is possible to do in constant time, but is probably overkill.
Another reason this is an issue is that the actual value I am interested in gets folded into the ... and obscured by a wall of 100 undefined values. That may indicate that this is only an issue with arrays whose length exceeds that output limit (100).

I am aware that there are helpers specifically built for jasmine that aid in cleaning up the output of matchers in odd use cases like this. I am using jasmine-collection-matchers.
This issue arises when a test like expect(foo).toHaveBeenCalledWith('arg1', 'arg2') fails and one of the spy's other (potentially unrelated) calls was passed a large, sparse array. When jasmine outputs the set of all arguments for the calls to that spy, the useful calls are obscured by the wall of undefined values.


Note: I understand abusing arrays as objects is a weird code pattern, but I have to test some code as is before I can shift any of its paradigms.",deckar01,NONE,2016-03-18 17:16:04+00:00,True,2016-03-18 19:04:53+00:00,0.08,,2,3,2016-03-18 18:35:58+00:00,0.06,deckar01,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1076,[toHaveBeenCalledWith] is not freezing the object passed to the function,"given the example:
spyOn(accountService, 'create').and.callFake(function (account) {
    account.id = 3;
    return q.resolve();
});

accountService.create({name: 'Kakaroto account'});
expect(accountService.create).toHaveBeenCalledWith({name: 'Kakaroto account'});
I got the following error:
Expected spy create to have been called with [ Object({ name: 'Kakaroto account' }) ] but actual calls were [ Object({ name: 'Kakaroto account', id: 3 }) ].
I know, it's not a good practice change the same object, this can be easily solved in my side of the code just making a copy of the account object, but the fact is: I called accountService.create with
{ name: 'Kakaroto account' } and the test is saying I didn't.
Probably the code is just saving a reference to the original object.
Is there a way to just take a copy of the object when it's passed to the function?",viniciusdacal,NONE,2016-03-18 19:55:54+00:00,True,2016-09-26 23:57:21+00:00,192.17,,4,4,2016-03-28 10:43:18+00:00,9.62,motizuki,NONE,2,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1078,FeatureRequest: flags to filter specs to run,"First: amazing job guys.
I think it would be great to allow developer to run specific specs by matching their name directly from command line.
When a fail raises after a mod, it's actually a pain to search and edit the spec file to apply the ""f"" before the interested ""it"" or ""describe"" block.
Could a flag like ""-g pattern"" to run just blocks matching the given pattern be implemented in the future?",damianobarbati,NONE,2016-03-20 17:49:08+00:00,True,2016-04-26 15:10:35+00:00,36.89,,2,2,2016-04-24 17:33:23+00:00,34.99,csymeonides,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1080,Jasmine seeing parsing error,"When feeding Jasmine this dummy data:
const testShowInfo = '{""id"": ""11655593"", ""artist"": ""Odesza"", ""date"": ""Thursday, March 24, 2016 at 10:00PM"", ""venue"": ""Pacific Coliseum"", ""location"": ""Vancouver, Canada"", ""tickets"": ""available""}';

const test_csrf = 'KGSa3p5f-eJDLDjksk6FQmRqx2aouBU9zY-w';

...and running this test (I'm returning and expecting an arbitrary number while I troubleshoot), I get SyntaxError: Unexpected token u:
describe('The Save Show Form', function() {

  beforeEach(function() {

    saveShow = {
      saveShowToDashboard: function(info, csrf) {
        const parsedShowInfo = JSON.parse(info);
        const _csrf = csrf;
        const data = {
          tourInfo: parsedShowInfo,
          token: _csrf
        };
        return 2;
      }
    };

    spyOn(saveShow, 'saveShowToDashboard').and.callThrough();

    saveShow.saveShowToDashboard(testShowInfo, test_csrf);

  });

  it('Should return a value of 2 for this test.', function() {
    expect(saveShow.saveShowToDashboard()).toEqual(2);
  });
});

According to my browser console, everything is being parsed just fine. Could this be a bug?",danemery,NONE,2016-03-21 18:52:46+00:00,True,2016-03-22 15:37:00+00:00,0.86,,2,2,2016-03-22 02:30:02+00:00,0.32,cwmoo740,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1081,Cannot find  spec\support\jasmine.json',"Today I did npm installed jasmine.  I read about configuring it, and am having issues with jasmine on istanbul. I keep gettign back
'c:\HA\VSTS\Applications\HA.Web.Main\spec\support\jasmine.json'

Does this file exist?  I see a reference to it on your docs.  All I see is the file path below.
node_modules >> jasmine >> lib >> examples >> jasmine.json",winnemucca,NONE,2016-03-21 20:57:34+00:00,True,2016-03-22 02:09:43+00:00,0.22,,2,1,2016-03-22 02:09:43+00:00,0.22,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1082,Where can I find automatic unit test generator for JavaScript?,"Hi Guys,
Where can I find automatic unit test generator for JavaScript/Angular2/TypeScript?",wizardnet972,NONE,2016-03-23 21:16:52+00:00,True,2016-03-24 02:59:05+00:00,0.24,,2,1,2016-03-24 02:59:05+00:00,0.24,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1083,Spying on a function referenced from object doesn't work when this function was called indirectly,"var foo = (function() {

    function bar(a) {
        console.log(a);
    }

    function callBarWith(a) {
        bar(a);
    }

    return {
        bar: bar,
        callBarWith: callBarWith
    }
})();

var barSpy = spyOn(foo, 'bar').and.callThrough();
//var barSpy = jasmine.createSpy('bar', foo.bar).and.callThrough();
foo.callBarWith(42);
expect(barSpy).toHaveBeenCalled();
expect(barSpy).toHaveBeenCalledWith(42);
both variants of creating a spy doesn't work for jasmine v2.4.1
both result in:

Expected spy bar to have been called.
Expected spy bar to have been called with [ 42 ] but it was never called.

Though following the console report, bar reference was actually called with '42' and logged the call.
If I replace foo.callBarWith(42) with foo.bar(42), everything works.",shamansir,NONE,2016-03-27 20:26:51+00:00,True,2016-03-29 06:15:42+00:00,1.41,,4,4,2016-03-27 20:48:02+00:00,0.01,shamansir,NONE,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1084,Potential issue on asynchronous test using `done();`,"Hello everyone,
By running the test below, the beforeEach in the inner describe block doesn't wait the done() be called before executing the inners it blocks.
Setting the inner it blocks a setTimeout of 1ms seems to solve the problem, however it doesn't seem to be ideal.
Does anyone have any thoughts about this? Is this really an issue?
describe('some test case..', function () {
    var User;
    beforeEach(function(){
        module(function($provide) {
            $provide.value('User', {
                performSignup: function(callback){
                    callback('123');
                }
            });
        });
    });

    beforeEach(inject(function (_User_) {
        User = _User_;
    }));

    describe('setting local variable this.uid inside the callback', function () {
        beforeEach(function (done) {
            User.performSignup(function(_uid){
                this.uid = _uid;
                done();
            });
        });

        it('should match value returned by callback - FAIL', function() {
            expect(this.uid).toBe('123');
        });

        it('nasty workaround adding a 1 ms timeout - PASS', function(done) {
            setTimeout(function(){
                expect(this.uid).toBe('123');
                done();
            },1);
        });
    });
});


Thanks in advance!",motizuki,NONE,2016-03-28 09:37:53+00:00,True,2016-08-15 17:49:52+00:00,140.34,,2,1,2016-08-15 17:49:52+00:00,140.34,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1085,Documentation for `this`,I started having memory issue and was able to run into one of the issues on github that discussed using this to clean up. I think if the documentation discussed the use of this for cleanup it would be helpful.,tpflueger,NONE,2016-03-28 15:04:06+00:00,True,2016-08-15 17:58:21+00:00,140.12,,2,1,2016-08-15 17:58:21+00:00,140.12,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1086,How do i pass argument when i test a method using and.callFake in jasmine?,"I am not seeing much useful documentation, how can i pass the arguments/parameters when i test an method/function using callFake jasmine functionality?",selvaonline,NONE,2016-03-29 13:09:03+00:00,True,2016-08-15 18:07:39+00:00,139.21,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1087,"Pretty-printing objects from a different frame results in ""[object Object]""","Attempting to pretty-print an object that came from another frame (or any other situation where value.toString !== Object.prototype.toString despite it not actually having a custom toString) results in the normal output of Object.prototype.toString being printed, ""[object Object]"". This seems to be due to the well-intentioned check for whether an object has a custom toString in order to prefer that over the normal pretty printing behaviour. Specifically, it is the value.toString !== Object.prototype.toString portion which causes a false positive.
This could be fixed by speculatively calling value.toString and comparing its output against the normal Object.prototype.toString output. If the output is different, then the value being pretty printed definitely has a custom toString and the output can be used as is.",thatfulvioguy,CONTRIBUTOR,2016-04-01 16:42:09+00:00,True,2016-09-27 18:40:42+00:00,179.08,,1,1,2016-04-08 14:05:59+00:00,6.89,thatfulvioguy,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1089,Adding gulp-jasmine-browser to the top level README,"I'd like to advertise our headless browser and browser versions of jasmine that run specifically for node environments that require browser-like environments.
Would it be ok to reference gulp-jasmine-browser in the top level README for people who might be looking at jasmine as a potential browser test runner in node-like environment setups? I can make the change in a pull request if you like.",rdy,NONE,2016-04-06 14:54:20+00:00,True,2016-08-15 16:31:33+00:00,131.07,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1090,Serialize objects passed to `done.fail` for readability,"When testing a promise based API the done and done.fail methods are a great help to write very efficient test code. Usually I end up with something like the following:
it('tests some async behaviour', function (done) {
  service.method()
    .then(function(result) {
      expect(result).toBe('something');
      done();
    })
    .catch(done.fail);
});
Now if the promise is rejected with an object as error description, the error message in jasmine is only Failed: [object Object]. This does not help in finding the issue at all. Thus in general I would change the .catch method to following:
.catch(function(err) {
  done.fail(JSON.stringify(err));
});
Although this is not a lot of code, it bloats up the test code with repetitive ""housekeeping"" code. In worst/extreme case it might take up most of the test method.
I would love to see a feature, where the done.fail method could print the content of a passed in object in a readable way.
During my research if someone raised this issue already, I stumbled upon the functionality of ""Pretty-printing"". I don't know enough on this feature, but could this maybe be applied to the error parameter?",mmmichl,CONTRIBUTOR,2016-04-07 18:18:18+00:00,True,2017-03-15 00:50:51+00:00,341.27,,3,2,2016-04-24 19:35:20+00:00,17.05,mmmichl,CONTRIBUTOR,1,1,0,0,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
1092,cannot spy on reactjs component functions,"Hey guys,
I cannot spy on my reactjs component member functions.
Here is what I have:
var MyComponent = React.createClass({
  render: function() {
    return <div className=""my-component"">
      <input ref=""nameInput"" />
      <button ref=""btn"" onClick={this.clickHandler}>Click Me</button>
    </div>;
  },
  clickHandler: function(evt) {
    console.log('the value is: ' + this.refs.nameInput.value);
  }
});
ReactDOM.render(<MyComponent />, document.getElementById('container'));

describe('mycomponent', function() {
  var TestUtils = React.addons.TestUtils; 

  // Can't spy on member function!!!!!!
  it('clickHandler gets called when the button is clicked', function() {
    spyOn(MyComponent.prototype, 'clickHandler');
    var testComp = TestUtils.renderIntoDocument(<MyComponent />);
    //spyOn(testComp, 'clickHandler'); //this doesn't work either
    var button = TestUtils.findRenderedDOMComponentWithTag(testComp, 'button');
    TestUtils.Simulate.click(button);
    expect(MyComponent.prototype.clickHandler).toHaveBeenCalled();
    debugger;
  });

});

Can someone please tell what I'm doing incorrectly?
Thanks.",rockneverdies55,NONE,2016-04-11 21:31:39+00:00,True,2016-08-15 17:42:32+00:00,125.84,,2,1,2016-08-15 17:42:32+00:00,125.84,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1093,Spy failed in image onload event,"I am using karma-jasmine and browserify to test Vue component. One method listen on image on load event. But the spy that called in the event handler didn't get the right result. Following snippets shows the error:
let spy = jasmine.createSpy('spy')
spy.and.returnValues({
  name: 'name'
})

describe('example tests', () => {
  it('should pass', (done) => {
    var img = new Image()
    img.onload = function() {
      console.log('2', spy())
      done()
    }
    img.src = ""http://dummyimage.com/100x100""
    console.log('1', spy())
  })
})

here we are, at position 1, the log shows 1, but at position 2, the log shows undefined.
Versions:

jasmine-core 2.4.1
karma 0.13.22
karma-jasmine 0.3.8
karam-browserify 5.0.3",holmescn,NONE,2016-04-16 12:54:03+00:00,True,2016-04-18 00:54:55+00:00,1.5,,2,1,2016-04-18 00:54:55+00:00,1.5,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1094,Angular2 (typescript) + Jasmine: require is not defined,"I have code var fs = require(""fs""); in app.component.ts inside my angular2 project, my app works. But when doing unit test with Jasmine, it comes with an error: require is not defined
Does anyone know how to do with it?",junjunruan,NONE,2016-04-18 14:45:56+00:00,True,2016-04-18 16:47:32+00:00,0.08,,2,1,2016-04-18 16:47:32+00:00,0.08,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1095,Allow reproducing of test order,"Recently I was debugging an intermittently failing test, which only happened when the tests were executed in a particular order (we have random test order enabled to prevent accidental dependencies between tests). However, this was hard to reproduce because Jasmine doesn't have functionality like in RSpec, where they print a seed that you can use to reproduce the same order. See https://relishapp.com/rspec/rspec-core/docs/command-line/randomization-can-be-reproduced-across-test-runs
It would be great to have something like that in Jasmine too!",janpaul123,NONE,2016-04-18 17:37:23+00:00,True,2016-05-09 04:46:54+00:00,20.46,,2,2,2016-04-19 01:57:33+00:00,0.35,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1096,Should {} ==  Object.create(null)? ,"I am testing a map built with Object.create(null), before it was with {}.
Ex:
expect({}).toEqual(Object.create(null))
Error message:
Expected Object({  }) to equal null({  })
This weird message comes from PrettyPrinter L119
The expect:false comes from: matchersUtil L181 because Object.create(null).constructor is undefined.
Should we use // Deep compare objects. for this one ?",dhoko,NONE,2016-04-19 11:40:52+00:00,True,2016-08-19 21:04:47+00:00,122.39,,2,2,2016-04-19 12:21:49+00:00,0.03,dhoko,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1097,Unable to Handle model dialog in two different it().,"Hi,
I've a scenario where clicking on a button will cause alert pop-up. I need to read the text inside the alert (alert.getText() is working) and then accept it(alert.accpet() working also). However, when i split alert.getText() and alert.accept() to two different its() the script is failing with Model dialog present
i Need to alert.getText() and alert.accept() in two different its(). Could some one please let me know if that is possible?
ENV:
Protractor 3.0.0.
IE 9.0
jasmine 2.x
Regards,
Jagadeesh",Kothajagadeesh,NONE,2016-04-19 14:58:28+00:00,True,2016-08-17 20:52:07+00:00,120.25,,2,1,2016-08-17 20:52:07+00:00,120.25,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1100,Custom equality doesn't work with toHaveBeenCalledWith()?,"describe(""custom equality"", function() {
  var eq = function(a,b) {
    return a==b;
  };

  beforeEach(function() {
    jasmine.addCustomEqualityTester(eq);
    spyOn(console, 'log');
  });
  it('should work with toEqual()', function() {
    expect('1').toEqual(1);
  });

  it('should work with toHaveBeenCalledWith()', function() {
    console.log('1');
    expect(console.log).toHaveBeenCalledWith('1');
    expect(console.log).toHaveBeenCalledWith(1);

  });
});

Using jasmine-standalone 2.4.1",awong9,NONE,2016-04-25 19:05:44+00:00,True,2016-09-26 23:41:04+00:00,154.19,,2,1,2016-09-26 23:41:04+00:00,154.19,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1102,Tests Fail When Boot.js is Included,"I have bunch of tests which I was running through Visual Studio but now I am trying to implement the tests such that I can run them through the command line using Karma.  After trying to use Karma, my tests started to fail so I assumed that this was Karma's fault but now I think it might be linked to Jasmine.
I think it is linked to Jasmine because I started only including files I really needed into my karma.config.js file.  I removed jasmine/boot.js and my tests stopped failing.
Let's say I have a test in this format...(as an example)
describe("""", () => {
    console.log(""describe1"");
    beforeEach(() => {
        console.log(""beforeEach"");
    });

    describe("""", () => {
        console.log(""describe2"");
        it("""", () => {
            console.log(""it1"");
        })

        it("""", () => {
            console.log(""it2"");
        })
    });
});

What would happen is my first describe would run, then the second describe and then the beforeEach and then the first it and so on.  The problem was that after my test successfully ran it would run the its again without running the beforeEach and thus the tests would fail.
Example Output of Above Code
describe1
describe2(note that the ""it""s are not executed)
beforeEach
it1
beforeEach
it2(so far so good but now...)
it1(notice how before each didn't run but the ""it""s were reran here and below)
it2",lpolya,NONE,2016-04-27 20:28:21+00:00,True,2016-05-02 15:12:55+00:00,4.78,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1103,Function.prototype.apply.apply does not work with JavaScriptCore on iOS ?,"I figured out that the function ""Function.prototype.apply.apply"" does not work with JavaScriptCore on iOS. I am using only the function ""Function.prototype.apply"" and it is working now.",chreck,NONE,2016-04-28 16:04:35+00:00,True,2018-03-29 00:22:47+00:00,699.35,,2,2,2016-09-27 00:23:41+00:00,151.35,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1104,argsFor not working for nested calls and same data object,"Hello, I've been having an issue with argsFor with a function called twice in a nested manner.
The function takes a params object, a data object and a callback. Inside the callback I call the original function but changing slightly the data object. Then, inside the test, argsFor(0) and argsFor(1) show the same data object (the one of the last call).
I was able to replicate the issue in plunker: http://plnkr.co/edit/5RBrnBhKkutYe1coyg7P
I added a bunch of console.log so you may check that the args are not working as expected.
It's important to mention that the controller works fine, the data object is sent as expected.",mikeiwi,NONE,2016-04-30 17:05:14+00:00,True,2016-09-27 00:46:07+00:00,149.32,,2,1,2016-09-27 00:46:06+00:00,149.32,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1105,strange jasmine.onComplete behaviour,"Strange behavior with onComplete, anytime when I create  more than 18 specs, onComplete does not get called
jasmine.onComplete(function () { istanbul.printCoverage(coverageOpts); });
jasmine.execute(files.src);
for(var i = 0; i < 17; i++) { it('should be defined', function () { expect(User).toBeDefined(); }); }
17 specs, 0 failures
Finished in 0.004 seconds
----------|----------|----------|----------|----------|----------------|
File      |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |
----------|----------|----------|----------|----------|----------------|
model/   |       50 |      100 |       50 |       50 |                |
user.js |       50 |      100 |       50 |       50 |          5,6,7 |
----------|----------|----------|----------|----------|----------------|
All files |       50 |      100 |       50 |       50 |                |
----------|----------|----------|----------|----------|----------------|
if I create 18 specs
for(var i = 0; i < 18; i++) { it('should be defined', function () { expect(User).toBeDefined(); }); }
onComplete function is ignored and result it like this
Started
..................
Done, without errors.",jwnoz,NONE,2016-05-02 09:40:14+00:00,True,2016-05-02 11:25:48+00:00,0.07,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1108,Severe memory leak in core,"While tracking down a memory leak in my Angular + Jasmine + Karma + Chrome test suite (the leak is bad enough that Chrome disconnects by the end of every test run, causing the suite to fail), I tried to write the simplest possible test setup to see if the leak exists there.
What I noticed is when running the same test in a loop (eg. 100,000x), memory usage as measured by top keeps climbing. The Chrome Browser process starts at around 240MB of memory, and climbs linearly to ~450MB until the suite is completed.
It seems like Jasmine is allocating a bunch of objects, and preventing GC from happening.
Repro code is below:
// spec.js:

function test() {
  it('should pass', function() {
    expect(true).toBe(true)
  })
}

describe('test', function() {
  for (var n = 0; n < 100000; n++) {
    test()
  }
})
// karma.conf.js:

module.exports = function (config) {
  config.set({
    frameworks: ['jasmine'],
    files: [
      './spec.js'
    ],
    browsers: ['Chrome']
  })
}
Full repro code is in this repo: https://github.com/bcherny/jasmine-leak-test.
And here is a memory timeline of the original leak, while running ~1500 tests for our production codebase:",bcherny,NONE,2016-05-04 22:02:36+00:00,True,2016-07-13 03:01:29+00:00,69.21,,5,11,2016-05-24 13:02:09+00:00,19.62,timaschew,NONE,1,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1109,Jasmine doesn't seems to recognize Jquery parameter,"I'm trying to make jasmine work with node. I haven't found any useful information about my problem. Maybe the documentation was not clear enough for me. So I decided to ask you guys.
I've configured my jasmine.json like this:
{
  ""spec_dir"": ""assets"",
  ""spec_files"": [
    ""**/*[sS]pec.js""
  ],
  ""helpers"": [
    ""assets/vendors/jquery.min.js"",
    ""js/src/*.js""
  ],
  ""stopSpecOnExpectationFailure"": false,
  ""random"": false
}
Working tree:
codedummies
  assets
    js
      src
        script.js
      spec
        scriptSpec.js
    vendors
      jquery.min.js
  spec
    suport
      jasmine.json

And I got this error:
jQuery is not defined
jQuery is passed as a parameter for my IIF javascript file like this:
...})(jQuery);",wellyal,NONE,2016-05-05 00:27:21+00:00,True,2016-08-15 22:44:07+00:00,102.93,,2,1,2016-08-15 22:44:07+00:00,102.93,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1110,jsApiReporter Documentation,"Hello,
I'm trying to get the test results within Javascript, I've seen that Jasmine provides a jsApiReporter interface but how is it used? I can't find any documentation of a real scenario which handles the test results.
@note
I was able to handle the results using a custom reporter, but I'm a little confused about the jsApiReporter support.
Thanks.",joafalves,NONE,2016-05-05 13:58:08+00:00,True,2016-07-13 03:38:41+00:00,68.57,,2,1,2016-07-13 03:38:41+00:00,68.57,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1111,Unable to fail test if expect fails,"Hi,
While using Jasmine 1.3, I was able to stop execution using ""fail()"" function long back but unable to do the same nowadays(since I'm getting error-

Referecne error: fail()

). So, upgraded to Jasmine 2.4 only to overcome this but I'm unable to abort test ('it' block) if any expect fails even in jasmine 2.4.
Can anyone please guide me in aborting a test if any expect fails in jasmine 2.4
Thanks in advance.",bharathp,NONE,2016-05-10 10:55:35+00:00,True,2016-09-24 00:48:54+00:00,136.58,,2,1,2016-09-24 00:48:54+00:00,136.58,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1112,Unable to get spec description and test description,"Hi,
I'm in need of getting my spec description in ""onPrepare"" block in order to replicate them in my own customized html report and appending 'it' block's title to my screenshot.png file name.
Able to get the spec name only when control gets into 'it' block, but not before or after that.
I've stuck here from many days and been trying in multiple ways as mentioned in many blogs but couldn't achieve this.
I think this feature is most important for anyone to access their own test names. Could you please provide any possible solution to achieve this.
Thanks  in advance.",bharathp,NONE,2016-05-10 11:06:09+00:00,True,2016-09-27 00:39:05+00:00,139.56,,2,1,2016-09-27 00:39:05+00:00,139.56,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1113,Jasmine throws an exception when test case finishes and a call to done() is made.,"At the end of my test, jasmine throws an exception and does not proceed to the next test case. Everything in the test function executes okay until when jasmine calls the done function.
at emitOne (events.js:77:13)
    at process.emit (events.js:169:7)
    at process.exit (node.js:750:17)
    at Jasmine.module.exports [as exit] (/usr/local/lib/node_modules/jasmine/lib/exit.js:6:5)
    at /usr/local/lib/node_modules/jasmine/lib/jasmine.js:160:23
    at jasmineDone (/usr/local/lib/node_modules/jasmine/lib/reporters/exit_code_reporter.js:10:5)
    at dispatch (/usr/local/lib/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1966:28)
    at ReportDispatcher.jasmineDone (/usr/local/lib/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1949:11)",mjilugu,NONE,2016-05-10 11:57:50+00:00,True,2017-07-31 21:21:26+00:00,447.39,,4,4,2016-11-18 19:31:52+00:00,192.32,slackersoft,MEMBER,1,0,0,1,['npm'],False,False,False,False,False,True,False,False,False,False,False,False,False,False,False
1115,Testing set/get,"Testing the following snippet
save(data, successMessage) {
    chrome.storage.local.set(data, (error) => {
      if (error) {
        this.status('Error Occurred. Please refresh.', 1000, 100, 'danger');
      } else {
        this.status(successMessage, 1000, 100, 'success');
      }
    });
  }
}
On calling save(data, message), it should call chrome.storage.local.set(...). The spyOn function returns the following error:
Error: set is not declared writable or has no setter in /path/to/jasmine (line 2008)",ankit-m,NONE,2016-05-15 17:04:32+00:00,True,2016-05-16 18:41:05+00:00,1.07,,3,5,2016-05-16 15:35:46+00:00,0.94,jaapz,NONE,0,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1116,API Document PLEASE!,"I really hate tools without api doc, It's too hard to use!
if I must look out method from source code??",qx,NONE,2016-05-16 08:44:51+00:00,True,2016-10-15 00:44:22+00:00,151.67,,5,6,2016-05-25 02:41:56+00:00,8.75,glebec,NONE,0,1,0,4,['docs'],False,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1117,Feature request for spyOn - pass method directly instead of using string constant for identification,"If I spy on a method with
spyOn(parent, 'methodToSpyOn')
and the name of the method changes during refactoring, I have to manually
adapt the string argument.
Therefore I suggest to include a method like
spyOnMethod(self, self.methodToSpyOn);
that does not use a string constant for the identification but retrieves the method directly.
When changing the method name during refactoring, my IDE will be able to adapt the argument automatically.
A method with only one argument would be even better, but I guess
this is not possible since the parent needs to be known:
spyOnMethod(self.methodToSpyOn);
Here is a first draft for an implementation:
function spyOnMethod(parent, methodToSpyOn) {
  var methodName = getMethodName(); 
  return spyOn(parent, methodName);

  function getMethodName() {
    var foundAttributeName = null;
    var attributeNames = Object.keys(parent);
    _.forEach(attributeNames, function (name) {
      var attribute = parent[name];
      if (attribute === methodToSpyOn) {
        foundAttributeName= name;
      }
    });
    return foundAttributeName;
  }
}",stefaneidelloth,NONE,2016-05-18 10:17:20+00:00,True,2016-10-15 00:29:51+00:00,149.59,,3,3,2016-05-25 02:47:19+00:00,6.69,glebec,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1118,"works via CLI but not through HTML, 404 not found","This is a project written by Typescript, I use jasmine to do some unit testing. Now it can work via the command line, but doesn't work with the fancy html page. It said 404, how to solve it?
This is my UnitTest.html, it is in the root of the project.
<!DOCTYPE html>
<html>

<head>
    <meta http-equiv=""content-type"" content=""text/html;charset=utf-8"">
    <title>My App Unit Tests</title>
    <link rel=""stylesheet"" href=""node_modules/jasmine-core/lib/jasmine-core/jasmine.css"">
    <script src=""node_modules/jasmine-core/lib/jasmine-core/jasmine.js""></script>
    <script src=""node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js""></script>
    <script src=""node_modules/jasmine-core/lib/jasmine-core/boot.js""></script>
</head>

<body>
    <script src=""node_modules/systemjs/dist/system.src.js""></script>
    <script src=""node_modules/typescript/lib/typescript.js""></script>
    <script>
        System.config({
            transpiler: 'typescript'     
        });
        System.import('./spec/UnitTest.spec.ts')
            .then(window.onload)
            .catch(console.error.bind(console));
    </script>
</body>

</html>

This is the jasmine.json
{
  ""spec_dir"": ""spec"",
  ""spec_files"": [
    ""**/*[sS]pec.js""
  ],
  ""helpers"": [
    ""helpers/**/*.js""
  ],
  ""stopSpecOnExpectationFailure"": false,
  ""random"": false
}

This is the actural test file, in the ""spec"" folder, the folder is the just under the root.
import { FindViewModel } from '../Application/TS/ViewModels/FindViewModel';
import { ISpeechService } from '../Emulator/TS/Services/ISpeechService';


describe('Tests for the FindViewModel', () => {
  it('getKeyword() should return a string', () => {
    let returnValue: string = (new FindViewModel()).getKeyword();
    expect(returnValue).toEqual(jasmine.any(String));
  });

  it('getKeywordByVoice() should return a string', () => {
    let checkThisValue:string;
    class mockSpeech implements ISpeechService{
        recognize():string{
            return checkThisValue;
        }
    }

    let testFindViewModel = new FindViewModel();
    let findKeywordByVoice = testFindViewModel.getKeywordByVoice(new mockSpeech());
    expect(findKeywordByVoice).toEqual(checkThisValue);
  });
});

After compile the Typescript, It can run smoothly via cli, I can comfirm, because when I try to screw the test, it throws exception.

But it won't run via browser, The error from the browser is just as following, seems can't find the File that imports from the unittest.spec.ts?


This is my structure of the project.

How to solve it?",Albert-Gao,NONE,2016-05-18 13:15:24+00:00,True,2016-11-18 20:17:56+00:00,184.29,,3,1,2016-11-18 20:17:56+00:00,184.29,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1119,Passing undefined/null to beforeEach() causes tests to be silently skipped.,"Passing undefined or null to beforeEach() causes the tests in the given spec file to be silently skipped, without any error. Here's an example showcasing the problem in Jasmine 2.4.1: http://codepen.io/anon/pen/EKzqVe
The issue seems to occur on this line - queueableFn.fn ends up being undefined, so the attempt at accessing .length throws an error which is somehow swallowed (you can see the issue using the ""Pause On Caught Exceptions"" feature of Chrome's Devtools).",voithos,CONTRIBUTOR,2016-05-18 17:55:50+00:00,True,2016-10-15 00:33:05+00:00,149.28,,3,1,2016-10-15 00:33:05+00:00,149.28,slackersoft,MEMBER,1,0,0,0,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
1120,`random: true` in config json doesn't appear to work,"I just started using jasmine and am used to having specs randomized in other languages. I'd prefer not to have to type --random=true to have this. Here is my config file:
{
  ""spec_dir"": ""spec"",
  ""spec_files"": [
    ""**/*[sS]pec.js""
  ],
  ""helpers"": [
    ""helpers/**/*.js""
  ],
  ""stopSpecOnExpectationFailure"": true,
  ""random"": true
}
Here is my jasmine version output:
$ jasmine version
jasmine v2.4.1
jasmine-core v2.4.1

Here is what JASMINE_CONFIG_PATH is set to:
$ echo $JASMINE_CONFIG_PATH
spec/config/jasmine.json

And here is where my config file is located:
$ find spec | grep json
spec/config/jasmine.json

I also tried putting the config where jasmine init placed it under spec/support/jasmine.json and setting the environment variable but no go. I'm running jasmine in a loop forever and it doesn't hit a failure I wrote that depends on the ordering of tests. When I run jasmine --random=true it shows up 50% of the time as expected. Not sure what I'm missing here.",jasonkeene,NONE,2016-05-21 23:51:51+00:00,True,2016-09-28 18:00:26+00:00,129.76,,4,3,2016-09-22 12:19:03+00:00,123.52,zack,NONE,1,0,0,2,['npm'],False,False,False,False,False,True,False,False,False,False,False,False,False,False,False
1121,Equality of different array iterators succeeds,"The following spec runs without failures:
""use strict"";
describe(""test"", function () {
    it(""compare arrays"", function () {
        let a = [1, 2];
        let b = [3, 4];
        expect(a.entries()).toEqual(b.entries());
    });
});
Should it not fail?",vkliatchko,NONE,2016-05-22 23:59:55+00:00,True,2017-03-11 21:01:56+00:00,292.88,,5,7,2016-09-13 02:40:55+00:00,113.11,chrisdeely,NONE,1,1,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1122,Accessibility of CSS styling on documentation pages,"Please consider changing the background color of the code samples in the documentation, they are hard to read, as the the background and some of the foreground colors lack enough contrast. I can still read it, but it's just requires way more concentration, and I can well imagine that people with visual impairment will inevitably have problems with it.",imrek,NONE,2016-05-23 06:10:10+00:00,True,2017-06-23 05:52:20+00:00,395.99,,4,2,2017-02-16 19:58:07+00:00,269.57,slackersoft,MEMBER,2,0,0,0,['docs'],False,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1123,Allow custom matchers to customize the error message,"Issue:
Large output messages returned by custom matchers are difficult to read.
Behavior:
Expectation.prototype.wrapCompare() only passes along the custom matcher's message, so buildExpectationResult has to construct a new error, which duplicates the message.

Having a really long line in the message breaks the HTMLReporter layout.

Expected behavior:
Expectation.prototype.wrapCompare() allows custom matchers to return an error object in its results and passes it to buildExpectationResult which will specify a custom error message.
jasmine.addMatchers({
  exampleMatcher: function() {
    return {
      compare: function(actual, expected) {
        ...
        return {
          pass: pass,
          message: message,
          error: new Error (message + '\n\n' + details)
        };
      }
    };
  }
});

The HTMLReporter layout should specify .jasmine-result-message { overflow-x: scroll; } to prevent horizontal overflow out of the document body (although it is less of an issue when the extended details are moved to the error).",deckar01,NONE,2016-05-26 18:00:41+00:00,True,2017-04-10 20:52:19+00:00,319.12,,2,4,2016-06-01 00:18:22+00:00,5.26,deckar01,NONE,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1124,Possibility to run external script before/after,"Hello,
I would like to know if there is there the possibility to run an external script file before/after jasmine runs all tests written?
e.g run a bat file to execute some task automatically when in Visual studio jasmine starts and just before it starts to run effectively the tests.
It is possible to capture the moment it start/end to run all tests?

Thanks for help",jean-fr,NONE,2016-05-31 16:35:09+00:00,True,2016-06-05 19:38:25+00:00,5.13,,2,2,2016-06-03 08:23:45+00:00,2.66,adityaparab,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1126,Help with testing javascript Closure in jasmine,"I am completely novice at using jasmine. I couldn't figure out how can I write a test case for a java script closure like below.
My code in Typescript is as follows
module FIRST.Mobile.Controllers{
""use strict"";
class sampletest
{
public  subtract(a: number, b: number): number {
    return a - b;
}
}
}

And when converted to JavaScript it becomes
var FIRST;
(function (FIRST) {
    var Mobile;
    (function (Mobile) {
        var Controllers;
        (function (Controllers) {
            ""use strict"";
            var sampletest = (function () {
                function sampletest() {
                }
                sampletest.prototype.subtract = function (a, b) {
                    return a - b;
                };
                return sampletest;
            })();
        })(Controllers = Mobile.Controllers || (Mobile.Controllers = {}));
    })(Mobile = FIRST.Mobile || (FIRST.Mobile = {}));
})(FIRST || (FIRST = {}));

I do not understand if I could test code in a typescript module?
If yes can some one explain me how could I test the subtract method using jasmine.
Thank you",ramavaxa,NONE,2016-06-02 05:04:12+00:00,True,2016-06-10 15:42:55+00:00,8.44,,2,1,2016-06-10 15:42:55+00:00,8.44,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1127,Custom messages for passed expectations,"Hi,
There are various places where it makes sense to have a custom message for passed test cases.
This is not an ""issue"" as such and the jasmine framework is doing a pretty good job for what it is intended.
However, I have faced many situations where if I write of own report generator, It is impossible to add an explanatory message for all the expectations. It makes HTML/Excel reports much readable,
There is a condition in the buildExpectationResult function in ExpectationResult.js
    function message() {
      if (options.passed) {
        return 'Passed.';
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return '';
    }

if this the option.passed condition evaluates true, it overrides my custom message with a string ""Passed.""
Do you think changing this condition to
if (options.passed && !options.message) {
would make it more useful?
I have tested in on my local setup and everything seems to work as expected.
If I set custom message for expectations (using functions like since() ) then the passed and failed test cases use that message. If I don't pass any custom message, it returns passed.
Following this approach, I was expecting the framework to return something like, for example, Expected true to be true but it seems to be working perfectly fine.
I believe this would be a great value add to the framework.

Use case where it comes handly
    var tc1 = it('Should navigate to SomePage', function () {
        tc1.result.tcName = ""TC1"";
        tc1.result.tcDesc = ""Verify create button is present"";
        tc1.result.expectations = [];
        since('Verify create button is present') // This is how the message is passed.
        .expect(SomePage.CreateButton.isPresent()).toBe(true);
    });

This generates the output as
""passedExpectations"": [{
    ""matcherName"": ""toBe"",
    ""message"": ""Verify create button is present"",
    ""stack"": """",
    ""passed"": true
}]

Pretty handy, isn't it?
Now, If I don't have ability to add custom message, I have to build my own expecation results again by writing each each expecation twice. (2nd time for my own result generation) like
    var tc1 = it('Should navigate to SomePage', function () {
        tc1.result.tcName = ""TC1"";
        tc1.result.tcDesc = ""Verify create button is present"";
        tc1.result.expectations = [];
        expect(SomePage.CreateButton.isPresent()).toBe(true); // This will build the native jasmine results object
        SomePage.CreateButton.isPresent().then(function(isPresent){ // now I have to manually build my own result object
            tc1.result.expectations.push({
                title: 'Verify create button is present',
                status: isPresent ? 'Passed' : 'Failed'
            })
        });
    });

As you can see, this makes the test cases look dirty. And the logic gets scattered all over the place.
It would be great, if all the results logic is at one place and is handled by the framework itself. :)",adityaparab,NONE,2016-06-03 07:57:05+00:00,True,2016-10-17 19:11:40+00:00,136.47,,5,3,2016-07-01 11:43:16+00:00,28.16,t2n,NONE,1,0,0,2,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1128,waitsFor like imlemenation in jasmine 2.4,"I need to wait for specified amount of time before second request(comment in code). How can i implement this one using jasmine 2.4?
it('It will fail for expiration of token', done => {
    const fakeUser = {
          ""grant_type"" : ""password"",
          ""client_id"" : ""abc123"",
          ""client_secret"" : ""ssh-secret"",
          ""username"": ""bob"",
          ""password"": ""secret""
        };
        request({
          url: routeFor('oauth/token'),
          method: 'POST',
          body: fakeUser,
          json: true
        }, (error, response, token) => {     

        let aheader = {};
        aheader.Authorization = 'Bearer '+ token.access_token;

       // Waitfor specified amount of time

        request({
           url: routeFor('test'),
           method: 'GET',
           headers: aheader,
           json: true
         }, (error, response, body) => {
          console.log(body);
         expect(body.error).toEqual(""token expired"");    
         done();
         });
      });
    });",lutfor3737,NONE,2016-06-06 18:08:41+00:00,True,2016-06-10 15:35:10+00:00,3.89,,2,1,2016-06-06 20:48:23+00:00,0.11,lutfor3737,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1130,Dynamically Loading Javascript files in test file.,"Hi
Currently working on getting our testing setup for a jQuery plugin.
In our test cases we need to be able to load different javascript files on the same test.
We're using fixtures to load html files but gotten stuck on how to include an external javascript file into a test.
Is there any built in way to do this in Jasmine, if not could anyone suggest how I could go about it?
Thanks for your help.",,NONE,2016-06-09 10:43:44+00:00,True,2016-06-10 15:39:32+00:00,1.21,,2,1,2016-06-10 07:44:44+00:00,0.88,jaapz,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1131,How to test spy in setTimeout?,"I have code like this:
it('should call json-rpc', function() {
    var spy = spyOn(object, 'echo');
    if (spy.andCallThrough) {
        spy.andCallThrough();
    } else {
        spy.and.callThrough();
    }
    enter(term, 'echo foo bar');
    setTimeout(function() {
        // here I've got error Expected a spy, but got Function.
        expect(object.echo).toHaveBeenCalledWith('foo', 'bar');
    }, 200);
});
and I've got error: Expected a spy, but got Function. how to test spy in setTimeout?",jcubic,NONE,2016-06-13 18:10:52+00:00,True,2016-06-14 14:48:50+00:00,0.86,,2,2,2016-06-14 14:48:50+00:00,0.86,jcubic,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1132,Add a way to specify custom reason for disabled suites,Currently we can provide custom reason for pending specs using pend(). How do we do the same for suites where we disable it using xdescribe? See http://stackoverflow.com/questions/37791690/any-way-to-provide-reason-to-a-disabled-suite-in-jasmine for more details. Thanks!,grushler,NONE,2016-06-14 07:07:01+00:00,True,2016-12-02 18:12:43+00:00,171.46,,3,2,2016-09-17 00:24:00+00:00,94.72,Gerg,CONTRIBUTOR,1,1,0,0,['feature request'],False,True,False,False,False,False,False,False,False,False,False,False,False,False,False
1133,"Help with ""extending"" the BDD interface","Hi there
I need some help to extend the default Jasmine interface (describe, before, etc) to add my own methods to it.
Instead of doing something like
describe('Module', function() {
  it('should assert true', function() {
  ))
})

I would like to do something like
NewInterface('Module', function () {
  check('title', function, function() {
  })
})

I'm having a hard time trying to put the pieces together. I know about the jasmine-npm project and understand (ish) the boot file but it feels excessive to have to write a new boot file to expose more methods in the interface.
I've also read about the guidelines to ""not change the interface"" which is fine, but wondering, in this case I would like to have people using the new interface with Jasmine under the hood.
Is there any other way? Like using a configuration file like the matchers or something?
Thanks for your help",tarciosaraiva,NONE,2016-06-15 09:53:49+00:00,True,2016-09-17 00:14:39+00:00,93.6,,2,1,2016-09-17 00:14:39+00:00,93.6,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1134,Timeline issues when testing with multiple setTimeout on a timeline ,"I am trying to test an idleTimeout library that includes a function to reset a timeout when a DOM event fires.
My issue is that the timeout's timeline, mocked by Jasmine, does not seem to be linear.
My test
  it('should reset the idleTimeout if one of the event handlers get\s called', () => {
            jasmine.clock().install();
            let callback = jasmine.createSpy('timerCallback');
            let IL = new InactivityLogout({idleTimeoutTime: 2000, timeoutCallback: callback});
            console.log('new InactivityLogout created');
            jasmine.clock().tick(1001); // 1001ms total time
            console.log('jasmine.clock().tick(1001)');
            expect(callback).not.toHaveBeenCalled();

            // initial timer 1 will be destoryed and new timer initialise 
            // with set idleTimeoutTime(2000)
            dispatchMouseEvent('click'); 

            jasmine.clock().tick(1000); // 2001 total time

            // new timer 2 is only 1000 into it's own timeline 
            // should not be called until 3001 because it was reset at 1001
            expect(callback).not.toHaveBeenCalled();  <- FAILS

            jasmine.clock().tick(2000); // 4001
            expect(callback).toHaveBeenCalled();
            jasmine.clock().uninstall();
  })
I expected that when calling jasmine.clock().tick(somenum) the current time in the jasmine scheduler would be updated, but that does not seem to happen.
Both the first callback and the second callback created get initialized with a current time of 0. And I don't fully understand why?
DelayedFunctionScheduler.js
getJasmineRequireObj().DelayedFunctionScheduler = function() {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;
    console.log('delayedfunctionscheduler init current time set', currentTime)


    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
      currentTime = endTime;
      console.log('delayedfunctionscheduler init current time set', currentTime)
    };

    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {
      var f;
      if (typeof(funcToCall) === 'string') {
        /* jshint evil: true */
        f = function() { return eval(funcToCall); };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || (currentTime + millis);

      console.log('schedule function timeoutkey', timeoutKey)
      console.log('schedule function currentTime', currentTime)
      console.log('schedule function run at millis', runAtMillis)

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function (a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };
Console logging to illustrate timeline
**** : code run in the idleTimeout library not shown
delayedfunctionscheduler init current time set 0
**** start timer timeout time 2000
schedule function timeoutkey 1
schedule function currentTime 0
schedule function run at millis 2000
**** start timer idleTimeoutID 1
**** clear timeout for id 1
**** start timer timeout time 2000
schedule function timeoutkey 2
schedule function currentTime 0
schedule function run at millis 2000
**** start timer idleTimeoutID 2
new InactivityLogout created
delayedfunctionscheduler self.tick current time set 1001
jasmine.clock().tick(1001)
**** timeout called
delayedfunctionscheduler self.tick current time set 2001
jasmine.clock().tick(2001)
delayedfunctionscheduler self.tick current time set 4001
jasmine.clock().tick(4001)
As you can see the order of logging is strange.
Ideally I feel like I my test case should work with Jasmine? Maybe I am just missing something super simple? Any help would be appreciated, hopefully this issue may help others. Happy to help out with a fix if you can help me understand what is wrong.
The test does work if it's for a simple case of the timer firing or not firing, depending on the callback time.
Simple test example that does work.
    it('should timeout when the idleTimeout is finished', () => {
        jasmine.clock().install();

        let callback = jasmine.createSpy('timerCallback');
        let IL = new InactivityLogout({idleTimeoutTime: 2000, timeoutCallback: callback});
        expect(callback).not.toHaveBeenCalled();
        jasmine.clock().tick(2001);
        expect(callback).toHaveBeenCalled();

        jasmine.clock().uninstall();
    });",vespertilian,NONE,2016-06-16 22:28:57+00:00,True,2016-06-17 09:11:12+00:00,0.45,,1,1,2016-06-17 09:21:51+00:00,0.45,vespertilian,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1135,Inherit parent context in beforeAll,"I have a test suite organized like this:
describe('Something', function() {
  beforeEach(function() {
    this.something = new Something();
  });
  describe('Suite 1', function() {
    beforeAll(function() {
      this.something.setSomething();
    });
    ... // a series of tests
  });
  describe('Suite 2', function() {
     beforeAll(function() {
      this.something.setSomethingElse();
     });
     ... // a series of tests
  });
});

I assume the something I created in beforeEach can be seen in the beforeAll child scope. However, this is not the behavior currently jasmine implemented (2.4.1).
I don't understand why this behavior is not supported. If not passing the parent context setup by beforeEach to beforeAll is the intended behavior, it would be nice to know why.",chaoran,NONE,2016-06-19 00:22:23+00:00,True,2016-07-19 06:47:34+00:00,30.27,,2,1,2016-06-19 00:32:14+00:00,0.01,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1136,TypeScript source and testing,"I have a JS app with Jasmine tests, but now I'm in the process of rewriting the entire app in TypeScript. I'd also like to rewrite the tests in TypeScript. Any suggestion on how to test with Jasmine then? Currently I'm transpiling all to JS and testing in a temporary build, but I hope to find a more straightforward way.",heruan,NONE,2016-06-22 13:34:02+00:00,True,2016-06-27 14:42:25+00:00,5.05,,2,2,2016-06-27 10:25:28+00:00,4.87,ValeriiVasin,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1138,Custom equality testers are ignored by asymmetric matchers,"At the very least, custom equality testers should be supported within objectContaining() and arrayContaining().  It is surprising to register a custom tester and have it ignored in certain contexts.",joeyparrish,CONTRIBUTOR,2016-06-23 20:55:02+00:00,True,2016-09-27 18:04:12+00:00,95.88,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1140,No Nested It?,"Hi, I am doing a front-end automation using protractor and jasmine. My test scenarios heavily reliant with the front end as such my specs are dynamic and loop dependent. Example of what I am doing: in the page there is this called template ( template for a survey ). It is divided into groups and each groups contains questionnaires ( can be multiple-choice, rubric type, or open-ended ). My test involves creating a template, which includes creating the groups and the questionnaires to create a whole template. Then I need to check if the front-end actually displays what I created. I have no problem with creating but my problem is the checking. I am not allowed to do the checking the same time as creating, they must be separate as after creating I need to save it first before I can do the checking. Since, I need to check the questionnaires and groups, I need to loop a lot. So first I need to loop the groups and then loop the questionnaires in each group and then check its question text and question options. So my first it block is to loop the groups it looks like this:
it( 'Should loop groups', function () {
groupPage.getGroups().map( function ( groupEl, groupIndex ) {
        if ( groupIndex > 0 ) {
            groupPage.clickGroup( groupIndex );
        }
                it( 'Should verify group title for group: ' + groupIndex, function () {
                        expect( groupPage.getGroupName() ).toEqual( 'Group Name' );
                }  );
    } );
} );

However the questionnaires are within the groups, so within the loop group it block, I need to write it blocks for the questionnaires and assert the question texts and option texts. In order to do that, I need to nest the questionnaires it inside the group it. It should look like this.
it( 'Should verify group titles', function () {
    groupPage.getGroups().map( function ( group, groupIndex ) {
        if ( groupIndex > 0 ) {
            groupPage.clickGroup( groupIndex );
        }
                it( 'Should verify group title for group: ' + groupIndex, function () {
                        expect( groupPage.getGroupName() ).toEqual( 'Group Name' );
                }  );
                questionPage.getQuestions().map( function ( question, questionIndex ) {
                        verifyQuestionText( questionIndex );
                } );
    } );
} );


function verifyQuestionText( questionIndex ) {
       it( 'Should verify question text: '  + questionIndex, function () {
              expect( questionPage.getQuestionText() ).toEqual( 'Question Text' );
       } );
}

But this doesn't work. It won't execute the nested it blocks. Any advice?",kariasbolster,NONE,2016-06-27 10:01:39+00:00,True,2016-07-19 06:42:26+00:00,21.86,,4,3,2016-07-07 15:48:52+00:00,10.24,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1141,Can't set jasmine.DEFAULT_TIMEOUT_INTERVAL to a value bigger then 10000,"I am using Jasmine 2.4.1 :
I can change jasmine.DEFAULT_TIMEOUT_INTERVAL to value less than 10000 ms, but
when I try to change the jasmine.DEFAULT_TIMEOUT_INTERVAL to a value bigger then 10000 ms
then the timeout still fires at 10000 ms.
Is that a bug or a feature ?",udiedrichsen,NONE,2016-06-28 07:24:29+00:00,True,2016-07-01 08:32:22+00:00,3.05,,1,1,2016-07-01 08:32:22+00:00,3.05,udiedrichsen,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1144,Can you update npm?,"jasmine-core v2.4.1 on npm is not the same with github, it's painful.
/lib/jasmine-core/jasmine.js/ on npm:
line 26:    if (typeof module !== 'undefined' && module.exports) {

/lib/jasmine-core/jasmine.js/ on github:
line 26:  if (typeof module !== 'undefined' && module.exports && typeof exports !== 'undefined') {",yeluoqiuzhi,NONE,2016-07-01 03:11:24+00:00,True,2016-09-17 00:07:39+00:00,77.87,,3,2,2016-07-13 22:48:54+00:00,12.82,amavisca,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1145,Asynchronous beforeEach / beforeAll,"Jasmine's it is able to handle async. However beforeEach, beforeAll, and describe do not seem to handle async functions properly. Sometimes test setup is asynchronous. Suggestions?",tonyxiao,NONE,2016-07-07 06:36:36+00:00,True,2016-07-08 15:41:20+00:00,1.38,,2,5,2016-07-07 15:40:56+00:00,0.38,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1146,Is this project active?,"I don't see any activity since March 2016, which is surprising for a number of reasons.
I hate to be that guy.   But I have to ask!
Seth",sethcall,NONE,2016-07-11 16:03:37+00:00,True,2016-07-13 03:19:30+00:00,1.47,,2,1,2016-07-13 03:19:30+00:00,1.47,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1147,jasmine.js:2219 Uncaught TypeError: this.expectationResultFactory is not a function,"Version 2.4.1 fails on one specific test I have.
The error is:
jasmine.js:2219 Uncaught TypeError: this.expectationResultFactory is not a function
Suite.onException @ jasmine.js:2219
onException @ jasmine.js:2330
onException @ jasmine.js:1924
handleException @ jasmine.js:1928
attemptAsync @ jasmine.js:1918
QueueRunner.run @ jasmine.js:1871
(anonymous function) @ jasmine.js:1898
(anonymous function) @ jasmine.js:1842
onComplete @ jasmine.js:2467


After upgrading jasmine to the latest version (commit f6da084  on Mar 27), original error gone, but now I get a new one:
jasmine.js:1921 Uncaught TypeError: Cannot read property 'length' of undefined
QueueRunner.run @   jasmine.js:1921
QueueRunner.execute @   jasmine.js:1910
queueRunnerFactory  @   jasmine.js:706
Spec.execute    @   jasmine.js:362
fn  @   jasmine.js:2558
attemptAsync    @   jasmine.js:1967
QueueRunner.run @   jasmine.js:1922
(anonymous function)    @   jasmine.js:1949
...

The main problem I see is with error handling by jasmine - when this error happens jasmine doesn't reports failure to Karma but stops running other tests, making karma and CI think that all tests are passed:
Chrome 51.0.2704 (Windows 10 0.0.0): Executed 49 of 190 SUCCESS (0.149 secs / 0.074 secs)",yrtimiD,NONE,2016-07-12 20:11:06+00:00,True,2016-12-02 18:37:56+00:00,142.94,,5,6,2016-07-12 20:26:46+00:00,0.01,yrtimiD,NONE,1,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1148,Please update Glob dependency (minimatch@0.3.0 deprecated),"Hi,
I get the following warning during my test environment install:
npm WARN deprecated minimatch@0.3.0: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue

as far as I see this comes from jasmine@2.4.1 dependency for glob@3.2.11 (here ""minimatch"": ""0.3"" is defined as dependency). So the install shows:
+-- jasmine-reporters@2.2.0 
| +-- jasmine@2.4.1 
| | +-- exit@0.1.2 
| | +-- glob@3.2.11 
| | | `-- minimatch@0.3.0 
| | |   +-- lru-cache@2.7.3 
| | |   `-- sigmund@1.0.1 
| | `-- jasmine-core@2.4.1 
| +-- mkdirp@0.5.1 
| | `-- minimist@0.0.8 
| `-- xmldom@0.1.22 

Could you help me out to resolve this issue. Maybe just a Glob update is needed for Jasmine.",aszegedi,NONE,2016-07-13 12:47:56+00:00,True,2016-09-02 04:17:56+00:00,50.65,,4,4,2016-07-13 22:51:50+00:00,0.42,amavisca,MEMBER,2,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1149,How can I call a spy upon a function being exported through a module,"I'm not very good at explaining so I'll do my best. I'm working with nodejs project.
I have a controller that has the following code inside of it:
// controller.js
exports.bar = (request, reply) => {
  // Do some processing
  return foo('val1','val2','val3')
}

function foo(arg1,arg2,arg3){
/// do something
}

exports.foo = foo;
So what I'm trying to do is test that foo has been called. I used the following code
controller = require('controller.js')
beforeEach(() => {
  spyOn(controller, 'foo').and.callFake((args, action) => {
    // return something
  });
})

it('testing foo function', (done) => {
   server.inject(opts, cb)
   function cb(res){
     expect(controller.foo).toHaveBeenCalled();
   }
})
I get an error with the test that says ""spy foo to have been called""
I also tried using spyOn(controller.prototype, 'foo') ando got the following error ""spyOn could not find an object to spy upon for foo()""
Any help with this is greatly appreciated, Thanks",jrcastillo,NONE,2016-07-13 17:45:19+00:00,True,2016-09-12 13:57:46+00:00,60.84,,3,3,2016-07-14 15:32:39+00:00,0.91,jrcastillo,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1153,NodeJS: Promise.then() doesn't get called during test?,"Im returning a promise from a module for an async file read function. The .then method in the promise doesnt get executed. Is this a known bug?
Source code is here",ShashankaNataraj,NONE,2016-07-15 14:16:29+00:00,True,2016-07-15 15:17:40+00:00,0.04,,2,1,2016-07-15 15:17:40+00:00,0.04,amavisca,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1154,Memory Leaks in Jasmine,"So I'm working on a large angular project with a large number of tests, 2539 as of writing this. In my tests, I'm using angular mock to inject angular variables into my tests in a beforeEach() and then saving them in a scoped variable for my tests to use. The problem I'm having is that jasmine maintains various references to the it(), describe(), beforeEach(), afterEach() functions inside it's suite object (https://github.com/jasmine/jasmine/blob/master/lib/jasmine-core/jasmine.js#L2186-L2192) which prevent any garbage collection from occurring of these scoped variables, so currently the memory footprint just spikes up to 2+ gigs of memory when we finally reach some internal limit of the browser's memory footprint and we get a browser disconnect.
My current solution is to have an afterEach() in each test file where it clears out these scoped variables, but it would be great if jasmine released it's references to the tests after they were run.",fracmak,NONE,2016-07-18 16:46:42+00:00,True,2016-11-04 17:23:09+00:00,109.03,,6,9,2016-07-18 22:33:20+00:00,0.24,amavisca,MEMBER,2,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1156,"""TypeError: this.expectationResultFactory is not a function"" unable to force specs","I'm currently unable to force specs without receiving the error TypeError: this.expectationResultFactory is not a function. I'm running protractor e2e tests using Jasmine 2.3.4.
Here is a stack trace:
/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2219
      this.result.failedExpectations.push(this.expectationResultFactory(data);
Suite.onException /node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2219:48
at QueueRunner.queueRunnerFactory.onException /node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2330:28
at onException /jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1924:12
at [object Object]._onTimeout /jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1910:11
at Timer.listOnTimeout (timers.js:92:15) /jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1910:11

Please let me know what info would be helpful. Note that I do not have a beforeEach in an it block, as described in issue #1147.",seanhelvey,NONE,2016-07-19 17:43:50+00:00,True,2016-12-02 18:37:53+00:00,136.04,,2,1,2016-09-07 23:05:59+00:00,50.22,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1160,`grunt execSpecsInNode` does not print spec failures,"When I run grunt execSpecsInNode in the presence of failing tests, I get this output:
Running ""execSpecsInNode"" task
Warning: Task ""execSpecsInNode"" failed. Use --force to continue.

Aborted due to warnings.

I'm pretty sure this task used to output the actual failure messages. Is it just me? I'm on Mac OS 10.11.5, Node v6.3.0, latest master of Jasmine. Below is the output from npm ls.
jasmine-core@2.4.1 /Users/pivotal/workspace/jasmine
├─┬ glob@5.0.15
│ ├─┬ inflight@1.0.5
│ │ └── wrappy@1.0.2
│ ├── inherits@2.0.1
│ ├─┬ minimatch@3.0.2
│ │ └─┬ brace-expansion@1.1.5
│ │   ├── balanced-match@0.4.2
│ │   └── concat-map@0.0.1
│ ├── once@1.3.3
│ └── path-is-absolute@1.0.0
├─┬ grunt@0.4.5
│ ├── async@0.1.22
│ ├── coffee-script@1.3.3
│ ├── colors@0.6.2
│ ├── dateformat@1.0.2-1.2.3
│ ├── eventemitter2@0.4.14
│ ├── exit@0.1.2
│ ├─┬ findup-sync@0.1.3
│ │ ├─┬ glob@3.2.11
│ │ │ └── minimatch@0.3.0
│ │ └── lodash@2.4.2
│ ├── getobject@0.1.0
│ ├─┬ glob@3.1.21
│ │ ├── graceful-fs@1.2.3
│ │ └── inherits@1.0.2
│ ├─┬ grunt-legacy-log@0.1.3
│ │ ├─┬ grunt-legacy-log-utils@0.1.1
│ │ │ ├── lodash@2.4.2
│ │ │ └── underscore.string@2.3.3
│ │ ├── lodash@2.4.2
│ │ └── underscore.string@2.3.3
│ ├── grunt-legacy-util@0.2.0
│ ├── hooker@0.2.3
│ ├── iconv-lite@0.2.11
│ ├─┬ js-yaml@2.0.5
│ │ ├─┬ argparse@0.1.16
│ │ │ ├── underscore@1.7.0
│ │ │ └── underscore.string@2.4.0
│ │ └── esprima@1.0.4
│ ├── lodash@0.9.2
│ ├─┬ minimatch@0.2.14
│ │ ├── lru-cache@2.7.3
│ │ └── sigmund@1.0.1
│ ├─┬ nopt@1.0.10
│ │ └── abbrev@1.0.9
│ ├── rimraf@2.2.8
│ ├── underscore.string@2.2.1
│ └── which@1.0.9
├─┬ grunt-cli@0.1.13
│ └── resolve@0.3.1
├─┬ grunt-contrib-compass@0.6.0
│ ├── async@0.2.10
│ ├── dargs@0.1.0
│ └── tmp@0.0.21
├─┬ grunt-contrib-compress@0.5.3
│ ├─┬ archiver@0.4.10
│ │ └─┬ readable-stream@1.0.34
│ │   ├── core-util-is@1.0.2
│ │   ├── isarray@0.0.1
│ │   └── string_decoder@0.10.31
│ ├── lazystream@0.1.0
│ └── prettysize@0.0.3
├── grunt-contrib-concat@0.3.0
├─┬ grunt-contrib-jshint@0.7.2
│ └─┬ jshint@2.3.0
│   ├── cli@0.4.5
│   ├── console-browserify@0.1.6
│   ├── minimatch@0.4.0
│   └── underscore@1.4.4
├─┬ jasmine@2.4.1 (git://github.com/jasmine/jasmine-npm.git#b2f2f3c4a85fdfb9982dc6ec7db6c78f55299d77)
│ ├─┬ glob@3.2.11
│ │ └── minimatch@0.3.0
│ └── jasmine-core@2.4.1
├─┬ load-grunt-tasks@0.4.0
│ └─┬ multimatch@0.1.0
│   ├── lodash@2.4.2
│   └── minimatch@0.2.14
├── shelljs@0.1.4
└─┬ temp@0.8.3
  └── os-tmpdir@1.0.1",benchristel,CONTRIBUTOR,2016-07-20 16:57:27+00:00,True,2016-07-22 00:27:24+00:00,1.31,,2,5,2016-07-21 03:20:11+00:00,0.43,amavisca,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1161,expect().toThrow() doesn't work,"code.js
/*jshint node:true*/
'use strict';

exports.throw_error = function () {
    throw new Error('ALL YOUR BASE');
};

spec/TestSpec.js
/*jshint node:true, jasmine:true*/
'use strict';

var code = require('../code.js');

describe('code.js', function () {
    it('test throw_error method', function () {
        expect(code.throw_error()).toThrow();
    });
});

Result
$ jasmine spec/TestSpec.js 
Started
F

Failures:
1) code.js test throw_error method
  Message:
    Error: ALL YOUR BASE
  Stack:
    Error: ALL YOUR BASE
        at Object.exports.throw_error (/home/borisov/test/jasmine/code.js:5:11)
        at Object.<anonymous> (/home/borisov/test/jasmine/spec/TestSpec.js:8:21)

1 spec, 1 failure
Finished in 0.008 seconds

Version
$ jasmine -v
jasmine v2.4.1
jasmine-core v2.4.1",borisovg,NONE,2016-07-20 22:35:01+00:00,True,2016-07-20 22:40:43+00:00,0.0,,2,2,2016-07-20 22:39:31+00:00,0.0,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1164,Test failures on feature branches should not make the Travis badge red,"I'd expect the badge to reflect only the state of master. If I push failing tests to a feature branch that has a PR open, the badge currently turns red.",benchristel,CONTRIBUTOR,2016-07-22 22:37:49+00:00,True,2016-07-22 22:46:49+00:00,0.01,,2,2,2016-07-22 22:46:42+00:00,0.01,benchristel,CONTRIBUTOR,0,2,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1165,"Cannot run ""jasmine examples""","Hi, I was just starting up with jasmine, but I got this:
fs.js:951
  return binding.readdir(pathModule._makeLong(path), options.encoding);
                 ^

Error: ENOENT: no such file or directory, scandir '{{MY_PATH}}/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/example/node_example/spec/helpers/jasmine_examples'
    at Error (native)
    at Object.fs.readdirSync (fs.js:951:18)
    at copyFiles ({{MY_PATH}}/node_modules/jasmine/lib/command.js:186:24)
    at Object.installExamples [as action] ({{MY_PATH}}/node_modules/jasmine/lib/command.js:127:3)
    at Command.run ({{MY_PATH}}/node_modules/jasmine/lib/command.js:47:20)
    at Object.<anonymous> ({{MY_PATH}}/node_modules/jasmine/bin/jasmine.js:11:9)
    at Module._compile (module.js:541:32)
    at Object.Module._extensions..js (module.js:550:10)
    at Module.load (module.js:458:32)
    at tryModuleLoad (module.js:417:12)

Not sure why it happens yet. You probably will be faster than me in understanding why the error is occurring.",walterdolce,NONE,2016-07-23 10:03:33+00:00,True,2016-07-28 21:36:36+00:00,5.48,,3,3,2016-07-27 16:34:19+00:00,4.27,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1166,"Error during ""jasmine -v""","By running jasmine -v, I get:
jasmine v2.4.1
module.js:442
    throw err;
    ^

Error: Cannot find module '../node_modules/jasmine-core/package.json'
    at Function.Module._resolveFilename (module.js:440:15)
    at Function.Module._load (module.js:388:25)
    at Module.require (module.js:468:17)
    at require (internal/module.js:20:19)
    at Object.version [as action] ({{MY_PATH}}/node_modules/jasmine/lib/command.js:174:28)
    at Command.run ({{MY_PATH}}/node_modules/jasmine/lib/command.js:47:20)
    at Object.<anonymous> ({{MY_PATH}}/node_modules/jasmine/bin/jasmine.js:11:9)
    at Module._compile (module.js:541:32)
    at Object.Module._extensions..js (module.js:550:10)
    at Module.load (module.js:458:32)

Node version: v6.3.1
Npm: 3.10.3
OS is Mac OS X El Capitan",walterdolce,NONE,2016-07-23 10:05:42+00:00,True,2016-09-14 23:52:46+00:00,53.57,,2,1,2016-09-14 23:52:46+00:00,53.57,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1167,"Permanent ""Cancelled"" result if using Asynchronous XMLHttpRequest in Google Chrome","Hi there,
I am having both Karma and Jasmine installed. The case described below is tested without Jasmine-Ajax.
For some reason asynchronous ajax requests to remote servers failed with ""cancelled"" state in the Google Chrome console.
describe (""Test:"", function () {
    it (""test XMLHttpRequest"", function (done) {
        var xhr = new XMLHttpRequest ();

        xhr.addEventListener (""load"", function (event) {
            done ();
        }, false);

        xhr.open (""GET"", ""https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"", true);
        xhr.send ();
    });
});

Expected behavior

Ajax requests should work as expected

Actual behavior
Ajax ends with ""abort"" event and exists.
Also the code below works fine in the Google Chrome console:
var xhr = new XMLHttpRequest ();

xhr.addEventListener (""load"", function (event) {
    console.log (""ALL OK"");
}, false);

xhr.open (""GET"", ""https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"", true);
xhr.send ();

Enviroment Details

windows 8.1
gulp CLI version 3.9.1
gulp Local version 3.9.1
Karma version: 1.1.0
jasmine-core: 2.4.1

Workaround
Currently it seems stable if working with synchronous requests:
describe (""Test:"", function () {
    it (""test XMLHttpRequest"", function (done) {
        var xhr = new XMLHttpRequest ();

        xhr.addEventListener (""load"", function (event) {
            done ();
        }, false);

        // TADAAA: synchronous!
        xhr.open (""GET"", ""https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"", false);
        xhr.send ();
    });
});",alexander-ossur,NONE,2016-07-24 05:19:00+00:00,True,2016-07-27 16:31:29+00:00,3.47,,2,1,2016-07-27 16:24:47+00:00,3.46,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1168,How to compose matchers or use built-in matchers in custom matchers,"I have implemented a custom wrapper type - called Some - (using ES6 classes) and now want to create a custom matcher - called toBeSome for this type.
class Some {
  constructor(value) { ...}
  method1() { ... }
  method2() { ... }
}

The custom matcher I want to create needs to accept other matchers which apply to the value inside Some:
expect(new Some(2)).toBeSome(x => x.toEqual(2))

I wasn't sure how to pass in built-in matchers to toBeSome, but I figured if I pass them as functions, I should be able to call them within my custom matcher.
My custom matcher looks like this (I've simplified it here a little bit):
var customMatchers = {
  toBeSome: (util, customEqualityTesters) => ({
    compare: (actual, expectedMatcher) => {
      var result = expectedMatcher(expect(actual.value));
      return result;
    }
  })
};

I'm expecting expectedMatcher(expect(actual.value)) to apply the given expectedMatcher for me.
For example, in the case of expect(new Some(2)).toBeSome(x => x.toEqual(2)) above, expectedMatcher(expect(actual.value)) should become:
expect(actual.value).toEqual(2)

But it actually returns undefined.
It seems like built-in matchers are not defined yet when defining custom matchers?
Any idea how I can pass and use matchers in custom matchers?",mmollaverdi,NONE,2016-07-24 06:10:29+00:00,True,2017-02-16 00:44:05+00:00,206.77,,4,8,2016-07-24 06:15:34+00:00,0.0,mmollaverdi,NONE,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1171,Codeclimate is analyzing files in `lib/`,"Not only do the compiled files get a very bad grade, Codeclimate detects duplicated code between the src/ and lib/ files, which drags the GPA of the whole project down.",benchristel,CONTRIBUTOR,2016-07-25 17:42:22+00:00,True,2016-07-26 04:43:50+00:00,0.46,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1172,Weird behavior when comparing a DOM element to a POJO with a nodeType property,"Some strange stuff happens with toEqual when objects have a nodeType property.
var a = {nodeType: 1, foo: 1};
var b = {nodeType: 1, foo: 'different'};

expect(a).not.toEqual(b); // fails!
// the failure message is ""Expected HTMLNode not to equal HTMLNode.""
The root cause seems to be that we ascertain whether something is a DOM node by checking its nodeType property. But then there's this code from eq:
var aIsDomNode = j$.isDomNode(a);
var bIsDomNode = j$.isDomNode(b);
if (aIsDomNode && bIsDomNode) {
  // At first try to use DOM3 method isEqualNode
  if (a.isEqualNode) {
    return a.isEqualNode(b);
  }
  // IE8 doesn't support isEqualNode, try to use outerHTML && innerText
  var aIsElement = a instanceof Element;
  var bIsElement = b instanceof Element;
  if (aIsElement && bIsElement) {
    return a.outerHTML == b.outerHTML;
  }
  if (aIsElement || bIsElement) {
    return false;
  }
  return a.innerText == b.innerText && a.textContent == b.textContent;
}
if (aIsDomNode || bIsDomNode) {
  return false;
}
The code that uses Element seems to be supposed to run only in IE8 (it can actually be hit in other browsers, if a has a nodeType property, which is checked by isDomNode, but does not have an isEqualNode method). But Element seems to be supported in other browsers as well, so why not always check for DOMness with x instanceof Element?",benchristel,CONTRIBUTOR,2016-07-25 22:11:03+00:00,True,2018-05-05 01:02:10+00:00,648.12,,6,9,2016-07-26 04:26:07+00:00,0.26,Gerg,CONTRIBUTOR,2,2,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1173,Unresolved function or method configureDefaultReporter(),"Hello,
I am very new to using Jasmine and I am trying to set it up to use jasmine-spec-reporter instead of the default reporter. However I cannot remove the default reporter because configureDefaultReporter() is undefined. I am using version 2.3.2
Here is my code
var Jasmine = require('jasmine');
var jasmine = new Jasmine();
var SpecReporter = require('jasmine-spec-reporter');

jasmine.loadConfig({
    ""spec_dir"" : ""test/electron"",
    ""spec_files"" : [
        ""electron_spec.js""
    ],
    ""helpers"" : []
});

jasmine.configureDefaultReporter({
    print: () => {}
});

jasmine.getEnv().addReporter(new SpecReporter());
This should be pretty close to exactly the same as the docs
http://jasmine.github.io/2.4/node.html#section-25
http://jasmine.github.io/2.4/node.html#section-Reporters
I have tried using jasmine.getEnv().configureDefaultReporter() as well.
Any thoughts/suggestions?
I apologize in advance if this is something incredibly simple that is going over my head.",Mercieral,NONE,2016-07-28 16:51:43+00:00,True,2016-07-28 17:26:39+00:00,0.02,,2,3,2016-07-28 17:17:13+00:00,0.02,amavisca,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1174,noTryCatch option to make debugging easier,"When a spec throws an exception and a developer has dev tools open it would be better if the exception is thrown all the way out and causes test execution to stop and the browser to open the source of the exception and begin debugging.
Our current implementation simply avoids the try/catch in QueueRunner attemptSync and attemptAsync functions.",craigcomstocks,NONE,2016-07-28 16:53:15+00:00,True,2016-11-18 19:25:15+00:00,113.11,,2,4,2016-07-28 17:46:37+00:00,0.04,craigcomstocks,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1175,"beforeAll and afterAll execute asyncronious functions inside xdescribe, unlike their -Each counterparts","The behaviour inside disabled suites (i.e. in the xdescribe function calls) of beforeAll and beforeEach differs considerably, and I suppose this is not an expected behavior.
In the example below, if the beforeAll call is changed to beforeEach then the suite passes, otherwise it is not.
One can use such constructs to setup a requirejs module before all specs, so this is not an artificial example, it is just simplified.
describe('TestBug suite\n', function() {
  'use strict';
  xdescribe('xdecsr\n', function() {
    beforeAll(function(done) {
      setTimeout(function() {
        throw 1;
        done();
      }, 0);
    });
    it('descr', function() {
      expect(1).toEqual(1);
    });
  });
  describe('decsr\n', function() {
    it('descr', function() {
      expect(1).toEqual(1);
    });
  });
});

The same issue is with afterAll.",koroliov,NONE,2016-07-31 11:42:35+00:00,True,2016-12-02 17:57:07+00:00,124.26,,3,3,2016-09-14 23:14:34+00:00,45.48,slackersoft,MEMBER,1,0,0,1,"['bug', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,True,False,False,False
1176,jasmine.anything() doesn't match undefined,"When using
spyOn(myFn, 'myMethod');
myFn.myMethod(undefined);
expect(myFn.myMethod).toHaveBeenCalledWith(jasmine.anything());
I get
Expected spy call to have been called with [ <jasmine.anything> ] but actual calls were [ undefined ]
If I use anything other than 'undefined' everything is fine.",w3apps,NONE,2016-08-01 11:02:01+00:00,True,2016-08-02 02:46:50+00:00,0.66,,5,6,2016-08-02 02:46:50+00:00,0.66,Gerg,CONTRIBUTOR,1,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1178,xdescribe results appear in report as pending,"http://jasmine.github.io/2.4/introduction.html#section-Disabling_Suites
As per the docs it states the results will not appear in the results (I'm guessing this means the report). And in Pending section right below it, it clearly makes the distinction that it will still show the results.
And from what I understand xdescribe should not mark things as pending() as it's different from being disabled.
Reproduce:
Using jasmine 2.4.1 (from npm), I copy the code in that section into a file and run jasmine on the file (with a barebones support json file).
Output:
Started
*

Pending:

1) A spec is just a function, so it can contain any code
  No reason given

1 spec, 0 failures, 1 pending spec",hnry,NONE,2016-08-10 19:51:50+00:00,True,2016-12-16 21:47:21+00:00,128.08,,2,6,2016-09-17 00:10:48+00:00,37.18,Gerg,CONTRIBUTOR,0,1,0,1,"['docs', 'ready for work']",False,False,False,False,False,False,False,True,False,True,False,False,False,False,False
1179,Jasmine and JavaScript for Automation (JXA) on the Mac,"Any chance that Jasmine works with JavaScript for Automation (JXA) on the Mac? JXA can't be run in the context of a browser - it has access to OS APIs and things like that, so as I said, it can't run in a browser.
Any ideas?
Thanks",dagware,NONE,2016-08-12 01:20:09+00:00,True,2016-09-16 22:47:15+00:00,35.89,,4,5,2016-08-13 07:33:50+00:00,1.26,joeldbirch,NONE,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1180,Improve default error messages for typed arrays,"For typed arrays, only a comma-separated list of array elements is output, which can cause confusion.
For example:
expect(new Uint32Array([1,3,2,5,4,8,])).toEqual(new Uint8Array([1,3,2,5,4,8,]));
outputs
Error: Expected 1,3,2,5,4,8 to equal 1,3,2,5,4,8.",reiner-dolp,NONE,2016-08-13 09:17:27+00:00,True,2017-08-04 16:34:45+00:00,356.3,,3,5,2016-09-16 22:36:40+00:00,34.56,Gerg,CONTRIBUTOR,0,1,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1181,No documentation for jasmine.json,"I can't find documentation for the jasmine.json file format anywhere, making it a big productivity drain.
I want to figure out how to exclude directories from my specs list, but can't figure out how due to the lack of documentation.
This is a core configuration file and should be easy to find.",fortuna,NONE,2016-08-19 14:31:42+00:00,True,2016-09-07 23:15:52+00:00,19.36,,3,3,2016-08-19 14:47:49+00:00,0.01,fortuna,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1182,Run time generated suites,"Hi, I want to run tests when some event occurs in my app/browser, I embedded jasmine inside some app and tried something more complex but i felt like Jasmine doesn't support run time generated tests so i went and write something simple, like :
describe(""Refresh"", function () {
window.addEventListener(""click"",function(){
describe(""test"",function(){
it(""test"",function(){
expect(true).toBe(true);
});
console.log(""Some text"")
});
})
});
So after this i get ""Some test"" in console but no specs, however if I do this :
describe(""Refresh"", function () {
        describe(""test"",function(){
            it(""test"",function(){
               expect(true).toBe(true);
            });
            console.log(""Some text"")
        });

});
Basically same thing just without window,addEventListener it work. Is there any way i could do this kind of testing in Jasmine and if not can you suggest some framework that supports this kind of testing.
Best regards, Nikola Ilic",chokaa,NONE,2016-08-24 08:52:57+00:00,True,2016-08-24 17:09:41+00:00,0.34,,2,1,2016-08-24 17:09:41+00:00,0.34,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1183,Allow reporters to be cleared,"Hey guys,
I wanted to swap the default Jest reporter, but since they do their own config somewhere and Jasmine only supports adding reporters and not removing old ones, I can't use any reporters unless the guys at Jest make that configurable somehow.
Seems like being able to clear or remove reporters would solve this nicely.",hakunin,NONE,2016-08-25 06:44:25+00:00,True,2016-09-28 19:16:48+00:00,34.52,,2,2,2016-08-25 17:56:05+00:00,0.47,slackersoft,MEMBER,1,0,0,0,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
1184,Stop single test on first expectation failed,"Using jasmine 2.4, and I was wondering if it's possible to stop a single test on first expect failed. I mean the test (it block code) not the entire suite/set of tests (describe block code).
I have acknowledged the existence of stopSpecOnExpectationFailure but this stop all the Spec.
Example
describe('demo suite', function () {
  it('older test', function (done) { /* some code */});
  it('old test', function (done) { /* some code */});

  it('new test', function (done) {

    //should be an object, but let's assume that for some Exception/Error on function returns a null
    var person = getPerson(); 

    expect(person).not.toBeNull();
    expect(person.name).not.toBeNull(); // if person == null will not stop here and throw an exception later
    expect(person.name).toBe('john');

    done();

  });

  it('newer test', function (done) { /* some code */});

});
So, regardless of the other tests being marked as success or failed, it would be great If I could ""stop"" new test on first failed expectation and not by a thrown exception. It's possible to do that?
Appreciate any help you can give! 👍",poliveira89,NONE,2016-08-26 20:58:49+00:00,True,2016-09-14 21:17:54+00:00,19.01,,5,10,2016-09-13 13:33:32+00:00,17.69,henrahmagix,CONTRIBUTOR,1,1,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1185,htmlReporter for node projects,"I can use jasmine-standalone to run spec in the browser and get the nice html output of the specs (only if the specs are not accessing node specific features like process.argv and require('fs')).
However, i am unable to find a way to get same nice html output if i am writing specs for a node project.
when i type this command in the console jasmine, i get the following output:
...............................................................
63 specs, 0 failures
Finished in 1.229 seconds

But I wonder if there is a way like writing this command jasmine --useHtmlReporter so that i get nice html output.
Note that I am using node specific features which means i cannot use tools like browserify to bundle the project and load in the jasmine.html.
It seems that env.addReporter(htmlReporter) requires a DOM and thus should be run in a browser like chrome or PhantomJS, right?",nashwaan,NONE,2016-08-27 08:31:42+00:00,True,2016-09-24 00:38:07+00:00,27.67,,2,1,2016-09-16 22:02:25+00:00,20.56,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1186,Parent's beforeEach/afterEach apply to specs inside nested describe -- bug or by design?,"Let's consider a nested specs structure:
describe {
  beforeEach {}
  afterEach {}
  it { #1 }
  describe {
    it { #2 }
    it { #3 }
  }
}

Right now (or, as of version 2.4.1) beforeEach and afterEach will be called three times, as if specs 2 and 3 where not nested, and at the same level as spec 1.
Nesting logic would suggest calling beforeEach and afterEach only two times, once for spec 1, and once for nested describe, as a whole.
Is current behavior accidental (bug?), or was it created intentionally.
If it is not a bug, then what is the reasoning behind such decision (it will help to find structural work-around).",3n-mb,NONE,2016-08-29 19:57:51+00:00,True,2016-08-30 01:48:14+00:00,0.24,,2,1,2016-08-30 01:48:14+00:00,0.24,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1187,toHaveBeenCalledTimes(0) fails silently in async,"In Jasmine v2.4.1 (jasmine-core v2.4.1), calling expect(obj.Save).toHaveBeenCalledTimes(0) asynchronously hangs until jasmine.DEFAULT_TIMEOUT_INTERVAL limit is reached.
Calling the function synchronously returns the following error

Expected times failed is required as an argument.

Either the behavior of toHaveBeenCalledTimes(0) should be changed to match not.toHaveBeenCalled() or providing 0 to toHaveBeenCalledTimes will have to find a way to emit an error in an asynchronous execution flow.
To reproduce:
describe(""Multiple spies, when created manually"", function () {
  var tape;

  beforeEach(function() {
    tape = jasmine.createSpyObj('tape', ['play', 'pause', 'stop', 'rewind']);

    tape.play();
    tape.pause();
    tape.rewind(0);
  });

  it(""tracks that the spies were called"", function(done) {
    Promise.resolve().then(function () {
        expect(tape.play).toHaveBeenCalled();
        expect(tape.pause).toHaveBeenCalled();
        expect(tape.rewind).toHaveBeenCalled();
        expect(tape.stop).toHaveBeenCalledTimes(0);
        done()
    })
  });
});

Output:

Failures:

Multiple spies, when created manually tracks that the spies were called
Message:
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
Stack:
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
at tryOnTimeout (timers.js:228:11)
at Timer.listOnTimeout (timers.js:202:5)",jerroydmoore,NONE,2016-08-30 23:37:17+00:00,True,2016-09-07 22:56:13+00:00,7.97,,4,3,2016-09-03 23:56:04+00:00,4.01,chrisdeely,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1188,2.5.0 Regression issue with expect().toHaveBeenCalledWith(),"After installing 2.5.0, many of our tests are failing with:
PhantomJS 2.1.1 (Windows 8 0.0.0) Some test... FAILED
        TypeError: undefined is not a constructor (evaluating 'allKeys[i].match(/^[0-9]+$/)') in C:/<path>/node_modules/jasmine-core/lib/jasmine-core/jasmine.js (line 2988)
        c:/<path>/specFile.js:79:85

All the tests I've looked at so far call toHaveBeenCalledWith, e.g.:
expect(aSpy).toHaveBeenCalledWith({
  someProperties: ""string"",
  someOtherProperties: true
})
The full function that is throwing an error is:
    function keys(obj, isArray) {
      var allKeys = Object.keys ? Object.keys(obj) :
        (function(o) {
            var keys = [];
            for (var key in o) {
                if (has(o, key)) {
                    keys.push(key);
                }
            }
            return keys;
        })(obj);

      if (!isArray) {
        return allKeys;
      }

      var extraKeys = [];
      for (var i in allKeys) {
        if (!allKeys[i].match(/^[0-9]+$/)) {
          extraKeys.push(allKeys[i]);
        }
      }

      return extraKeys;
    }
(edit)
Temporary Workaround
Lock jasmine-core to version 2.4.1 until this is addressed.",azz,NONE,2016-08-31 08:17:12+00:00,True,2016-09-02 03:45:01+00:00,1.81,,15,16,2016-08-31 09:27:50+00:00,0.05,tfrijsewijk,NONE,1,1,0,12,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1189,Nested describes fail when using spyOn in 2.5.0,"After updating to 2.5.0 we have lots of failing tests because Jasmine fails to set the spy correctly when describes are nested inside each other. Consider this simple test case:
describe(""demo"", function () {
    beforeEach(function () {
        spyOn(sessionStorage, 'getItem').and.callFake(function (key) {
            return 'item-'+key;
        });
    });

    it(""should do something"", function() {
        expect(sessionStorage.getItem('test')).toBe('item-test');
    });

    describe(""nested describe"", function() {
        it(""should do something"", function() {
            expect(sessionStorage.setItem('test', 'value')).toBe(undefined);
        });
    });
});
The error message returned is:
Error: <spyOn> : getItem has already been spied upon
Usage: spyOn(<object>, <methodName>)",mariusGundersen,NONE,2016-08-31 09:24:49+00:00,True,2016-09-02 04:11:54+00:00,1.78,,5,4,2016-08-31 19:44:07+00:00,0.43,leonelgoncalves,NONE,0,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1190,Jasmine 2.5.0 breaks jasmine.clock tick behavior,"After updating my node project to jasmine-core 2.5.0, jasmine test ticks seems to cause the clock to increase with geometric progression.
Here's a simple test that shows what I'm talking about.  It ticks the clock several times, 1000 ms each time.
describe('jasmine.clock', function() {
    beforeEach(function() {
        jasmine.clock().install();
        jasmine.clock().mockDate(new Date(2016, 6, 7));
    });

    afterEach(function() {
        jasmine.clock().uninstall();
    });

    it('jasmine.clock.tick', function() {
        console.log(Date.now());

        jasmine.clock().tick(1000);

        console.log(Date.now());

        jasmine.clock().tick(1000);

        console.log(Date.now());

        jasmine.clock().tick(1000);

        console.log(Date.now());
    });
});
The actual output is
LOG LOG: 1467864000000
LOG LOG: 1467864001000
LOG LOG: 1467864003000
LOG LOG: 1467864006000

but I expect it to be
LOG LOG: 1467864000000
LOG LOG: 1467864001000
LOG LOG: 1467864002000
LOG LOG: 1467864003000

I think #915 may be the culprit, but that's just because it's the only related recent change I could find.",mramato,NONE,2016-08-31 15:10:40+00:00,True,2016-09-01 04:25:51+00:00,0.55,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1191,"callFake() fails when passing a ""special"" function","To reproduce:
jasmine.createSpy('spy').and.callFake(console.log);
This fails with the following error:
Error: Argument passed to callFake should be a function, got function () {
          self.log(method, arguments)
          return Function.prototype.apply.call(orig, localConsole, arguments);
        }

This is caused by the change in #1059. The check for a function in the change is fn instanceof Function. And since console.log instanceof Function returns false, this will fail.
This is quite confusing, since it indeed is a function. I would say the check should be updated. (For example _.isFunction() returns true for console.log.)",IgorAufricht,NONE,2016-09-01 11:18:54+00:00,True,2016-09-14 23:07:27+00:00,13.49,,2,2,2016-09-04 20:33:26+00:00,3.39,chrisdeely,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1194,Missing `has()` check in `keys()`,"Hey there,
.toEqual() is failing for me since updating to edge, and I tracked it down to a missing has() in the keys function.
Note: I tried to fork and contribute, but jasmine-core package seems to itself load a (gitignored) older version of itself inside of its own ./node_modules, so editing ./lib/jasmine-core/jasmine.js has no effect, and a change in /node_modules/jasmine-core//node_modules/jasmine-core/lib/jasmine-core/jsmine.js can't of course get committed...
Further, I found that the non-node_modules version of that lib has already been fixed using a for loop instead of for-in, but that newer file doesn't get loaded since the node-module dependency takes priority for some reason.
Previous version (commented out hotfix I added):
var extraKeys = [];
for (var i in allKeys) {
    // if (has(allKeys, i)) {
        if (!allKeys[i].match(/^[0-9]+$/)) {
            extraKeys.push(allKeys[i]);
        }
    // }
}
Seems to have been changed recently, but doesn't get loaded:
var extraKeys = [];
if (allKeys.length === 0) {
    return allKeys;
}

for (var x = 0; x < allKeys.length; x++) {
    if (!allKeys[x].match(/^[0-9]+$/)) {
        extraKeys.push(allKeys[x]);
    }
}",nemoDreamer,NONE,2016-09-02 16:48:51+00:00,True,2016-09-07 22:03:19+00:00,5.22,,3,4,2016-09-02 17:16:29+00:00,0.02,mbuckley,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1195,TypeError: undefined is not a constructor (evaluating 'allKeys[i].match(/^[0-9]+$/)'),"Version: 2.5.0
Exception
TypeError: undefined is not a constructor (evaluating 'allKeys[i].match(/^[0-9]+$/)') in ~/node_modules/jasmine-core/lib/jasmine-core/jasmine.js (line 2989)
Assertion triggering exeption
expect(window.alert).toHaveBeenCalledWith 'response'
Overview
After updating jasmine-core from v2.4.1 to v2.5.0 I am seeing the following exception. With the changes to the eq function for v2.5.0, it seems to be caused by the following loop block.
jasmine-core/lib/jasmine.js ~ line 2988
for (var i in allKeys) {
  if (!allKeys[i].match(/^[0-9]+$/)) { // line 2988
    extraKeys.push(allKeys[i]);
   }
}

If I add a guard check for hasOwnProperty it resolves the issue. I'm not familiar enough with this code to know if this is the correct solution. Should this loop also be checking inherit properties or should it exclude them?
// hasOwnProperty example code that resolves the exception
for (var i in allKeys) {
  if (allKeys.hasOwnProperty(i)) { // guard that resolves issue
    if (!allKeys[i].match(/^[0-9]+$/)) {
      extraKeys.push(allKeys[i]);
    }
  }
}

Has anyone else run into this?",mbuckley,NONE,2016-09-02 17:12:29+00:00,True,2016-09-07 22:01:56+00:00,5.2,,11,14,2016-09-02 22:39:31+00:00,0.23,olgabuksa,NONE,1,1,0,9,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1196,SpyOn not being reset on BeforeEach for PhantomJS ,"Hi,
I'm having this issue after updating to v2.5.0.
I'm using SpyOn inside a beforeEach to mock localstorage with an object. Any it() statement will fail, except the first one, throwing Error:  : getItem has already been spied upon
It seems to not be resetting the spies after each it() statement.
This happens when using PhantomJS (2.1.1). Switching to Chrome does not produce the error.
Below is a sample of my code.
Thanks.
import {provide} from '@angular/core';

import {beforeEachProviders, inject} from '@angular/core/testing';

import {MyService} from '../myService/index'

describe('My Service', () => {  

    var storeMock = {};

    beforeEachProviders(() => {
        return [         
        MyService,                               
        ];
    });

    // Mock localStorage;    
    beforeEach(() => {
        storeMock = {};

        spyOn(localStorage, 'getItem').and.callFake( (key:string):String => {
        return storeMock[key] || null;
        });
        spyOn(localStorage, 'removeItem').and.callFake((key:string):void =>  {
        delete storeMock[key];
        });
        spyOn(localStorage, 'setItem').and.callFake((key:string, value:string):string =>  {
        return storeMock[key] = <string>value;
        });
        spyOn(localStorage, 'clear').and.callFake(() =>  {
            storeMock = {};
        });               
    });

    it('should set items in local storage when calling doSomething', inject([MyService], 
        (service: MyService) => {                       

            service.doSomething();

            expect(localStorage.getItem('item1')).toBe('value1');
            expect(localStorage.getItem('item2')).toBe('value2');            
        })
    );

    it('should set items in local storage when calling doSomething2', inject([MyService], 
        (service: MyService) => {                       

            service.doSomething2();

            expect(localStorage.getItem('item3')).toBe('value3');
            expect(localStorage.getItem('item4')).toBe('value4');            
        })
    );

});",ezekjh,NONE,2016-09-02 17:22:28+00:00,True,2016-09-05 13:30:05+00:00,2.84,,2,2,2016-09-03 22:59:14+00:00,1.23,seanparmelee,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1198,mock clock in 2.5.0 advances date by sum of previous calls to tick,"seems that pull request #980 may have fixed an issue, but it broke the clock. mockDate.tick is now called with endTime, which is accumulated from all calls to tick.
Example:
fdescribe('test', function () {
    beforeEach(function() {
        jasmine.clock().install();

        self.baseDate = new Date(2016, 0, 1, 5, 30, 20);

        jasmine.clock().mockDate(self.baseDate);
    });

    function offsetFromBaseDate() {
        return new Date().getTime() - self.baseDate.getTime();
    }

    it('should work', function () {
        expect(offsetFromBaseDate()).toBe(0);

        jasmine.clock().tick(60000);

        expect(offsetFromBaseDate()).toBe(60000);

        jasmine.clock().tick(60000);

        expect(offsetFromBaseDate()).toBe(120000);
    });

    afterEach(function() {
        jasmine.clock().uninstall();
    });
}); 

fails with Expected 180000 to be 120000.",Necroskillz,NONE,2016-09-05 11:47:43+00:00,True,2016-09-07 22:52:57+00:00,2.46,,2,1,2016-09-07 22:52:57+00:00,2.46,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1199,Jasmine does not report anything,"According to jasmine documentation, I should be able to run the testsuite running jasmine.
On this repository running jasmine in the test directory does absolutely nothing, even after exporting JASMINE_CONFIG_PATH to the jasmine.json file or passing it as argument. Note that even changing a test so that it fails, I get no result, no error, nothing. The command just returns to the prompt.
This is the content of the file
$ more jasmine.json 
{
  ""spec_dir"": ""test"",
  ""stopSpecOnExpectationFailure"": false,
  ""random"": false,
  ""spec_files"": [""*spec.js""]
}


(venv) sborini@MacBook-Pro:test (protocol-host-rewrite) [1 stash] $ ls `which jasmine`
/usr/local/bin/jasmine

package.json
{
  ""version"": ""1.4.0-dev"",
  ""name"": ""configurable-http-proxy"",
  ""description"": ""A configurable-on-the-fly HTTP Proxy"",
  ""author"": ""Jupyter Developers"",
  ""license"": ""BSD-3-Clause"",
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""https://github.com/jupyterhub/configurable-http-proxy.git""
  },
  ""dependencies"": {
    ""commander"": ""~2.9"",
    ""http-proxy"": ""~1.13.2"",
    ""lynx"": ""^0.2.0"",
    ""strftime"": ""~0.9"",
    ""winston"": ""~2.2""
  },
  ""devDependencies"": {
    ""jasmine"": ""^2.4.1"",
    ""jshint"": ""^2.9.2"",
    ""nyc"": ""^6.4.0"",
    ""request"": ""~2"",
    ""ws"": ""^1.1""
  },
  ""main"": ""index.js"",
  ""files"": [
    ""index.js"",
    ""lib/configproxy.js"",
    ""lib/trie.js"",
    ""lib/error/*.html"",
    ""bin/configurable-http-proxy""
  ],
  ""bin"": {
    ""configurable-http-proxy"": ""bin/configurable-http-proxy""
  },
  ""scripts"": {
    ""jshint"": ""jshint bin/ lib/ test/"",
    ""test"": ""nyc jasmine JASMINE_CONFIG_PATH=test/jasmine.json"",
    ""coverage-html"": ""nyc report --reporter=html"",
    ""codecov"": ""nyc report --reporter=lcov && codecov""
  }
}",stefanoborini,NONE,2016-09-06 21:39:53+00:00,True,2016-09-07 22:21:52+00:00,1.03,,4,5,2016-09-07 01:01:35+00:00,0.14,godmar,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1200,"When mixing Angular's $q and ES6's Promise, some of the promises don't get resolved.","I was trying to test my code that uses Restangular (which uses $q) and Sweetalert2 (which uses Promise). Basically, I open an alert box; this in turn returns a Promise, which gets resolved when the user clicks the confirm button; then I make a Restangular call which produces a $q promise. While it worked just fine on my browser, the promise produced by $q never got resolved in Jasmine.
So I googled around and found this issue: http://stackoverflow.com/questions/33965435/testing-angular-when-mixing-q-and-es6-promises
It has simple code to reproduce the issue I described above. I'm currently using the workaround suggested by the OP to get around this issue, but I believe there should be a fix for this issue.",yukw777,NONE,2016-09-08 15:19:21+00:00,True,2016-09-16 21:48:25+00:00,8.27,,2,1,2016-09-16 21:48:24+00:00,8.27,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1201,Array containing an object broken after update.,"This check used to pass:
expect(array).toContain(value)

Array:
[
  {""_t"":""user"",""id"":1073970419,""email"":""email3@example.org"",""name"":""Spectator""},
  {""_t"":""user"",""id"":4464992042,""email"":""email4@example.org"",""name"":""Collaborator""},
  {""_t"":""user"",""id"":1978569710,""email"":""email5@example.org"",""name"":""Manage""}
]

Value:
{""_t"":""user"",""id"":1978569710,""email"":""email5@example.org"",""name"":""Manage""}

But no longer passes. Whats the new way to write the same test?
StackOverflow question:
http://stackoverflow.com/questions/39411424/jasmine-how-to-check-that-array-contains-an-object",hakunin,NONE,2016-09-09 12:17:49+00:00,True,2016-09-27 00:10:01+00:00,17.49,,2,3,2016-09-16 16:44:08+00:00,7.18,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1202,how to write test case for REST web service call for custom components,"Hi all,
I am newbie for jasmine test-case .I had written a test-case for my components coded with AngularJS.
release.directive.js
angular.module('wepaComponents')
  .directive('wepaComponentsRelease', wepaComponentsReleaseDirective)

/**
 * Represents a directive for release block.
 *
 * Loads the release block content in body of the release page
 *
 * @example @lang html
 * <wepa-components-release></wepa-components-release>
 */
function wepaComponentsReleaseDirective () {
  return {
    restrict: 'E',

    scope: {
      'callback': '='
    },

    link: function (scope) {},

    templateUrl: 'release/componentRelease.html',

    controller: function ($scope, $http, wepaCore, wepaUIMessageConst, wepaUIErrorMessage,
      $mdDialog, session, $location, DTOptionsBuilder, DTColumnDefBuilder, DTColumnBuilder) {
      $scope.fullName = ''
      $scope.userBalance = ''
      $scope.persons = ''
      $scope.succResponse = ''
      $scope.errorResponse = ''
      $scope.showeAlert = false
      $scope.releasefiles = null
      $scope.API_NAME = session.getAPIName()
      var refreshPrintTimer = ''

      /* DataTable Responsive view changes based on the screen width */

      if (window.innerWidth < 751) {
        $scope.dtColumnDefs = [
          DTColumnDefBuilder.newColumnDef(0).notSortable(),
          DTColumnDefBuilder.newColumnDef(1).notSortable(),
          DTColumnDefBuilder.newColumnDef(2).notSortable(),
          DTColumnDefBuilder.newColumnDef(3).notSortable(),
          DTColumnDefBuilder.newColumnDef(4).notSortable(),
          DTColumnDefBuilder.newColumnDef(5).notSortable().withClass('none')
        ]
      }
      if (window.innerWidth < 630) {
        $scope.dtColumnDefs = [
          DTColumnDefBuilder.newColumnDef(0).notSortable(),
          DTColumnDefBuilder.newColumnDef(1).notSortable(),
          DTColumnDefBuilder.newColumnDef(2).notSortable(),
          DTColumnDefBuilder.newColumnDef(3).notSortable(),
          DTColumnDefBuilder.newColumnDef(4).notSortable().withClass('none'),
          DTColumnDefBuilder.newColumnDef(5).notSortable().withClass('none')
        ]
      }
      if (window.innerWidth > 751) {
        $scope.dtColumnDefs = [
          DTColumnDefBuilder.newColumnDef(0).notSortable(),
          DTColumnDefBuilder.newColumnDef(1).notSortable(),
          DTColumnDefBuilder.newColumnDef(2).notSortable(),
          DTColumnDefBuilder.newColumnDef(3).notSortable(),
          DTColumnDefBuilder.newColumnDef(4).notSortable(),
          DTColumnDefBuilder.newColumnDef(5).notSortable()
        ]
      }
      $scope.dtOptionsdata = DTOptionsBuilder.newOptions()
        .withOption('responsive', true)
        .withOption('paging', false)
        .withOption('scrollCollapse', true)

      /*$scope.dtColumns = [
        DTColumnBuilder.newColumn('ReleaseCode').withTitle('ReleaseCode'),
        DTColumnBuilder.newColumn('Status').withTitle('Status').notVisible()
      ]*/
      /**
       * @desc: This method get the all uploaded file list from the library call
       * it is responsible for (1) Call wepa core library for getFileList function (2) Get and parse the response data
       * from library call (3) Display the uploaded file list (4) Call remote release functions - submitRemoterelease(),
       * cancelRemoterelease() and getRemotereleasestatus()
       *
       * @action getFileDetails initially called from the controller and show the all uploaded file list.
       **/

      $scope.getFileDetails = function () {
        console.log('getFileDetails starts')
        log.info('COM:RELEASE: API: '+ $scope.API_NAME +' getFileDetails Method has been called')
        $scope.token = session.getAuthTokenFromCookie()
        $scope.filenamesession = session.getFilename()
        console.log($scope.filenamesession)
        $scope.file = []
        var j = 0
        $scope.kioskStationKey = ''
        $http.get('config/config.json')
          .then(function (response) {
            log.info('COM:RELEASE: API: '+ $scope.API_NAME +' config.json File has been read')
            $scope.kioskStationKey = response.data.kioskStationIDKey
            wepaCore.getRemoteReleaseStationList([$scope.kioskStationKey])
              .then(function (response) {
                log.info('COM:RELEASE: API: '+ $scope.API_NAME +' getRemoteReleaseStationList service has been called')
                console.log('response.length')
                console.log(response)
                if (response.length <= 0) {
                  $scope.showeAlert = true
                  $scope.errorResponse = 'Station Key is mismatched or invalid!'
                  log.info($scope.errorResponse)
                } else {
                  console.log('submitRemoteRelease loop outer')
                  log.info('COM:RELEASE: API: '+ $scope.API_NAME +' Files submitted to remote release')
                  for (var i = 0; i < $scope.filenamesession.length; i++) {
                    if ($scope.filenamesession[i].checked == true) {
                      console.log('********SELECTED FILE LIST*********')
                      console.log($scope.filenamesession[i])
                      $scope.file[j] = $scope.filenamesession[i];
                      (function (j) {
                        wepaCore.submitRemoteRelease(response[0], $scope.filenamesession[i].releaseCode)
                          .then(function (response) {
                            console.log(response)
                            $scope.file[j].transactionId = response.transactionId
                            $scope.file[j].remotePrintStatus = 'PROCESSING'
                            console.log($scope.file[j])
                          })
                          .catch(function (error) {
                            $scope.showeAlert = true
                            $scope.errorResponse = error.errorMessage
                            console.log(error.errorMessage)
                            log.error('COM:RELEASE: API: '+ $scope.API_NAME +' RemoteRelease process failed')
                          })
                      })(j)
                      j++
                    }
                  }
                  refreshPrintTimer = setInterval(function () {
                    $scope.refreshPrintStatus()
                  }, 10000)
                }
              })
              .catch(function (error) {
                log.error('COM:RELEASE: API: '+ $scope.API_NAME +' Login User login failed!!!')
                console.log(error)
              })
          })
      }

      $scope.refreshPrintStatus = function () {
        for (var i = 0; i < $scope.file.length; i++) {
          {
          if (!angular.isUndefined($scope.file[i].transactionId)) {
            (function (i) {
              wepaCore.getRemoteReleaseStatus($scope.file[i].transactionId)
                .then(function (response) {
                    log.info('COM:RELEASE: API: '+ $scope.API_NAME +' getRemoteReleaseStatus called successfully!')
                  console.log(response.status)
                  console.log('*********TransactionId*********')
                  console.log($scope.file[i].transactionId)
                  if (response.status == 'COMPLETED' || response.status == 'CANCELED' || response.status == 'FAILED' || response.status == 'INVALID') {
                    clearInterval(refreshPrintTimer)
                    $scope.showbar = true
                    $scope.cancel = true
                    console.log('timer stopped')
                  }
                  if (response.status == 'ACCEPTED' || response.status == 'QUEUED' || response.status == 'PRINTING') {
                    console.log('STATUS---->ACCCEPTED|QUEUED|PRINTING')
                    $scope.showbar = false
                    $scope.cancel = false
                  } else {
                    console.log('STATUS----->OTHERS')
                    $scope.cancel = true
                  }
                  $scope.file[i].remotePrintStatus = response.status
                })
                  .catch(function (error) {
                      log.error('COM:RELEASE: API: '+ $scope.API_NAME +' getRemoteReleaseStatus failed!!!')
                  })
            })(i)
          }
          }
        }
      }

      $scope.cancelprint = function (transactionId) {
        var confirm = $mdDialog.confirm()
          .title('Important')
          .textContent('Are you sure do you want to cancel this remote release?')
          .ok('Yes')
          .cancel('No')
        $mdDialog.show(confirm).then(function () {
          console.log('Cancel starts')
          console.log(transactionId)
          wepaCore.cancelRemoteRelease(transactionId)
            .then(function (response) {
              log.info('COM:RELEASE: API: '+ $scope.API_NAME +' Print cancel process has been started')
              console.log('*****CANCEL SERVICE HIT********')
              if (response.status === 'COMPLETED') {
                $scope.cancel = true
                $scope.showbar = false
              } else {
                console.log('CANCEL STATUS FAILED')
                $scope.cancel = false
              }
            }).catch(function (error) {
            log.error('COM:RELEASE: API: '+ $scope.API_NAME + ' Print cancel process failed!!')
            console.log(error)
          })
        }, function () {
          $scope.status = ''
        })
      }
      $scope.getFileDetails()

      /**
       * @desc: This method get the user details from the library call
       * it is responsible for (1) Call wepa core library for getUserInfo function (2) Get and parse the response data
       * from library call (3) Display the uploaded file list
       *
       * @action getUserInfo initially called from the controller and show the user information.
       **/
      $scope.getUserName = function () {
        wepaCore.getUserInfo($scope.token)
          .then(function (response) {
            log.info('COM:RELEASE: API: '+ $scope.API_NAME + ' getUserInfo service has been called successfully and returned user info')
            $scope.succResponse = response
            $scope.fullName = $scope.succResponse.firstName + ' ' + $scope.succResponse.lastName
            $scope.userBalance = $scope.succResponse.accountBalance
          }).catch(function (error) {
          log.error('COM:RELEASE: API: '+ $scope.API_NAME +' getUserInfo service call failed!!')
          console.log(error)
        })
      }
      $scope.getUserName()
      /**
       * @desc: This method clear the current user session data
       * it is responsible for (1) remove user session (2) redirect to login page
       **/
      $scope.logOut = function () {
        log.info('COM:RELEASE: API: '+ $scope.API_NAME + ' Logout successfully')
        session.destroy()
        clearInterval(refreshPrintTimer)
        $location.path('/login')
      }
      $scope.goDashboard = function () {
        log.info('COM:RELEASE: API: '+ $scope.API_NAME + ' Redirect to dashboard')
        clearInterval(refreshPrintTimer)
        $location.path('/dashboard')
      }
      /*
       * @desc: This method is used to show processing dialog box. If user submit the form with valid details
       * this box will appear and intimate to user request has been processing
       */
      $scope.showAlert = function (ev) {
        $scope.hide = false
        $mdDialog.show(
          $mdDialog.alert()
            .clickOutsideToClose(true)
            .title('Sure! Abort the printing')
            .textContent('Click OK to Abort')
            .ok(wepaUIMessageConst.DIALOG_OK)
            .targetEvent(ev)
        )
      }
    }
  }
}


releaseSpec.js:
describe('Unit testing file model', function() {
    var $compile, $rootScope, elements, scope, wepaCore, deferred, $mdDialog, $httpBackend, authRequestHandler, session
    var FAKE_RESPONSE = {data: {status: 'COMPLETED'}}
    var FAKE_FILE_LIST = [{checked: true, tes1: 'test1', tes8: 'test8'}]
    var FAKE_STATIONKEY = ['ABC123-ABC123']
    var FAKE_SUBMIT_RESPONSE = 'TEST_RESPONSE'
    var FAKE_RELEASECODE = 'ABC123'
    var FAKE_TRANSACTIONID = 'abc1234'
    var FAKE_FILERESPONSE = 'COMPLETED'
    var FAKE_LENGTH = 5

    // Load the myApp module, which contains the directive
    beforeEach(module('ngMaterial'))
    beforeEach(module('ngAria'))
    beforeEach(module('datatables'))
    beforeEach(module('wepaComponents'))
    beforeEach(module('wepaComponentsTemplates'))
    beforeEach(module('wepaCore'))

    // Store references to $rootScope and $compile
    // so they are available to all tests in this describe block
    beforeEach(inject(function(_$compile_, _$rootScope_,_wepaCore_,_$q_,_$mdDialog_,_$httpBackend_,_session_) {
        // The injector unwraps the underscores (_) from around the parameter names when matching
        deferred = _$q_.defer()
        $compile = _$compile_;
        $rootScope = _$rootScope_;
        wepaCore = _wepaCore_;
        $mdDialog = _$mdDialog_;
        $httpBackend = _$httpBackend_;
        session = _session_;
        scope = $rootScope.$new();
        log = {
            info: function(str){},
            error: function(str){},
            debug: function(str){}
        }
        spyOn(wepaCore, 'getFileList').and.returnValue(deferred.promise)
        spyOn(wepaCore, 'getUserInfo').and.returnValue(deferred.promise)
        spyOn(wepaCore, 'getRemoteReleaseStatus').and.returnValue(deferred.promise)
        spyOn(wepaCore, 'cancelRemoteRelease').and.returnValue(deferred.promise)
        spyOn(wepaCore, 'submitRemoteRelease').and.returnValue(deferred.promise)
        spyOn(wepaCore, 'getRemoteReleaseStationList').and.returnValue(deferred.promise)
        spyOn($mdDialog, 'show').and.returnValue(deferred.promise)
        //$httpBackend.when('GET', 'config/config.json').respond(deferred.resolve(FAKE_TRANSACTIONID));
        authRequestHandler = $httpBackend.when('GET', 'config/config.json').respond({kioskStationIDKey: '0.0.1'});
        elements = angular.element(""<wepa-components-release callback='called'></wepa-components-release>"");
        $compile(elements)($rootScope.$new())
        $rootScope.$digest()
        controller = elements.controller(""wepaComponentsRelease"")
        scope = elements.isolateScope() || elements.scope()
        scope.callback = function(){}


    }));

    afterEach (function () {
        $httpBackend.verifyNoOutstandingExpectation ();
        $httpBackend.verifyNoOutstandingRequest ();
    });


    it('getFileDetails method called with config.json', function() {
        // Compile a piece of HTML containing the directive
        session.putFilename([{checked:true}])
        scope.getFileDetails();
        deferred.resolve(FAKE_FILE_LIST)
        $httpBackend.flush();
        scope.$digest();
    });

   /* it('getFileDetails method called with empty config.json', function() {
        // Compile a piece of HTML containing the directive
        authRequestHandler.respond(200, '');

        scope.getFileDetails();
        deferred.resolve([])
        $httpBackend.flush();
        scope.$digest();
    });

    it('getFileDetails method called with getRemoteReleaseStationList service rejected', function() {
        // Compile a piece of HTML containing the directive
        authRequestHandler.respond(200, '');
        scope.getFileDetails();
        $httpBackend.flush();
        deferred.reject([])
        scope.$digest();
    });*/

    it('refreshPrintStatus method called', function() {
        // Compile a piece of HTML containing the directive
            scope.file.length = FAKE_LENGTH
            scope.refreshPrintStatus();
            /*scope.file[0] = {transactionId:'terst'}
            scope.file[1] = {transactionId:'terst'}*/
            deferred.resolve(FAKE_TRANSACTIONID)
            $httpBackend.flush();
            scope.$digest();
    });

    it('cancelprint method called', function() {
        // Compile a piece of HTML containing the directive
        scope.cancelprint(FAKE_TRANSACTIONID);
        deferred.resolve(FAKE_RESPONSE)
        $httpBackend.flush();
        scope.$digest();
    });

    it('cancelprint method called', function() {
        // Compile a piece of HTML containing the directive
        console.log('cancelprint method called')
        scope.cancelprint(FAKE_RESPONSE);
        deferred.resolve(FAKE_RESPONSE)
        scope.response.status = FAKE_FILERESPONSE
        deferred.reject(FAKE_RESPONSE)
        $httpBackend.flush();
        scope.$digest();
    });

    it('showAlert() method called with success response', function() {
        // Compile a piece of HTML containing the directive
        scope.showAlert ();
        deferred.resolve(FAKE_RESPONSE)
        window.innerWidth = 600
        $httpBackend.flush();
        scope.$digest();
    });

    it('showAlert() method called with failled response', function() {
        // Compile a piece of HTML containing the directive
        scope.showAlert ();
        deferred.reject(FAKE_RESPONSE)
        window.innerWidth = 600
        $httpBackend.flush();
        scope.$digest();
    });

    it('logOut() method called with success response', function() {
        // Compile a piece of HTML containing the directive
        $httpBackend.flush();
        scope.logOut();
    })

    it('goDashboard() method called with success response', function() {
        // Compile a piece of HTML containing the directive
        $httpBackend.flush();
        scope.goDashboard();
    })
    it('getUserName() method called with success response', function() {
        // Compile a piece of HTML containing the directive
        $httpBackend.flush();
        scope.getUserName();
        deferred.reject(FAKE_RESPONSE)
    })
})

Coverage Report:
Link : Screenshot
I surfed in google for 3 days ,no reference help me to write a good javascript testcase.
Thanks in advance for valuable help !!",gopi1989,NONE,2016-09-12 16:31:06+00:00,True,2016-09-13 00:15:51+00:00,0.32,,2,1,2016-09-13 00:15:51+00:00,0.32,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1204,done.fail() results in timeout,"Calling done.fail() or fail() still waits for the timeout and then prints an erroneous error message stating that the async callback wasn't invoked in time. The error message seems to get through correctly (the message was ""Failed"" below)

Message:
Failed
Stack:
Error: Failed
at /Users/areed/Projects/chilmark/spec/chilmarkSpec.js:45:16
at process._tickCallback (node.js:369:9)
Message:
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
Stack:
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
at Timer.listOnTimeout (timers.js:92:15)",albertreed,NONE,2016-09-13 01:56:33+00:00,True,2016-09-28 00:24:05+00:00,14.94,,4,5,2016-09-16 16:29:33+00:00,3.61,Gerg,CONTRIBUTOR,1,1,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1205,Standalone download for 2.5.1,The 2.5.1 release list on https://github.com/jasmine/jasmine/releases doesn't have a stand-alone download.,tntim96,NONE,2016-09-13 05:18:36+00:00,True,2016-09-14 16:54:39+00:00,1.48,,2,1,2016-09-14 16:54:39+00:00,1.48,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1206,Documentation for customer matchers is unclear,"Hi. In the example for the custom matcher you have this code sample
toBeGoofy: 
// ... time passes
  if (result.pass) {
    result.message = ""Expected "" + actual + "" not to be quite so goofy"";
  } else {
    result.message = ""Expected "" + actual + "" to be goofy, but it was not very goofy"";
  }

Now the test is called ""toBeGoofy"" and the ""pass"" says NOT to be goofy, while the other branch says ""to be goofy"". So ""toBeGoofy"" passes if actual is NOT goofy? It's not clear at all from the two sentences which branch of the if-statement is and which isn't goofy. It's all well and good to have fun while writing documentation, but if it's not understandable than you are missing the point. Is it not possible to have something which is more black and white?
Thanks.",gotofritz,NONE,2016-09-13 14:21:28+00:00,True,2016-09-13 15:24:54+00:00,0.04,,2,2,2016-09-13 15:14:48+00:00,0.04,Gerg,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1207,Missing documentation for .toThrow('foo'),"The jasmine documentation for 'toThrow()' fails to mention the following useful feature.
  it(""The 'toThrow' matcher can also test for specific strings being thrown"", function() {
    var foo = function() {
      throw 'foo';
    };

    expect(foo).toThrow('foo');
    expect(foo).not.toThrow('bar');
  });

This is different than "".toThrowError"" (which expects a ""new Error"" object to be thrown).
(Only by stepping through the source code did I discover this undocumented feature).",Xantix,NONE,2016-09-13 19:22:02+00:00,True,2016-12-16 19:32:30+00:00,94.01,,3,1,2016-09-13 20:58:43+00:00,0.07,slackersoft,MEMBER,1,0,0,0,['docs'],False,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1210,"FR: if there is a map file next to the javascript file, use that for the line numbers","Hi
I use jasmine with typescript source. The problem I am running into is that when an expect fails, jasmine prints out the line number of the line in the javascript file and then I am left trying to do the mapping back to the original typescript source manually. It would be very useful if jasmine would notice the existence of a .map file and use that to figure out the line of the original typescript file.
From other comments I have seen, it doesn't seem that the jasmine authoring team uses typescript at all, but jasmine is proving very useful for unit testing typescript.
Thanks
Greg",gregveres,NONE,2016-09-14 22:13:27+00:00,True,2016-09-14 22:26:50+00:00,0.01,,2,2,2016-09-14 22:26:50+00:00,0.01,slackersoft,MEMBER,1,0,0,1,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
1211,Tests are not running,"For some reason, when I run $ jasmine nothing happen and I really don't get it what am I missing.
package.json
{
    ""jasmine"": ""^2.5.1"",
    ""jshint"": ""^2.7.0""
}

jasmine.json
{
  ""spec_dir"": ""spec"",
  ""spec_files"": [
    ""**/*[sS]pec.js""
  ],
  ""helpers"": [
    ""helpers/**/*.js""
  ],
  ""stopSpecOnExpectationFailure"": false,
  ""random"": false
}

DummySpec.js
describe(""Dummy"", function() {
  it('has a dummy spec to test 2 + 2', function() {
    expect(1 + 1).toEqual(4);
  });
});",rochapablo,NONE,2016-09-15 12:05:16+00:00,True,2016-09-15 16:27:34+00:00,0.18,,2,1,2016-09-15 16:27:34+00:00,0.18,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1212,jasmine.getEnv().currentSpec returns undefined,"Snippet for taking screenshot on Test Failure
    afterEach(function() {

        var spec = jasmine.getEnv().currentSpec;
        var passed = spec.results().passed();

      if (!passed) {
        browser.takeScreenshot().then(function(png) {
          writeScreenShot(png, ""screenshot.png"");
        });
      }

        function writeScreenShot(data, filename) {
                var stream = fs.createWriteStream(filename);
                stream.write(new Buffer(data, 'base64'));
                stream.end();
        }

    });

Console error
  Message:
    Failed: Cannot read property 'results' of undefined
  Stack:
    TypeError: Cannot read property 'results' of undefined
        at Object.<anonymous> 


it returns undefined here,
var spec = jasmine.getEnv().currentSpec;
console.log(spec);",prashanth-sams,NONE,2016-09-16 01:19:13+00:00,True,2016-09-16 22:46:30+00:00,0.89,,3,5,2016-09-16 16:27:56+00:00,0.63,Gerg,CONTRIBUTOR,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1213,stopSpecOnExpectationFailure does not work in asynchronous specs,"Using Jasmine 2.5.2, running in node.
stopSpecOnExpectationFailure will throw an uncaught exception and cause the process to just exit if it's used with an asynchronous spec. This means that reporters don't get a chance to print final output, and wrappers get no chance to recover and shut down gracefully.
For example, with this config:
{
  ""stopSpecOnExpectationFailure"": true,
  ""spec_dir"": """",
  ""spec_files"": [
    ""spec.js""
  ]
}
and this spec file:
describe('async foo', function() {
  it('should bar', function(done) {
    setTimeout(function() {
      expect(1).toEqual(2);
    }, 10);
  });

  it('should baz', function() {
    expect(1).toEqual(1);
  });
});
Instead of getting some nice output, I get:
$ node node_modules/jasmine/bin/jasmine.js JASMINE_CONFIG_PATH=config.json
Started

/Users/ralphj/jasminetest/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:349
        throw new j$.errors.ExpectationFailed();
        ^
Error
    at Object.getJasmineRequireObj.errors (/Users/ralphj/jasminetest/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2761:33)
    at Object.getJasmineRequire.core (/Users/ralphj/jasminetest/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:49:26)
    at Object.module.exports [as boot] (/Users/ralphj/jasminetest/node_modules/jasmine-core/lib/jasmine-core/node_boot.js:24:32)
    at new Jasmine (/Users/ralphj/jasminetest/node_modules/jasmine/lib/jasmine.js:15:30)
    at Object.<anonymous> (/Users/ralphj/jasminetest/node_modules/jasmine/bin/jasmine.js:7:15)
    at Module._compile (module.js:413:34)
    at Object.Module._extensions..js (module.js:422:10)
    at Module.load (module.js:357:32)
    at Function.Module._load (module.js:314:12)
    at Function.Module.runMain (module.js:447:10)",juliemr,NONE,2016-09-20 19:30:39+00:00,True,2016-09-28 21:25:40+00:00,8.08,,3,2,2016-09-24 00:37:11+00:00,3.21,Gerg,CONTRIBUTOR,1,1,0,0,['bug'],False,False,False,False,False,False,False,False,False,False,False,True,False,False,False
1214,No specs found with no errors when using angular decorators and classes calling super(),"When I run jasmine on my browser, I get a no specs found error without errors in my console and my network returns 304 and 200 responses.
I narrowed it down to creating objects from classes that use super() in their constructors or if the angular services uses an @Injectable decorator.

What version are you using?
Jasmine 2.4.1
What environment are you running Jasmine in (node, browser, etc)?
Node JS
Chrome
Typescript
Angular 2 final version
How are you running Jasmine (standalone, npm, karma, etc)?
Standalone and through browser",atang020,NONE,2016-09-22 18:07:10+00:00,True,2016-10-15 00:27:23+00:00,22.26,,4,5,2016-09-24 00:29:56+00:00,1.27,Gerg,CONTRIBUTOR,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1216,configureDefaultReporter to noop will no longer remove the default reporter,"I noticed when I upgrade from version 2.5.1 -> 2.5.2 I am no longer able to supres the console logger with
    let Jasmine = require('jasmine')
    let myReporter = require('./spec/helpers/customReporter')
    let noop = function() {}
    let jrunner = new Jasmine()

    jrunner.configureDefaultReporter({
        print: noop
    }) // remove default reporter logs

running jasmine via node $ node launcher.js
It's OS independent, on both windows and linux",freed00m,NONE,2016-10-03 04:51:51+00:00,True,2016-11-02 00:30:17+00:00,29.82,,2,1,2016-11-02 00:30:17+00:00,29.82,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1217,Show difference in equality failure of objects,"If two objects are compared using expect.toEqual and there is a difference, we only get a dump of the entire object, which makes it nearly impossible to tell what the difference actually is.
Many other libraries print the actual difference. Can jasmine do the same?",aaronbeall,NONE,2016-10-03 21:56:33+00:00,True,2016-10-04 15:50:31+00:00,0.75,,2,1,2016-10-04 15:50:30+00:00,0.75,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1218,Testing a style properties on element hover,"we have a problem with testing styles when element is hovered.  Event for ""mousover"" is executed but change of background color is not detected, but it works in browser.
We are using Jasmine version 2.5.2, Karma version 1.2.0 and Angular 2.
Example of a test:
it('Primary Button shoud have proper css color on hover', fakeAsync(() => {
    let testComponent = fixture.debugElement;
    de = fixture.debugElement.query(By.css('button.a-button.u-is-large'));
    el = de.nativeElement;
    let styles = window.getComputedStyle(el);


    el.addEventListener('mouseover', (a) => {
      tick();
      fixture.detectChanges();

      console.log(styles.backgroundColor);
      expect(de).not.toBeNull();
      expect(styles.backgroundColor).toBe('rgb(0, 138, 203)');

    });

    console.log(styles.backgroundColor);
    let event = new Event('mouseover');
    el.dispatchEvent(event);
  }));

HTML:
<button type=""button"" class=""a-button u-is-large u-is-primary"">Primary Button</button>
If anyone has idea how to solve this, we would really appreciate it.
Thanks",gasperthegracner,NONE,2016-10-06 16:29:50+00:00,True,2016-10-07 00:30:44+00:00,0.33,,4,3,2016-10-07 00:30:44+00:00,0.33,Gerg,CONTRIBUTOR,0,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1219,deepEqual module outdated,"I noticed that current deepEqual implementation lacks a lot of features? It is a ""copy"" of underscore.
Lodash supports more features now, but I also found this one: https://github.com/zubuzon/kewlr. Seems to support both browser and node.
Is this going to be fixed?",,NONE,2016-10-07 12:10:21+00:00,True,2016-12-02 19:40:14+00:00,56.31,,2,2,2016-10-12 00:39:54+00:00,4.52,Gerg,CONTRIBUTOR,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1220,UI is not recreated properly in 2.5+ when window.onload is called multiple times,"I was following this guide to setup Angular2 testing in Jasmine: https://www.xplatform.rocks/2016/02/01/testing-angular2-apps-with-jasmine-and-typescript/
Version 2.4+ works fine, however when updating to version 2.5+, UI is not displayed correctly. See screenshots:
Jasmine 2.4.1

Jasmine 2.5.2

Error in console:
zone.js@0.6.25?main=browser:357 TypeError: Cannot read property 'spies' of undefined
    at currentSpies (https://unpkg.com/jasmine-core@2.5.2/lib/jasmine-core/jasmine.js:803:53)
    at SpyRegistry.clearSpies (https://unpkg.com/jasmine-core@2.5.2/lib/jasmine-core/jasmine.js:2123:19)
    at clearResourcesForRunnable (https://unpkg.com/jasmine-core@2.5.2/lib/jasmine-core/jasmine.js:615:21)
    at https://unpkg.com/jasmine-core@2.5.2/lib/jasmine-core/jasmine.js:777:9
    at ZoneDelegate.invokeTask (https://unpkg.com/zone.js@0.6.25?main=browser:236:37)
    at Zone.runTask (https://unpkg.com/zone.js@0.6.25?main=browser:136:47)
    at drainMicroTaskQueue (https://unpkg.com/zone.js@0.6.25?main=browser:368:35)
    at XMLHttpRequest.ZoneTask.invoke (https://unpkg.com/zone.js@0.6.25?main=browser:308:25)


What version are you using?
2.5.2 (reproducible since 2.5.0)
What environment are you running Jasmine in (node, browser, etc)?
browser
How are you running Jasmine (standalone, npm, karma, etc)?
standalone
If possible, include an example spec that demonstrates your issue.
any spec",dmitrijs,NONE,2016-10-08 15:27:39+00:00,True,2016-10-14 16:27:22+00:00,6.04,,2,2,2016-10-14 16:27:22+00:00,6.04,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1221,"ability to suppress ""has no expectations"" warnings","Using Jasmine 2.5.0, I have several tests that have no expectations. Some are just testing, whether a particular asynchronous method is called (and will error out due to the timeout), others will report errors by throwing exceptions. Currently all these tests print ""Spec 'Foo' has no expectations."" to the browser console and ""SPEC HAS NO EXPECTATIONS"" to the HTML output.
The latter is a bit annoying, since it indicates a problem, where there is none. The former is more problematic as it spams the console with bogus error messages, which make it harder to recognize real problems in the console output.
One workaround is to add a ""null"" expectation to the tests, for example ""expect(true).toBe(true)"", but this makes tests harder to read and is non-obvious.
Below is a real world example:
describe(""Foo.LoadManager"", function () {
    ""use strict"";
    it(""load() will abort another Promise"", function (done) {
        let promise1, promise2,
            manager = new Foo.LoadManager();

        promise1 = new Promise(function (resolve) {
            window.setTimeout(resolve, 1);
        });
        promise2 = new Promise(function (resolve) {
            window.setTimeout(resolve, 5);
        });
        manager.load(promise1).then(() => {
            done.fail(""promise1 was unexpectedly fulfilled"");
        });
        manager.load(promise2).then(done);
    });
});",srittau,NONE,2016-10-11 16:05:28+00:00,True,2017-08-10 00:22:23+00:00,302.35,,7,7,2017-02-16 01:26:44+00:00,127.39,slackersoft,MEMBER,2,1,0,3,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
1223,"HI  i am using jasmin 0.9.b3  version  but unfortunately  new version 0.9.b11 is updated  in repository due to new version  we are unable to update dlr reports to particular  messageId.  so, plz help us ,Thanks in Advance .     ","Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine (Jasmine npm, karma, etc),
consider filing an issue with that library if appropriate

When submitting an issue, please answer the following:


What version are you using?


What environment are you running Jasmine in (node, browser, etc)?


How are you running Jasmine (standalone, npm, karma, etc)?


If possible, include an example spec that demonstrates your issue.
Thanks for using Jasmine!",anushakl,NONE,2016-10-19 10:38:42+00:00,True,2016-10-19 14:04:47+00:00,0.14,,2,1,2016-10-19 14:04:47+00:00,0.14,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1226,Share `this` on beforeAll/afterAll,"Version: 2.4
Environment: browser
Runner: karma

I like that the this object gets shared between each beforeEach run.
But how come this isn't shared with beforeAll/afterAll calls?
There may be an obvious reason to this (apologies for this then), unfortunately I can't see it. Searching around hasn't given me any result either.
Thanks",augnustin,NONE,2016-10-24 17:46:43+00:00,True,2016-10-25 12:30:47+00:00,0.78,,2,4,2016-10-25 11:54:07+00:00,0.76,amavisca,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1227,Wrapping jasmine in node-fiber,"So I have the following to bootstrap my jasmine:
import Jasmine from 'jasmine';
import Fiber from 'fibers';
import log from 'loglevel';

// Set log level to ""error"" so anything lower won't be printed.
log.setDefaultLevel(""error"");

function main() {
    var jasmine = new Jasmine();
    jasmine.loadConfigFile('spec/support/jasmine.json');
    jasmine.execute();
}

// Here we run the main executable.
// This makes javascript synchronous instead of the asynchronous.
Fiber(main).run();
As you can see, I wrapped it in Fiber.
For a short while, no problem. It was testing my ""Fiberized"" modules well. This is until I added a trivial unit test, just accessor test. The accessor test is not failing, but those ""Fiberized"" modules (passing before) are now failing.",JoeyAndres,NONE,2016-10-24 21:30:12+00:00,True,2016-10-24 23:34:27+00:00,0.09,,2,1,2016-10-24 23:34:27+00:00,0.09,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1228,Expose clearReporters() method in runner module,"I noticed that in v2.5.2 the default reporter is no longer removed when adding a custom one. So I've found out that there is a new method. But for some reason it is not exposed in runner class. So now I have to do:
var Jasmine = require('jasmine'),
    jrunner = new Jasmine();

jrunner.env.clearReporters();
jrunner.addReporter(myReporter);

jrunner.execute();
I think it would be better to be able to drop env:
var Jasmine = require('jasmine'),
    jrunner = new Jasmine();

jrunner.clearReporters();
jrunner.addReporter(myReporter);

jrunner.execute();",lonelyelk,NONE,2016-10-25 14:21:03+00:00,True,2017-03-24 18:41:48+00:00,150.18,,3,5,2016-11-30 16:44:51+00:00,36.1,DerekOverlock,NONE,1,0,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1229,Can't use numeric assertions passing through protractor,"I'm trying to use toBeGreaterThan and co in my protractor assertions.
        initialWidth = $(selectedPanel.width).getAttribute('value')
        .... resize the panel ....
        resizedWidth = $(selectedPanel.width).getAttribute('value')
        expect(resizedWidth).toBeGreaterThan(initialWidth)

To my understanding this makes a string comparison, not a number comparison. In fact protractor will resolve the promises (resolving with text) before calling the jasmine matcher.
I guess this could be solved either in the protractor call, but it could also be solved by casting to a number in jasmine. ie
  compare: function(actual, expected) {
    return {
      pass: **+**actual > **+**expected
    };
  }

This seems like the most sensible of the two solutions, but what do you think?
using jasmine 2.4, protractor 3.3.0",martinsson,NONE,2016-10-26 13:31:10+00:00,True,2016-11-02 00:51:00+00:00,6.47,,2,1,2016-11-02 00:50:57+00:00,6.47,Gerg,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1231,"error  "".spies undefined"" after all specs run as of v.2.5.x","Somewhere around jasmine.js v.2.5.x the spy clearing logic changed and I started getting
the error: TypeError: Cannot read property 'spies' of undefined in the console.
The visible symptom is that the browser testrunner output is empty.
All tests have run. This error happens during the final cleanup.
Everything worked fine as recently as v.2.4.1 before some kind of change to the cleanup involving spies.
See the errant behavior in this trivial plunker: http://plnkr.co/edit/qixgrpWpf6mgbIfn29zc?p=preview from the Angular 2 docs (I'm the author of the Angular 2 testing chapter).
During the final cleanup, when the id is ""suite0"", the error is thrown in ...
    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {
      if(!currentRunnable()) {
        throw new Error('Spies must be created in a before function or a spec');
      }
      return runnableResources[currentRunnable().id].spies; // <-- THROWS HERE
    }});

... because the value of runnableResources is the empty object {}.
The following hack gets around the bug:
    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {
      if(!currentRunnable()) {
        throw new Error('Spies must be created in a before function or a spec');
      }
      if (runnableResources[currentRunnable().id]) {
        return runnableResources[currentRunnable().id].spies;
      }
      return [];
    }});",wardbell,NONE,2016-10-30 06:20:05+00:00,True,2017-06-16 21:11:13+00:00,229.62,,9,19,2016-11-04 18:49:36+00:00,5.52,slackersoft,MEMBER,1,0,0,6,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1232,There is a broken link in the Wiki,In the Wiki you are pointing to 'Try Jasmine out in your browser' which is pointing to broken link. Could you please update?,nalekberov,NONE,2016-11-06 20:22:29+00:00,True,2016-11-06 21:16:01+00:00,0.04,,2,1,2016-11-06 21:16:01+00:00,0.04,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1233,Tests get false positive if you yield without wrapping (in coffeescript),"Version: jasmine-core@2.4.1
Environment: node, coffeescript
Run via npm run jasmine
This is a problem especially with Coffeescript, which will ""helpfully"" automatically convert functions to generators for you if you use yield in them.
We normally use this slight modification of co.wrap around all our it test functions, so that we can yield inside them.
co = require 'co'

module.exports = utils =
  wrap: (gen) ->
    fn = co.wrap(gen)
    return (done) ->
      fn.apply(@, [done]).catch (err) -> done.fail(err)

The problem is that if we accidentally leave off utils.wrap, the test still passes silently, but none of the expectations were actually run. This seems to happen any time the callback that it gets is a generator function.
Here's a spec that works correctly (by failing)
it ""doesn't silently pass generator functions"", utils.wrap (done) ->
  a = yield Promise.resolve(""a"")
  expect(false).toBe(true)
  done()

Here's a spec that demonstrates the problem (by passing)
it 'silently passes generator functions', ->
  a = yield Promise.resolve(""a"")
  expect(false).toBe(true)

The problem doesn't occur if you use (done) ->, (it correctly fails due to timeout), but because yielding tests look synchronous, we failed to notice that in several cases.
This is what we've put in place for now to prevent this from ever happening, in our spec helper.js file, which successfully revealed three old tests which were not actually being run due to this problem. It would be great if something like this were put into Jasmine proper.
var oldIt = global.it;
global.it = function(description, testFn) {
  if(testFn.constructor.name === 'GeneratorFunction'){
    throw(Error(""You didn't wrap a generator function! Do it like this: it 'does a thing', utils.wrap (done) ->""))
  }
  oldIt.apply(jasmine.getEnv(), arguments)
}",phoenixeliot,NONE,2016-11-07 20:30:10+00:00,True,2017-04-11 18:53:31+00:00,154.93,,2,3,2016-11-18 20:31:05+00:00,11.0,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1235,feature: make main testing functions module importable,"In a javascript, typescript or other module environment it would be ideal to import the testing functions as opposed to making them available globally.
eg
import { describe, it } from 'jasmine';
Does this sound like a good idea to everyone else?",mikehaas763,NONE,2016-11-12 14:03:00+00:00,False,,,,3,3,2016-11-18 20:23:07+00:00,6.26,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1237,executing Jasmine twice creates exception via undefined spies property on undefined ,"I'm using Jasmine to generate a boolean of pass/fail.  This is on 2.5.2
To do this, I'm running jasmine.execute([files]) and relying on jasmine.completionReporter.onComplete.
Running jasmine.execute a second time produces an exception on line 803 of jasmine.js in jasmine-core.  Seems the currentRunable().id is undefined in runnableResources.
    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {
      if(!currentRunnable()) {
        throw new Error('Spies must be created in a before function or a spec');
      }
      return runnableResources[currentRunnable().id].spies; // exception,runnableResources = [];
    }});",mikegwhit,NONE,2016-11-30 04:26:17+00:00,True,2016-12-01 00:48:04+00:00,0.85,,2,3,2016-11-30 04:36:47+00:00,0.01,mikegwhit,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1238,Custom Matchers Issue,Never mind I figured it out. Please delete this issue.,Mujaddadi,NONE,2016-12-01 17:27:43+00:00,True,2016-12-01 18:13:33+00:00,0.03,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1239,Provide clear documentation with function signatures,"Hello.
Current documentation it's fun and good example. But when I find some non-typical framework's call I stumble every time to understand what extra parameter means. Can you make standard documentation with function signatures and parameters description.
E.g., At the moment I'm trying realize what 3rd parameter does in this call
it('text', callbackFunc, 1000)",fetis,NONE,2016-12-02 16:50:12+00:00,True,2016-12-02 17:35:19+00:00,0.03,,2,1,2016-12-02 17:35:19+00:00,0.03,slackersoft,MEMBER,1,0,0,0,['docs'],False,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1240,nstall jasminenoe,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine (Jasmine npm, karma, etc),
consider filing an issue with that library if appropriate

When submitting an issue, please answer the following:

What version are you using?
What environment are you running Jasmine in (node, browser, etc)?
How are you running Jasmine (standalone, npm, karma, etc)?
If possible, include an example spec that demonstrates your issue.

Thanks for using Jasmine!",gibbok,NONE,2016-12-09 17:36:51+00:00,True,2016-12-09 18:47:25+00:00,0.05,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1241,Only first spec runs when testing with Nashorn engine,"I'm trying to run Jasmine with Nashorn. I've written my boot script and basically Jasmine runs as intended, but sadly it runs only first spec from first suite. Here is my code (I copied jasmine release /lib folder contents inside ./jasmine folder):
./code.js:
var isJavaByteArray = function(value) {
    return typeof value == 'object' 
        && typeof value.length == 'number' 
        && !Array.isArray(value)
        && (value.length == 0 || typeof value[0] == 'number')
}
./test.js:
#!/usr/lib/jvm/default/bin/jjs -scripting


load('jasmine/jasmine.js');

jasmine = jasmineRequire.core(jasmineRequire);
var env = jasmine.getEnv();
var jsm = jasmineRequire.interface(jasmine, env);

env.addReporter({

    jasmineStarted: function(suiteInfo) {
        print('Running suite with ' + suiteInfo.totalSpecsDefined);
    },

    suiteStarted: function(suite) {
        print('\n    ' + suite.description + '...');
    },

    specDone: function(result) {
        print(result.description + ': ' + result.status);

        for(var i = 0; i < result.failedExpectations.length; i++) {
            print('Failure: ' + result.failedExpectations[i].message);
            print(result.failedExpectations[i].stack);
        }
    }

});



load('code.js');


jsm.describe(""code.js"", function() {

    jsm.it(""recognizes Java byte[] array correctly"", function() {
        jsm.expect( isJavaByteArray([1, 2, 3]) ).toBe(false);
        jsm.expect( isJavaByteArray(new java.lang.String('test').getBytes()) ).toBe(true);
    });

    jsm.it(""is not insane"", function() {
        jsm.expect( true ).toBe(true);
    });

});

jsm.describe(""Nashorn"", function() {

    jsm.it(""is not insane"", function() {
        jsm.expect( true ).toBe(true);
    });

});


env.execute();
I made some additional effort (load/print functions substitutes) to run the tests with Node.js, and under Node.js all tests are running. Am I doing some mistake? How can I debug to resolve my problem?",loziniak,NONE,2016-12-09 20:34:14+00:00,True,2017-10-26 19:28:41+00:00,320.95,,4,4,2017-01-12 01:10:27+00:00,33.19,slackersoft,MEMBER,2,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1243,Feature request: done() in describe,"Using:
-Jasmine 2.5
-Node 6.6
-with Protractor
Background:
I'm generating a list of string URIs from a page, through a promise running in beforeEach.
I'd like to loop through that list and on each URI, which I'd like to place each in its own describe with the URI string as title, execute a number of tests, which preferably should live each in its own it().
My code looks like this:
`describe('Pages', () => {
var pages

beforeAll((done) => {

  // open page
  browser.get(someurl)

  // get links
  element.all(by.css(someselector)).then(rows => {
    get_list_of_url_objects_from_elements(rows).then( resolved_links=> {
      pages = resolved_links
      done()
    })
  })
})

   pages.forEach( page => {
  describe(page.name+' should have no 404',() => {
    beforeAll(() => {
      browser.get(page.href)
    })

    it('on images', () => {
      common.check404_images()
    })

    it('on stylesheets', () => {
      common.check404_stylesheets()
    })
      
    it('on scripts', () => {
      common.check404_scripts()
    })
  })
})

})
`
Problem:
pages is always in undefined, because that part of the code is executed while the first beforeAll runs.
Possible solution:
I could just wrap the forEach loop within a describe(done), so that it waits for pages to have a value.
Requested feature:
I'd need describe to allow done() function, so that I can do async tests with better separation of sub-specs.
In the meantime, I managed to stash the each loop in a single big it() and execute all tests on all URIs together, but it's not pleasant and I really would like to display separate sections for each sub-spec.
Thanks for the attention",aijanai,NONE,2016-12-13 12:10:09+00:00,True,2017-02-09 21:59:27+00:00,58.41,,2,1,2017-02-09 21:59:27+00:00,58.41,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1244,Derivative Promises get resolved incorrectly,"Gist:
I spy on get method of my rest service.
spyOn(restService, 'get').and.callFake(function () {
return deferred.promise;
});
The method I am trying to test is myService.getFormData() that returns a chained promise:
function getFormData() {
var getPromise = this.restService.get(endPoint, params, true);
var processedDataPromise = then(successHandle, failHandler);
return processedDataPromise;
}
3.Back to Jasmine spec, I invoke getFormData function and make assertions:
     var processedDataPromise = myService.getFormData();
     processedDataPromise.then(function(data) {
      expect(data).not.toBeNull();

    });

deferred.resolve(testFormData);
$rootScope.$digest();
The Problem:
The above derivative promise (processedDataPromise) does indeed get resolved. However the 'data' passed to it is undefined. Is it anything to do with $digest cycles not doing its job in Jasmine?
Why does Jasmine not pass any data to the above derived promise.?
Further Note: The processedDataPromise is a completely new promise than the get returned promise.
It is a promise for processedData which as we can see is returned by successHandle (Definition not shown) once its parent getPromise gets resolved.
In UI everything works like a Charm.",YelloJacket,NONE,2016-12-14 18:43:16+00:00,True,2017-02-09 19:05:45+00:00,57.02,,3,2,2016-12-23 14:45:44+00:00,8.84,zion1129,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1245,Behaviour of stopSpecOnExpectationFailure=true + done.fail(Error),"Hello,
Run: jasmine-npm
Version: 2.5.2
Node: 7.0.0
With the following
Config:
{
  ""stopSpecOnExpectationFailure"": true,
}
Test:
    it('Should fail in async before test', (done) => {
        Promise.reject(new Error('make me fail')).then((result) => {
            expect(result).toEqual(result);

            done();
        }).catch(done.fail);
    });
I have an error
(node:30498) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error
(node:30498) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
F

Failures:
1) MalformedMessageError: Should fail in async before test
  Message:
    Failed: make me fail
  Stack:
    Error: make me fail
        at Object.it (/path/to.spec.js:34:24)
  Message:
    Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
  Stack:
    Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
        at ontimeout (timers.js:365:14)
        at tryOnTimeout (timers.js:237:5)
        at Timer.listOnTimeout (timers.js:207:5)

There are 2 possible solutions:

Make done.fail not to rethrow an error
Update docs to document such case

Both are OK for me, but it took several hours to find a root cause of test failures.",wingedfox,NONE,2016-12-15 11:32:20+00:00,True,2017-04-11 17:15:25+00:00,117.24,,3,4,2017-02-09 19:00:55+00:00,56.31,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1247,the doc error in introduction.js about the mockDate,"Hello!
I recently read the documentation, and I found an error in it.
About the mocking the Date part in the documentation, the code is as below:
   describe(""Mocking the Date object"", function(){
     it(""mocks the Date object and sets it to a given time"", function() {
         var baseTime = new Date(2013, 9, 23);

         jasmine.clock().mockDate(baseTime);

        jasmine.clock().tick(50);
        expect(new Date().getTime()).toEqual(baseTime.getTime() + 50);
       });
   });

According to the documentation, before using jasmine.clock().tick function to manipulate time, we  should call the jasmine.clock().install function.
When I test the code shown as above, it throws an error : ""Mock clock is not installed, use jasmine.clock().install()"".",lukesomnus,NONE,2016-12-28 11:36:26+00:00,True,2016-12-29 01:54:22+00:00,0.6,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1250,Support symbols in array arg to createSpyObj() and expect().toHaveBeenCalled() etc," - What version are you using? 2.5.2
Symbols don't appear to work in these methods, I get the error:
TypeError: Cannot convert a Symbol value to a string",nbransby,NONE,2017-01-03 22:41:16+00:00,True,2017-02-09 21:53:57+00:00,36.97,,2,3,2017-02-09 21:53:57+00:00,36.97,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1251,EADDRINUSE connect EADDRINUSE 127.0.0.1:<port number> error seen when executing protractor scripts,"Node version - 4.4.2
Jasmine version - 2.4.1
Protractor version - 3.1.1
OS - Windows Server 2012 R2, 64-bit
When we try to run our protractor tests that use Jasmine, we see an error - EADDRINUSE being thrown after a couple of it blocks are executed. This same test works fine on our laptops (Win7 64bit). Can you advise on why this error is thrown?
The error thrown: EADDRINUSE connect EADDRINUSE 127.0.0.1:
It throws a random port number each time and we have verified that this port is not being used by any other processes at that time.",eymemathew,NONE,2017-01-05 22:24:27+00:00,True,2017-01-06 05:57:51+00:00,0.31,,2,1,2017-01-06 05:57:51+00:00,0.31,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1252,toThrowError with <iframe> reports incorrectly,"jasmine-standalone-2.5.2 in browser

Hi, thank you for the great framework.
When an app that runs in <iframe> is tested, toThrowError reports incorrectly. It says ""Expected function to throw an Error, but it threw..."".
Jasmine uses Error constructor in current window, but it was made by Error constructor in child window.
In this code:

  
    
      jasmine/src/core/matchers/toThrowError.js
    
    
         Line 31
      in
      8624a52
    
    
    
    

        
          
           if (!(thrown instanceof Error)) { 
        
    
  


if (!(thrown instanceof Error)) {
It checks with the Error in current window always. But the thrown was made in different global (namespace).
For example:

app.html

<!DOCTYPE html>
<html>
<head>
  <meta charset=""utf-8"">

  <script>

    function methodA() {
      return 'foo';
    }

    function methodB() {
      throw new Error('bar');
    }

  </script>

</head>

<body>
  app.html
</body>
</html>

Spec

describe('App running in <iframe>', function() {

  function methodC() {
    throw new Error('baz');
  }

  var childWindow;

  beforeAll(function(done) {
    // Prepare <iframe>
    var iframe = document.body.insertBefore(document.createElement('iframe'), document.body.firstChild)
    iframe.addEventListener('load', function() {
      childWindow = iframe.contentWindow;
      // self.Error = childWindow.Error;
      done();
    });
    iframe.src = 'app.html';
  });

  it('should return foo', function() {
    expect(childWindow.methodA()).toBe('foo');
  });

  it('should throw an error', function() {
    expect(function() {
      childWindow.methodB();
    }).toThrowError('bar');
  });

  it('(test in current window)', function() {
    expect(function() {
      methodC();
    }).toThrowError('baz');
  });
});
The second spec fails.
I think, this line:
if (!(thrown instanceof Error)) {
should be:
if (!(thrown instanceof (thrown.constructor.constructor('return this')()).Error)) {
This gets Error from the same global as thrown.",anseki,CONTRIBUTOR,2017-01-12 06:54:23+00:00,True,2017-03-10 22:36:40+00:00,57.65,,2,2,2017-02-09 22:10:40+00:00,28.64,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1253,Stop Jasmine javascript testing after first it fails.,"I am new to jasmine javascript testing and for starting i got a dummy project from internet with some basic functions and test spec for same. I am using jasmine 2.5 and using jasmine.js library for loading jasmine related functionality. I am running this basic test in chrome browser.
My source file: MathUtils.js:
MathUtils = function() {};

MathUtils.prototype.sum = function(number1, number2) {
		return number1 + number2;
}

MathUtils.prototype.substract = function(number1, number2) {
	return number1 - number2;
}

and spec file for this is:
describe(""MathUtils"", function() {
	var calc;
	beforeEach(function() {
		calc = new MathUtils();
	});
	it(""should be able to calculate sum of 10 and 40"", function() {
		expect(calc.sum(10, 40)).toEqual(54);	
	});
        it(""should be able to calculate diff of 40 and 10"", function() {
		expect(calc.substract(40, 10)).toEqual(30);	
	});
});

In spec, 1st case will fail and 2nd will pass.
Here I want a mechanism to stop execution when 1st case fails i.e. when 1st case fails 2nd should not execute. Right now even if 1st case fails, it executes remaining cases and shows report with test cases fail/pass status.
There are already issue with same requirement raised specially #414 and #577 . I tried to use the solution but could not achieve desired result. (or you can say i did not understand it)
Can you give solution in naive way, or in context of above code so it will be very basic approach to understand jasmine abort test feature for new developer.",gavdix,NONE,2017-01-13 10:02:47+00:00,True,2017-02-09 22:42:53+00:00,27.53,,3,4,2017-01-15 01:04:12+00:00,1.63,lmj0011,NONE,1,0,0,2,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
1254,Test fail when calling `done(true)`,"Hi guys!
As I was reading (jasmine/jasmine.github.io#67), jasmine should not fail when calling done(true) or done(whatever!), but it's failing in my local env.
Do you have unit tests for done function? You should check that done should not fail when passing a parameter.


What version are you using?
""karma-jasmine"": ""^0.3.6"",


What environment are you running Jasmine in (node, browser, etc)?
Browser


How are you running Jasmine (standalone, npm, karma, etc)?
IE, Chrome, FF, Safari",NoelBroda,NONE,2017-01-13 14:50:16+00:00,True,2017-02-09 22:28:31+00:00,27.32,,2,1,2017-02-09 22:28:31+00:00,27.32,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1255,expect(null).toEqual(jasmine.any(Object)) passes,"version
jasmine v2.5.3
jasmine-core v2.5.2
environment
node v6.9.4
npm v3.10.10
running Jasmine
from cli using the jasmine command to run my tests
I'm expecting this to fail, but it doesn't.
How does null equal an Object?
expect(null).toEqual(jasmine.any(Object));",lmj0011,NONE,2017-01-15 00:52:49+00:00,True,2018-02-06 19:23:09+00:00,387.77,,4,4,2017-01-30 16:29:36+00:00,15.65,JamieMason,NONE,1,0,0,2,"['feature request', 'has Tracker story']",False,True,False,False,False,False,False,False,True,False,False,False,False,False,False
1256,Give test file in the result to enable to use the new sonar generic test import,"When reporting to sonar, we now need to specify in wich file the test has run - see this:
https://docs.sonarqube.org/display/PLUG/Generic+Test+Coverage
A plugin exists to report data from karma to jenkins, but it requires the ""describe"" to contains the exact path name, which is not really beautifull:
https://github.com/tornaia/karma-sonarqube-unit-reporter
Would it be possible to add the file path (relative to baseRoot of course) in the result:
this.specSuccess = this.specSkipped = this.specFailure = function (browser, result) {
result.file = ...
}
Thanks in advance",jehon,NONE,2017-01-16 15:26:47+00:00,False,,,,2,2,2017-01-16 15:37:42+00:00,0.01,jehon,NONE,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1257,Maps comparison always passes,"This code passes successfully:
const a = new Map();
const b = new Map();
a.set('name', 10);
b.set('id', 9);

expect(a).toEqual(b);
URLSearchParams objects comparison also always passes because of using Map internally
Tested on Jasmine 2.4.1 and 2.5.2. Using Karma test runner (version 1.3.0), Chrome 55.0.2883.",downace,NONE,2017-01-18 06:41:45+00:00,True,2017-05-19 21:19:21+00:00,121.61,,5,6,2017-02-10 00:18:22+00:00,22.73,derekdowling,NONE,1,0,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1258,TypeError: null is not an object,"Below is the error log that I have received with running the gulp test
bower_components/angular/angular.js:4631:53
18-Jan-2017 16:45:09	forEach@bower_components/angular/angular.js:322:24
18-Jan-2017 16:45:09	loadModules@bower_components/angular/angular.js:4591:12
18-Jan-2017 16:45:09	createInjector@bower_components/angular/angular.js:4513:30
18-Jan-2017 16:45:09	workFn@bower_components/angular-mocks/angular-mocks.js:3060:60
18-Jan-2017 16:45:09	     TypeError: null is not an object (evaluating 'obj[methodName]') in node_modules/jasmine-core/lib/jasmine-core/jasmine.js (line 1991)
When submitting an issue, please answer the following:


What version are you using?  ""jasmine-core"": ""2.4.1""


What environment are you running Jasmine in (node, browser, etc)?  node


How are you running Jasmine (standalone, npm, karma, etc)?  karma


If possible, include an example spec that demonstrates your issue.
it 'should go() to `login` state', ->
 spyOn $state, 'go'

 $security.notAuthenticated 'bar',
   foo: 'bar'

 expect $state.go
   .toHaveBeenCalledWith 'login',
     data: Base64.encode '{""to"":""bar"",""toParams"":{""foo"":""bar""}}'



Thanks for using Jasmine!",dinee4321,NONE,2017-01-18 18:38:27+00:00,True,2017-02-15 23:56:01+00:00,28.22,,2,1,2017-02-15 23:50:02+00:00,28.22,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1260,toThrow don't work in Firefox,"I'm running test from browser (firefox) and toThrow don't work (it work in Chrome)
I have code like this:
it('should throw exception when calling from login', function() {
    term.logout();
    var strings = $.terminal.defaults.strings;
    expect(function() { term.logout(); }).toThrow(new Error(sprintf(strings.notWhileLogin, 'logout')));
    enter(term, '1');
    enter(term, '1');
    push_interpreter();
    expect(function() { term.logout(); }).toThrow(new Error(sprintf(strings.notWhileLogin, 'logout')));
});
I get this Error message:
Error: You can't call `login' function while in login in http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js (line 4124)
$.fn.terminal/<.login@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:4124:27
$.fn.terminal/</<@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:5279:28
ready/<@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:5098:33
make_interpreter@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:3187:17
ready@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:5086:21
when_ready@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:3921:17
$.fn.terminal/<.push@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:5061:17
$.fn.terminal/</<@http://localhost/projects/jcubic/terminal/repo/js/jquery.terminal-src.js:5279:28
push_interpreter@http://localhost/projects/jcubic/terminal/repo/spec/terminalSpec.js:1986:21
tests_on_ready/</</</<@http://localhost/projects/jcubic/terminal/repo/spec/terminalSpec.js:2026:21
attemptSync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1510:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1498:9
QueueRunner.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1485:5
Env/queueRunnerFactory@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:518:7
Spec.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:306:5
wrapChildAsAsync/<@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1708:31
attemptAsync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1520:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1496:16
attemptAsync/next@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1517:32
complete@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:333:9
clearStack@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:506:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1505:7
QueueRunner.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1485:5
Env/queueRunnerFactory@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:518:7
Spec.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:306:5
wrapChildAsAsync/<@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1708:31
attemptAsync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1520:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1496:16
attemptAsync/next@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1517:32
complete@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:333:9
clearStack@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:506:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1505:7
QueueRunner.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1485:5
Env/queueRunnerFactory@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:518:7
Spec.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:306:5
wrapChildAsAsync/<@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1708:31
attemptAsync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1520:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1496:16
attemptAsync/next@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1517:32
complete@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:333:9
clearStack@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:506:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1505:7
QueueRunner.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1485:5
Env/queueRunnerFactory@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:518:7
Spec.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:306:5
wrapChildAsAsync/<@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1708:31
attemptAsync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1520:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1496:16
QueueRunner.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1485:5
Env/queueRunnerFactory@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:518:7
Suite.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1694:5
wrapChildAsAsync/<@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1708:31
attemptAsync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1520:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1496:16
attemptAsync/next@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1517:32
complete@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1703:9
clearStack@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:506:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1505:7
attemptAsync/next@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1517:32
complete@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:333:9
clearStack@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:506:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1505:7
QueueRunner.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1485:5
Env/queueRunnerFactory@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:518:7
Spec.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:306:5
wrapChildAsAsync/<@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1708:31
attemptAsync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1520:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1496:16
QueueRunner.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1485:5
Env/queueRunnerFactory@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:518:7
Suite.prototype.execute@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1694:5
wrapChildAsAsync/<@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1708:31
attemptAsync@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1520:9
QueueRunner.prototype.run@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1496:16
attemptAsync/next@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1517:32
complete@http://localhost/projects/jcubic/terminal/repo/bower_components/jasmine/lib/jasmine-core/jasmine.js:1703:9

I'm using jasmine ~2.5.2 from bower
You can see it online here  http://terminal.jcubic.pl/SpecRunner.html",jcubic,NONE,2017-01-21 17:48:36+00:00,True,2017-01-21 18:28:41+00:00,0.03,,1,1,2017-01-21 18:28:41+00:00,0.03,jcubic,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1261,Firefox load spec two times,"I'm running jasmine from browser it work fine from Chromium but in FireFox it load my spec twice I have only one <script> tag in html file and if I remove it, it don't load my tests at all. To fix it I needed to add code that check for global variable if it set to true it don't load tests.
If can check it here http://terminal.jcubic.pl/SpecRunner.html look at firefox console (there are two requests for spec/terminalSpec.js",jcubic,NONE,2017-01-21 18:01:07+00:00,True,2017-01-24 23:44:55+00:00,3.24,,2,2,2017-01-24 23:44:55+00:00,3.24,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1262,undefined is not a constructor (evaluating 'this.documentResponsiveListener()') ,"I'm using a ConfirmDialog component from the PrimeNG library in my angular 2 app. The component works fine when testing it out in a browser, but for some reason, using the component makes Karma/Jasmine explode.
 Error: Error in ./ReturnFileParameterComponent class ReturnFileParameterComponent - inline template:2:4 caused by: undefined is not a constructor (evaluating 'this.documentResponsiveListener()') in C:/Users/wlaw/Desktop/ens_fits_ui/karma-shim.js (line 41475)
        ngOnDestroy@C:/Users/wlaw/Desktop/ens_fits_ui/karma-shim.js:71991:45 <- webpack:///~/primeng/components/confirmdialog/confirmdialog.js:140:0
        ngOnDestroy
        destroyInternal
        destroy@C:/Users/wlaw/Desktop/ens_fits_ui/karma-shim.js:41076:34 <- webpack:///~/@angular/core/bundles/core.umd.js:12361:0
        ...

In the component.spec.ts file, I imported both the dialog service and module needed for the dialog component to work:
import {
    ...
    ConfirmDialogModule,
    ConfirmationService
} from 'primeng/primeng';


describe('Return File Parameter Component Test', () => {

    beforeEach(() => {
        TestBed.configureTestingModule({
            declarations: [ReturnFileParameterComponent, HtmlUserFriendlyTimePipe, Html24HourDatePipe, DayOfWeekPipe],
            providers: [
                ...
                ConfirmationService,
                ...
            ],
            imports: [
                ...
                ConfirmDialogModule
            ]
        });
        TestBed.compileComponents();
    });

...

    it('should call add on a new Return File Parameter and submit it to the service', inject(
        [ReturnFileParameterComponent, AuthHelper],
        (component: ReturnFileParameterComponent, authHelper: AuthHelper) => {
            let fixture: ComponentFixture<ReturnFileParameterComponent> =
                getTestBed().createComponent(ReturnFileParameterComponent);

            fixture.componentInstance.ngOnInit()
                .then(fixture.detectChanges)
                .then(function () {
                    let newParam = fixture.componentInstance.add();
                    expect(fixture.componentInstance.selectedParam).toBe(newParam);
                    expect(fixture.componentInstance.editParam).toBe(true);
                });
        })
    );
});

But almost every test fails.
Here is the beginning portion of the template file:
<div class=""ui-grid-row"" id=""return-parameter-table"">
    <h5>Return File Parameters</h5>
    <p-growl [value]=""msgs"" life=""3000""></p-growl>
    <p-confirmDialog header=""Confirmation"" icon=""fa fa-question-circle"" width=""425""></p-confirmDialog>
...

I'm using jasmine-core 2.2.5 with karma 1.4.0 and karma-jasmine 1.1.0. I've seen this issue before without using Karma that was a result of some dependency injection issues, but here I can't quite figure it out since it looks like all the correct dependencies are imported.
I'm running the tests with PhantomJS, but I've also tried Firefox and Chrome to see if it was a browser issue, but the error persists.
So basically I have no idea why its failing the tests but I get absolutely no problems using it in a browser. Any help would be greatly appreciated.",wheelerlaw,NONE,2017-01-23 16:00:18+00:00,True,2017-01-24 23:46:53+00:00,1.32,,2,1,2017-01-24 23:46:53+00:00,1.32,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1263,"Test freezes when fixture.debugElement.query(By.css("".something"")) is checked for null","I have a test that checks if a DOM element has been removed by an ngIf. When I grab the DOM element using: fixture.debugElement.query(By.css("".something"")) the result is either null or a DOM element.
If the result is null, then the following test works fine. But, if the test result contains an element, it doesn't simply fail the test, it freezes up the debug browser.
The test looks like this:
var result = fixture.debugElement.query(By.css(""#something""))
expect(result).toBe(null)  // same goes for .toBeFalsy(), .toEqual(null)
This is not a problem if you use document.getElementById(""something"") to get the element. So the issue seems to be only if you try to check if a fixture element is null when it is not.",egdraper,NONE,2017-01-23 18:53:35+00:00,True,2017-01-24 23:06:33+00:00,1.18,,7,7,2017-01-24 23:06:33+00:00,1.18,slackersoft,MEMBER,2,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1264,Variation on allow reSpy for inheritance,"Our app uses SmartClient which provides a class inheritance system which uses the underlying Javascript inheritance system. The following example is SmartClient-based, but the problem applies more generally, too.
Let's say you have a class isc.ListGrid and a sub-class isc.ListGridPlus.
If you spyOn(isc.ListGrid, 'create') it works. If you then try to spyOn(isc.ListGridPlus, 'create') it fails saying create has already been spied upon. This is because ListGridPlus does not provide its own implementation of create and hence spyOn sees the superclass' spy.
If you want to be able to differentiate between calls made to isc.ListGrid.create and isc.ListGridPlus.create you'd need to do something like:
isc.ListGridPlus.create = jasmine.createSpy('ListGridPlus.create');
However, I wanted to be able to use the idiomatic spyOn, so I made the following patch:
Osirium@ca35330
With the patch if spyOn detects the method it's trying to spyOn is already a spy, instead of outright throwing, it tests to see whether the obj.hasOwnProperty(methodName). If it doesn't, then it creates a dummy function, such that the rest of spyOn can behave as expected.
The one caveat is that you couldn't call .callThrough because the dummy function would not do what you expected. This potentially could be worked around but I thought to keep it simple.
If this patch had associated tests and I raised a PR, would it be something you would consider merging? Or is there a better way of doing this?",edsharp,NONE,2017-01-24 12:58:07+00:00,True,2017-01-25 00:54:39+00:00,0.5,,2,1,2017-01-25 00:54:39+00:00,0.5,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1265,Using --grep will call every defined beforeAll() in your suite/spec,"Hello!
Essentially when users use the --grep option to delineate which tests run (which is a fantastic feature), it will run every beforeAll() in the file where matches are found, resulting in many superfluous beforeAll()s being triggered. This does not happen with beforeEach().
I reported this issue within the Protractor project, but it was tagged as possibly as issue with Jasmine (and not Protractor).
For much more detail (including full code examples), please see the original issue: angular/protractor#3952",wburgess-datical,NONE,2017-01-24 19:25:42+00:00,True,2017-01-24 23:00:03+00:00,0.15,,5,8,2017-01-24 23:00:03+00:00,0.15,slackersoft,MEMBER,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1266,TypeError: jasmine.configureDefaultReporter is not a function,"When trying to configure the default reporter as described in the documentation. Then I get the following error.
npm test

> trying-to-configure-jasmine-default-reporter@0.0.0 test /home/agirorn/tmp/trying-to-configure-jasmine-default-reporter
> jasmine first.spec.js

/home/agirorn/tmp/trying-to-configure-jasmine-default-reporter/first.spec.js:1
(function (exports, require, module, __filename, __dirname) { jasmine.configureDefaultReporter({
                                                                      ^

TypeError: jasmine.configureDefaultReporter is not a function
    at Object.<anonymous> (/home/agirorn/tmp/trying-to-configure-jasmine-default-reporter/first.spec.js:1:71)
    at Module._compile (module.js:409:26)
    at Object.Module._extensions..js (module.js:416:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at /home/agirorn/tmp/trying-to-configure-jasmine-default-reporter/node_modules/jasmine/lib/jasmine.js:87:5
    at Array.forEach (native)
    at Jasmine.loadSpecs (/home/agirorn/tmp/trying-to-configure-jasmine-default-reporter/node_modules/jasmine/lib/jasmine.js:86:18)
npm ERR! Test failed.  See above for more details.
This can be reproduced from this gist: https://gist.github.com/agirorn/2d58eb1c08cbd4837830c3e3cbfa9503
I guess this is either a bug in the documentation of jasmine.",agirorn,NONE,2017-01-27 12:26:03+00:00,True,2017-04-11 17:19:30+00:00,74.2,,2,2,2017-02-15 23:39:14+00:00,19.47,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1267,Jasmine .spec.js files outside the spec directory,"Is it possible to have my .spec.js files outside of the spec directory?
I.E.
/src/thing.model.js
/src/thing.model.spec.js

instead of
/src/thing.model.js
/spec/thing.model.spec.js
```",sgen,NONE,2017-01-30 22:42:04+00:00,True,2017-04-11 17:11:44+00:00,70.77,,3,2,2017-02-01 07:46:38+00:00,1.38,piniu,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1269,Jasmine does not catch error thrown from setImmediate in a Promise.,"When jasmine is run with the spec below it does not detect the failed test and it exits cleanly with an exit code of 0. This has resulted in falls positive test runs.
I ran this on jasmine version 2.5.2 in node.js version 4.5.0 and 6.9.4.
function doIt(callback) {
  return Promise.resolve(true)
    .then(callback)
    .catch((error) => {
      setImmediate(() => {
        throw error;
      });
    });
}

describe('broken', () => {
  it('is broken', (done) => {
    doIt((value) => {
      throw new Error('I am broken!');
    }).then(done).catch(done.fail);
  });
});
I get this output.
➜  bug-in-jasmie ./node_modules/.bin/jasmine
Started
.


1 spec, 0 failures
Finished in 0.005 seconds

➜  bug-in-jasmie echo $?
9
I expected to see this.
➜  bug-in-jasmie ./node_modules/.bin/jasmine
Started
F

Failures:
1) broken is broken
  Message:
    Failed: I am broken!
  Stack:
    Error: I am broken!
        at /home/agirorn/tmp/bug-in-jasmie/spec/broken.spec.js:14:13
        at process._tickCallback (node.js:369:9)
        at Function.Module.runMain (module.js:443:11)
        at startup (node.js:139:18)
        at node.js:974:3

1 spec, 1 failure
Finished in 0.007 seconds

➜  bug-in-jasmie echo $?
1",agirorn,NONE,2017-01-31 12:17:12+00:00,True,2017-02-16 00:24:29+00:00,15.51,,2,1,2017-02-16 00:24:29+00:00,15.51,slackersoft,MEMBER,1,0,0,0,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
1271,trigger jasmine from controller,"I'm trying to trigger jasmine tests from my controller using jasmine-reporter.
the issue is when it finish (btw it finish correctly) the node process exit.
How can i prevent jasmine.execute()  to take the node server down?
i think this repository is more relevant then jasmine-reporters simply because i'm loading the reporter into jasmine - but maybe I'm wrong.
var Jasmine = require('jasmine'),
    reporters = require('jasmine-reporters');
runQaTests: function (req, res, next) {
        var jasmine = new Jasmine();
        var junitReporter = new reporters.JUnitXmlReporter({
            savePath: __dirname+'/../tests/jasmine',
            consolidateAll: true
        });

        jasmine.loadConfigFile(""./spec/support/jasmine.json"");
        jasmine.addReporter(junitReporter);
        jasmine.execute();
        return res.json('trigger qa tests');
    }",piniu,NONE,2017-02-01 08:06:33+00:00,True,2017-03-10 22:25:39+00:00,37.6,,2,2,2017-02-01 10:19:26+00:00,0.09,piniu,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1272,Wrong invocation of a callback,"What version are you using?
I am using jasmine v2.5.3 and jasmine-core v2.5.2.


What environment are you running Jasmine in (node, browser, etc)?
I am using babel-node.


How are you running Jasmine (standalone, npm, karma, etc)?
As far as I know I'm running it standalone.


If possible, include an example spec that demonstrates your issue.
See the repository I created: https://github.com/marco-a/jasmine-bug.


$ npm install
$ npm test
You should see one test failing:

But I'm not even calling the said callback in my second test case!
Also strange: if you comment out some of the tests then it suddenly works again?!
AFAIK the method under test does not have an internal state.
Or am I maybe doing something wrong?",marco-a,NONE,2017-02-01 16:34:10+00:00,True,2017-02-16 19:14:02+00:00,15.11,,2,2,2017-02-01 18:57:18+00:00,0.1,marco-a,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1273,Running jasmine should fail if process.exit is called.,"When running this tests that call process.exit jasmine exits and the exit code is 0 indicating that the test run was successful. This can lead and has lead to false positive test runs.
I would assume that jasmine would exit with an error of some sorts, for example like this.
➜  jasmine-dies-in-the-end git:(master) ✗ ./node_modules/.bin/jasmine kill-jasmine.spec.js
Started
F

Failures:
1) process.kill() should not kill jasmine the test runner
  Message:
    Error: Jasmine was killed by calling (process.exit).
  Stack:
    Error: Jasmine was killed by calling (process.exit).
        at process.exit (/home/agirorn/tmp/jasmine-dies-in-the-end/kill-jasmine.spec.js:6:37)
        at doSomethingThatCallsProcessKillZero (/home/agirorn/tmp/jasmine-dies-in-the-end/kill-jasmine.spec.js:2:11)
        at Object.<anonymous> (/home/agirorn/tmp/jasmine-dies-in-the-end/kill-jasmine.spec.js:8:20)

1 spec, 1 failure
Finished in 0.005 seconds
And have a none 0 exit code.
Example code to reproduce.
function doSomethingThatCallsProcessKillZero() {
  process.exit();
}

describe('kill jasmine', () => {
  it('should not kill jasmine the test runner', () => {
    const result = doSomethingThatCallsProcessKillZero();
    expect(false).toBeTruthy();
  });
});
Result from Running in node 4.5.0
➜  jasmine-dies-in-the-end git:(master) ✗ ./node_modules/.bin/jasmine kill-jasmine.spec.js
Started",agirorn,NONE,2017-02-02 16:14:48+00:00,True,2017-03-14 23:58:37+00:00,40.32,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1274,How to pass parameters to beforeEach / afterEach?,"Is there a way to parameterize beforeEach / afterEach calls?
It is a common scenario for me to have multiple tests share same initialization code with some minor difference, e.g.:
it('test default', () => {
  this.myObj = createObj('default');
  // perform some test on myObj
});
it('other test for default', () => {
  this.myObj = createObj('default');
  // perform some other test on myObj
});
it('test foo', () => {
  this.myObj = createObj('foo');
  // perform some test on myObj
});
Is there a way to extract common logic to beforeEach and express parameters in test declaration? Something like that can be achieved in at least one framework I'm aware of (Java+TestNG). Here it could be something like:
beforeEach((name = 'default') => {
  this.myObj = createObj(name);
});
it('test default', () => {
  // perform some test on myObj
});
it('other test for default', () => {
  // perform some other test on myObj
});
it('test foo', 'foo', () => {
  // perform some test on myObj
});",tomkur,NONE,2017-02-07 09:43:43+00:00,True,2017-02-16 17:53:22+00:00,9.34,,3,3,2017-02-16 17:53:22+00:00,9.34,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1276,i18n of Jasmine API,"We're writing Dutch descriptions in our specs, and using Dutch names in our code. This makes it feel it bit 'off' that the functions describe and it are in English. To work around this, we've added some aliases to our test config:
var beschrijf = describe;
var het = it;

Now our specs read like a story in Dutch:
// ...

beschrijf(""Mijn Component"", () => {

	het(""opent een modal"", () => {
		comp.klikOpModalLink();
		expect(comp.isModalOpen()).toBe(true);
	});

	het(""valideert de invoer"", () => {
		comp.vulIn("""");
		expect(comp.getFoutmelding()).toBe(""Verplicht"");
	});

	// etc..
});

Notice that we didn't translate expect or toBe: we would have loved to have done so, but it was simply too much work.
Things got a little more complicated when we put our tests in TypeScript and had to declare our aliases:
declare function beschrijf(description: string, specDefinitions: () => void): void;
declare function het(expectation: string, assertion?: (done: DoneFn) => void, timeout?: number): void;
I was wondering whether it might be an interesting feature for the Jasmine framework itself to support i18n of its API, so that this scenario is supported out of the box.",RomkeVdMeulen,NONE,2017-02-10 13:56:39+00:00,True,2017-02-13 18:05:51+00:00,3.17,,2,1,2017-02-13 18:05:51+00:00,3.17,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1277,Expect message ,"JASMINE 2.4.1
expect(someValue).toBe(otherValue);
It does not show the detail message.
Currently, it just says expected false to be true and it spits out bunch of file references like below:
buildExpectationResult@file:/// ..., expectationResultFactory@file:... , addExpectationResult@file:///C:/Users/, addExpectationResult@file://... in ..file (line 52)
I think it should just show that test case failed message and why it failed. I am not sure why it is showing other 3 files names and its locaitons ?",rupeshtiwari,NONE,2017-02-10 17:31:33+00:00,True,2017-04-11 17:21:05+00:00,59.99,,2,2,2017-02-16 00:29:41+00:00,5.29,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1278,.toThrow() matcher with context argument,"Hey, I'd like to know if it is possible to add some context into .toThrow() matcher, just like the second argument in .toBe() or simmilar matcher:
expect(1).toBe(2, 'Reason-why-test-failed')
I don't want to specify what kind of error am I getting, just that I got some error.
Thanks.",iFarmGolems,NONE,2017-02-15 08:56:42+00:00,True,2017-04-11 17:31:39+00:00,55.36,,2,2,2017-02-16 01:15:05+00:00,0.68,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1279,Some URLs from the documentation are invalid,"Example:
https://jasmine.github.io/2.5/introduction#section-Spies:_and.callFake
Characters < and > are not valid and should be escaped.
See What characters are valid in a URL?",tkrotoff,CONTRIBUTOR,2017-02-19 23:16:12+00:00,True,2019-02-22 01:24:56+00:00,732.09,,2,2,2017-03-11 00:16:42+00:00,19.04,slackersoft,MEMBER,1,0,0,0,"['docs', 'ready for work']",False,False,False,False,False,False,False,True,False,True,False,False,False,False,False
1280,  Error: (SystemJS) Can't find variable: jasmineRequire,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine (Jasmine npm, karma, etc),
consider filing an issue with that library if appropriate

When submitting an issue, please answer the following:

What version are you using? 3.10.3
What environment are you running Jasmine in (node, browser, etc)? node
How are you running Jasmine (standalone, npm, karma, etc)? karma
If possible, include an example spec that demonstrates your issue.
describe('Work Karma Jasmine FrameWork', function () { it('true is true', function () { expect('Hello World for Karma and Jasmine FrameWork').toBe('Hello World for Karma and Jasmine FrameWork'); }); }); //# sourceMappingURL=work-karma-jasmine.spec.js.map

When I try to run the tests with karma get
PhantomJS 2.1.1 (Mac OS X 0.0.0) ERROR
Error: (SystemJS) Can't find variable: jasmineRequire
eval code
eval@[native code]
F@http://localhost:9878node_modules/systemjs/dist/system-polyfills.js:4:12217
H@http://localhost:9878node_modules/systemjs/dist/system-polyfills.js:4:11846
when@http://localhost:9878node_modules/systemjs/dist/system-polyfills.js:4:15520
run@http://localhost:9878node_modules/systemjs/dist/system-polyfills.js:4:14559
_drain@http://localhost:9878node_modules/systemjs/dist/system-polyfills.js:4:3250
drain@http://localhost:9878node_modules/systemjs/dist/system-polyfills.js:4:1667
Evaluating http://localhost:9878node_modules/karma-jasmine/lib/boot.js
Error loading http://localhost:9878node_modules/karma-jasmine/lib/boot.js

i try include directorios of lib in file config karma => `// Karma configuration
// Generated on Fri Feb 17 2017 14:46:21 GMT-0500 (COT)
module.exports = function (config) {
config.set({
    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    frameworks: ['jasmine', 'systemjs'],

    // list of files / patterns to load in the browser
    files: [
        'node_modules/jasmine-core/**/*.js',

        'app/built/!**!/!*spec.js',
         'app/built/!*spec.js',
         'app/built/!**!/!*spec.map.js',
         'app/built/!*spec.map.js'

    ],


    // list of files to exclude
    exclude: [],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    preprocessors: {},


    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    reporters: ['progress'],


    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,


    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['PhantomJS', 'PhantomJS_custom'],

    customLaunchers: {
        'PhantomJS_custom': {
            base: 'PhantomJS',
            options: {
                windowName: 'my-window',
                settings: {
                    webSecurityEnabled: false
                },
            },
            flags: ['--load-images=true'],
            debug: true
        }
    },

    phantomjsLauncher: {
        // Have phantomjs exit if a ResourceError is encountered (useful if karma exits without killing phantom)
        exitOnResourceError: true
    },
    // plugin
    plugins: ['karma-systemjs', 'karma-jasmine', 'karma-phantomjs-launcher'],

    // systemjs config
    systemjs: {
        // Path to your SystemJS configuration file
        configFile: 'systemjs.config.js',

        // Patterns for files that you want Karma to make available, but not loaded until a module requests them. eg. Third-party libraries.
        serveFiles: [
            'public/**/*.js',
            'node_modules/jasmine-core/lib/jasmine-core.js'


        ],

    },

    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: false,

    // Concurrency level
    // how many browser should be started simultaneous
    concurrency: Infinity
})

}
`
but not working please help me.",ahelord,NONE,2017-02-20 19:38:14+00:00,True,2017-02-20 21:04:09+00:00,0.06,,2,1,2017-02-20 21:04:09+00:00,0.06,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1281,Allow to manually destroy a spy,"Following the discussion on Google Groups: https://groups.google.com/forum/#!topic/jasmine-js/0RXvFo707EQ, I think my usecase is valid.
Jasmine does not allow to manually delete/destroy a spy and this is limiting.
function signIn(done) {
  ...
  // Fails the 2x time with ""<spyOn> : bar has already been spied upon""
  const mySpy = spyOn(foo, 'bar').and.callThrough();
  ...
  expect(foo.bar).toHaveBeenCalledTimes(1);

  // Jasmine missing feature:
  //mySpy.destroy();
}

function signOut(done) {
  ...
}

it('should be able to sign in/sign out multiple times', done => {
  signIn(() => {
    signOut(() => {
      signIn(() => { // Fails with ""<spyOn> : bar has already been spied upon""
        done();
      });
    });
  });
});
signIn, signOut... are bricks (i.e simple functions - not Jasmine tests) that are reused to write complex Jasmine test scenarios like:

signIn, doSomething1, signOut
signIn, doSomething1, doSomething2, doSomething3, signOut
signIn, signOut, signIn, signOut, signIn, signOut

Remarks:

Currently the second signIn call fails with <spyOn> : bar has already been spied upon
I cannot make spyOn global otherwise error Spies must be created in a before function or a spec
Adding beforeEach(()=> { spyOn(foo, 'bar').and.callThrough(); }) is not the solution because expect(foo.bar).toHaveBeenCalledTimes(1) will fail with the 2x signIn call (because .toHaveBeenCalledTimes(2))",tkrotoff,CONTRIBUTOR,2017-02-24 09:54:47+00:00,False,,,,13,24,2017-02-28 00:22:06+00:00,3.6,tkrotoff,CONTRIBUTOR,1,2,0,10,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1282,jasmine.clock and setTimeout inside nested promises,"How to use jasmine.clock setTimeout mock inside nested promises? (result: Error: jasmine.DEFAULT_TIMEOUT_INTERVAL)
Order is crucial here.
I need to test nested promises that must have setTimeout inside - order matters. I know that then is kind of process.nextTick (or setImmediate) and it goes beyond current event loop (which is the core problem here) but this knowledge does not solve the problem :)
I know that I can put jasmine.clock().tick() inside nested promise but this is pointless because I'm testing proper order in some events related lib.
How to test something like this in jasmine? any ideas?
It looks like jamine.clock().tick(...) have a sync nature but promises are async. So we are hitting a wall here?
it(""should run setTimeout mock inside chained promises"",(done)=>{

      jasmine.clock().install();

      let realOrder = [];

      let ok1=new Promise((resolve,reject)=>{
          resolve(""ok"");
      }).then((ok)=>{
        let p=new Promise((resolve,reject)=>{
          setTimeout(()=>{ // not fired up due to 'then' method
            realOrder.push(""1"");
            resolve(""1"");
          },100);
        });
        //jasmine.clock().tick(101); //<- order is crucial here so I can't do that
        return p;
      });

      let ok2=new Promise((resolve,reject)=>{
          resolve(""ok"");
      }).then((ok)=>{
        let p=new Promise((resolve,reject)=>{
          setTimeout(()=>{ // not fired up due to 'then' method
            realOrder.push(""2"");
            resolve(""2"");
          },50);
        });
        //jasmine.clock().tick(51); //<- order is crucial here so I can't do that
        return p;
      });

      jasmine.clock().tick(151);// we must go outside nested promise - we dont need to run tick inplace because order will change
      Promise.all([ok1,ok2]).then((results)=>{
        expect(results).toEqual([""1"",""2""]);
        expect(realOrder).toEqual([""2"",""1""]);
        done();
      });
  });",camel-chased,NONE,2017-02-24 19:44:56+00:00,True,2017-02-24 21:34:32+00:00,0.08,,2,3,2017-02-24 21:34:32+00:00,0.08,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1284,Start and stop the test manually in browser,"Expected behavior:

Start test manually: When I open the test runner web page in a browser, it shows all the suites and cases. Actually now it executes all of cases immediately on the page load.
Stop test manually: There is a ""stop"" button when I click it stop the test immediately. Actually now I cannot stop test unless I close the browser.

Environment


What version are you using?
2.5.2


What environment are you running Jasmine in (node, browser, etc)?
Browser.


How are you running Jasmine (standalone, npm, karma, etc)?
Standalone",skyshore2001,NONE,2017-03-02 02:40:38+00:00,True,2017-03-14 22:02:51+00:00,12.81,,2,2,2017-03-03 05:04:07+00:00,1.1,skyshore2001,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1285,Cannot show test progress in the browser,"Problem
I use jasmine 2.5.2 to test my back-end web APIs via ajax sync call in each ""it"" block.
When the test starts, the browser enters no response status with blank screen.
As the tests last long time, I want the progress feedback (result like "".""/""X""/""*"" shows after each case completes) and a manual stop-test feature (see #1284)
I don't want to write the cases in async mode as it makes code complex.
Environment


What version are you using?
2.5.2


What environment are you running Jasmine in (node, browser, etc)?
Browser.


How are you running Jasmine (standalone, npm, karma, etc)?
Standalone",skyshore2001,NONE,2017-03-02 02:53:59+00:00,True,2017-03-14 21:34:14+00:00,12.78,,2,1,2017-03-14 21:34:14+00:00,12.78,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1286,Spec is called before async beforeAll calls done,"Hello,
i am very new to Jasmine and all this stuff, so it is my first angular app at all. My application is an angular 2 app.
Everything is installed via npm.
Tests running in browser.
I use Karma as test runner.
Versions:
Jasmine: 2.4.1
Karma: 1.5.0
Chrome: 56.0.2924
OS:  Mac OS X 10.12.3
The Problem:
I created a suite, as follows:
describe('Service with asyncCall', function() {
        beforeAll(function(done) {
            new Service().asyncCall().then(function(result) {
                        console.log(result);
                        done();
                    }
                );
            }
        );

        it(
            'should be true',
            function() {
                console.log('test');
                expect(true).toEqual(true);
            }
        );
}

The asyncCall is as follows:
asyncCall() {
    var out = new Promise(
       function (resolve) {
            setTimeout(
                function() {
                    resolve('success');
                },
                2000
            );
        }
    );

    return out;
}

I expect the output to be something like
...
success
test
...

But the actual output in the Browser console is
test
success

Also the test is failing with the following message(s)
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.

Please can anybody help me out, or pointing in the right direction.
And sorry for my english is not so well...
Thank you.",neurospective,NONE,2017-03-03 10:11:06+00:00,True,2017-03-03 19:25:09+00:00,0.38,,1,1,2017-03-03 19:25:00+00:00,0.38,neurospective,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1287,"Message set with ""fail()"" can leak into following ""it()""","A message set with ""fail()"" can leak into following ""it()"" if an async method is mistakenly called by user (e.g., if one is not aware some 3rd party callback is async).
Happens with ""fail()"" messages only, not with ""expect()"" messages.
https://plnkr.co/edit/qfZCXMBM8IiA2AsvQwGu
The spec is also included below.
When submitting an issue, please answer the following:


What version are you using?
2.5.2


What environment are you running Jasmine in (node, browser, etc)?


How are you running Jasmine (standalone, npm, karma, etc)? standalone
https://plnkr.co/edit/qfZCXMBM8IiA2AsvQwGu demonstrates it in browser environment.
Plunkr shows same results for FireFox/Chrome/Safari.
describe('Jasmine message leak demo.', () => {

   // Oops - I am doing async but forgot ""done"".  My bad.
   it('This will unintentionally pass, and leak its fail.', () => {
       setTimeout(() => {
           fail('I am in your test!');
       }, 1000);
       expect(true);
   });

   // Should error on
   //     'Async callback was not invoked within timeout
   //      specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.'
   // Instead, it reports the fail message
   //     'I am in your test!'
   it('This will fail, but with wrong message.', (done) => {
       let rememberToCallDone = false;
       if (rememberToCallDone) {
           done();
       }
   });

   // Same code as previous ""it()"", but now this one behaves correctly:
   // It errors on
   //     'Async callback was not invoked within timeout
   //      specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.'
   it('This will fail, but with correct message.', (done) => {
       let rememberToCallDone = false;
       if (rememberToCallDone) {
           done();
       }
   });

   // Nothing leaks into here.  Behaves as expected.
   it('This will pass.', () => {
       expect(true);
   });

   // Nothing leaks into here.  Behaves as expected.
   it('This will pass.', (done) => {
       expect(true);
       done();
   });
 });



Thank you for this great library.",johncvrs,NONE,2017-03-03 16:24:40+00:00,True,2017-03-15 18:27:41+00:00,12.09,,2,2,2017-03-15 18:27:41+00:00,12.09,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1288,Jasmine hangs for a few min when trying to assert an object with circular reference,"Current behavior
There's a data structure DebugElement (wrapper around a native element with additional info useful for debugging). When you test to see if DebugElement doesn't exists expect(de).toBeFalsy() browser hangs for a few mins (as far as I understand Jasmine will keep cycling with a circular reference as it tries to print out the DebugElement to compare it to false).
Expected behavior
Should take a reasonable amount of time to execute the test.
Can it be addressed somehow inside Jasmine or should I change DebugElement impl?
Minimal reproduction of the problem with instructions
https://plnkr.co/edit/GGECfSqptOXadysFDUh6?p=preview",DzmitryShylovich,NONE,2017-03-03 20:07:35+00:00,True,2017-03-10 22:35:03+00:00,7.1,,2,2,2017-03-10 22:20:06+00:00,7.09,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1290,How to load jasmine into browser with installed by npm?,"I just want to load jasmine into browser with installed by npm, no using bundlers like webpack or browserify. I downloaded jasmine from npm, but it fails run from browser with:
Uncaught ReferenceError: require is not defined
    at jasmine.js:1
Looks like jasmine installed via npm is just working with node.js, not for browser :(
I hate download javascript library from website and put them inside of project, I prefer download module from npm directly, so I can easily install it just run 'npm install', and also I can easily update with 'npm update'.
If I use bundler, it will resolves this problem, but I want to write testing code directly, without bundling. So, is there a way to using jasmine from npm to browser directly? Also do you have a plan to support UMD? Thanks!",rico345100,NONE,2017-03-07 06:28:27+00:00,True,2017-03-09 20:21:39+00:00,2.58,,2,2,2017-03-07 14:55:09+00:00,0.35,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1291,toHaveBeenCalledWith() crashes test environment when matching large objects,"Problem:
toHaveBeenCalledWith() matcher with large objects
Outcome:
crashes the entire environment (PhantomJS) or runs recursively (Chrome).
Workaround
create a custom equality tester (jasmine.addCustomEqualityTester) before ""toHaveBeenCalledWith()"" is called. This leads to the EqualityTester failing rather than the environment crashing :)
Setup:

Angular2
Jasmine 2.5.2

Example:
Some sort of injectable service
@Injectable()
class EventService {
    broadcast(name: string, ...args: any[]) {
		//do something
	}
}

A big/complex object to match like an Angular component
class Angular2Component {

	someFunction() {
		injectedEventService.broadcast(""myEventName"", this);	//this being the component itself
	}

}

Now the Test
describe(() => {

    it(""myTest"", inject([EventService], (eventService: EventService) => {
	
		spyOn(eventService, ""broadcast"");
		//createComponent
		component.someFunction();
		
		expect(eventService.broadcast).toHaveBeenCalled(); // true

		// When the second argument isn't passed, the equlity matcher crashes the 
                // environment
		expect(eventService.broadcast).toHaveBeenCalledWith(""myEventName"")
	
                // Also crashes the environment when the argument amount is correct but one value is
                // not correct
                expect(eventService.broadcast).toHaveBeenCalledWith(""someOtherEventName"", jasmine.any(Angular2Component));

	}));

})",smasala,NONE,2017-03-10 16:00:06+00:00,True,2017-06-14 20:36:46+00:00,96.19,,5,15,2017-03-10 16:11:30+00:00,0.01,smasala,NONE,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1292,TypeError: this.expectationResultFactory is not a function,"Jasmine-core 2.5.2

The following is the test I am running:
/// <reference path=""visualize.page.ts"" />
/// <reference path=""../../reference.d.ts"" />

import { CommonPageItems } from '../../../../test/e2e/common.page'
import { NewVisualizationView } from './visualize.page'
import { ListView } from '../../../../test/e2e/listView.page'

let common = new CommonPageItems()
let vizList = new ListView()
let vizPage = new NewVisualizationView()

describe('create visualizations', () => {
    /**
     * Create Visualizations Test Suite
     */

    beforeAll(() => {
        vizPage.navigateToApp()
    })

    afterAll(() => {
        common.signOut()
    })

    beforeEach(() => {
        vizPage.newViz()
    })

    it('bar chart - additional config', () => {
        vizPage.chooseChart('bar')
        expect(vizPage.additionalConfigAlert.getText()).toMatch('Bar chart needs at least 1 measure and 0 breakdowns.')
        vizPage.returnToVizListView()
    })
})

I run the following command to get this run:
gulp e2e --suite visualize --baseUrl <a URL goes here>
The test runs and passes however the browser session never closes and I get the following error:
<REST OF PATH>/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2219
      this.result.failedExpectations.push(this.expectationResultFactory(data));
                                               ^
TypeError: this.expectationResultFactory is not a function
    at Suite.onException (/Users/curtissalisbury/src/github.com/artemishealth/artemis-app/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2219:48)
    at QueueRunner.onException (/Users/curtissalisbury/src/github.com/artemishealth/artemis-app/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2330:28)
    at onException (/Users/curtissalisbury/src/github.com/artemishealth/artemis-app/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1924:12)
    at Timeout._onTimeout (/Users/curtissalisbury/src/github.com/artemishealth/artemis-app/node_modules/jasmine/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1910:11)
    at tryOnTimeout (timers.js:232:11)
    at Timer.listOnTimeout (timers.js:202:5)

This was literally working yesterday and this morning I come in and I am getting the above mess.
Thanks for using Jasmine!",DarthOpto,NONE,2017-03-15 15:49:39+00:00,True,2017-03-15 18:16:52+00:00,0.1,,2,3,2017-03-15 17:18:26+00:00,0.06,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1293,use async7await on the tests ,"Hi, i`m trying to implement a test for my postman library but i need use async/await to do this. The problem is that if I put the done parameter in the test method I got this:
(node:3253) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error
But, If I remove the parameter the test passes but don't execute the ajax call. That is the code:
it('Basic test', async function (done) {
    let data;
    try {
      data = await this.actionwords.thePostmanTestIsExecuted(""Login"").catch(error=> {throw new Error(error)});
    } catch(error){
        expect(error.error).toBe(null);
    }
    try {
      data = await this.actionwords.aResponseIsReceived(data).catch(error=> {throw new Error(error)});
      
      expect(data.data).not.toBe(null);
      expect(data.data.length).toBeGreaterThan(0);
      expect(data.error).toBe(null).or.toBe(undefined);        
    } catch(error) {
        expect(error.error).toBe(null);
    }
    try {
      Promise.all(done).catch(error=>{ throw Error(error); }).catch(error=>{ throw Error(error); });
    } catch(error) {
       expect(error.error).toBe(null);
    }
  });

How can I do this test execute properly using async/await?",thiagohora,NONE,2017-03-16 09:34:29+00:00,True,2017-03-16 16:35:55+00:00,0.29,,2,1,2017-03-16 16:35:55+00:00,0.29,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1294,What about including Infinity methods?,"I am thinking about two methods like toBeInfinity(), toBeNegativeInfinity().
Of course one could argue that we could work around this issue with toEqual(Infinity), but then I would reply ""what is then the purpose of toBeNaN() method?"".
For a visual example, you can refer to https://github.com/mhevery/jasmine-node/pull/415/files.",thodorisbais,CONTRIBUTOR,2017-03-18 23:54:42+00:00,True,2017-04-08 00:43:12+00:00,20.03,,2,2,2017-03-24 00:43:07+00:00,5.03,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1295,Feature Request: Nested 'it' blocks should throw a useful error,"Version 2.5.3 and previous, all environments.
Nested it blocks are unsupported and meaningless, but sometimes test writers mess up and make them anyway (for example, if they have helper functions). It would be nice if Jasmine threw an error when this happens, instead of silently passing. For example, something like:
describe('nested its', function() {
  it('should throw some sort of error', function() {
    it('erroneous nested it', function() {
      expect(true).toEqual(false);
    });
  });
});
Should throw something like unexpected ""it"" statement inside a test.",juliemr,NONE,2017-03-22 04:15:32+00:00,True,2018-01-25 04:18:25+00:00,309.0,,5,5,2017-03-24 00:44:34+00:00,1.85,slackersoft,MEMBER,2,1,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1296,Spying on ES module properties,I'm using webpack 2 with babel to transpile my code. With webpack 1 it was possible to spy on module properties since import/export were converted to CommonJS but webpack 2 is now compliant with the ES standard. Which means I can no longer spy on a module property because the module is frozen. Does jasmine provides a way to spy on module properties? Or is there a workaround for this?,bensampaio,NONE,2017-03-22 13:43:43+00:00,True,2017-04-11 17:28:00+00:00,20.16,,3,2,2017-04-11 14:50:20+00:00,20.05,senyaak,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1297,jasmine.DEFAULT_TIMEOUT_INTERVAL at odds with actual execution times,"What version are you using? 2.5.2
What environment are you running Jasmine in (node, browser, etc)? node
How are you running Jasmine (standalone, npm, karma, etc)? gulp-wdio (so WebdriverIO using Jasmine as the test runner)

This is not a blocking issue for me at all - I've learned that the jasmine.DEFAULT_TIMEOUT_INTERVAL needs to be set fairly high for web UI tests. What has me curious, though, is that the run times I see in my console don't seem to have much relation to my configured timeout, and that makes it hard for me to understand (and communicate to others) what exactly is going wrong when I get timeout errors. To illustrate: Here is a jasmine.DEFAULT_TIMEOUT_INTERVAL failure where the timeout was set to 20000.

So for a 20 second timeout:

The test itself had a 28 second runtime.
The suite had a 43 second runtime.
The entire command (using time to measure) had a 49 second runtime.

So some questions arise:

What exactly is jasmine.DEFAULT_TIMEOUT_INTERVAL measuring?
At what point does it start waiting and counting to 20000 (or whatever one has configured the timeout to be)?

I'm open to the possibility that the webdriverio context might be muddying the waters here, but it at least seems like it's related to jasmine itself so I wanted to start here.",TheMetalCode,NONE,2017-03-23 22:32:15+00:00,True,2017-03-24 16:34:35+00:00,0.75,,2,2,2017-03-23 23:59:41+00:00,0.06,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1299,Add `console.time` and `console.timeEnd` support to `jasmine.clock`,"I wrote a util that wraps console's time and timeEnd methods (https://developer.mozilla.org/en-US/docs/Web/API/console#Timers), and is able to calculate averages across multiple calls, etc...
But I'm getting brittle test results even when using combinations of .toBeGreaterThan and .toBeLessThan, because I can't account for large fluctuations of test execution time...
It would be great to be able to ""mock"" these console methods much like we currently can setTimeout.
It seems they're standard, and so would not be subject to the same requirements as #866 ?",nemoDreamer,NONE,2017-03-24 20:44:25+00:00,True,2017-03-30 14:38:34+00:00,5.75,,2,5,2017-03-29 23:33:29+00:00,5.12,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1302,Please release new NPM including spyOnProperty,See also #1008,StefH,NONE,2017-03-27 12:36:12+00:00,True,2017-04-24 21:03:48+00:00,28.35,,2,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1303,Two questions regarding code implementation.,"Hi,
In toBeFasly.js:
return {
    pass: !!!actual
};

Is it just a personal style or there is a deep reason to use !!! instead of one !?
In toBeDefined.js:
return {
    pass: (void 0 !== actual)
};

Is it just a personal style or there is a deep reason to use void 0 instead of undefined?",,NONE,2017-03-31 01:08:19+00:00,True,2017-04-08 00:48:44+00:00,7.99,,1,1,2017-04-08 00:48:44+00:00,7.99,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1305,What about having something like an overloaded method of toBeCloseTo() for cases with a precision value of 0?,"For example, the following toBeCloseTo(1.17, 0) would be more readable (imho) if it was just toBeCloseTo(1.17), because method's name itself declares that it's not an actual equality, but an ""almost equal"". Having that said, the method's precision argument is only useful for cases that the user has the need to explicitly declare the amount of decimal points to be checked for possible equality.",thodorisbais,CONTRIBUTOR,2017-03-31 17:11:51+00:00,True,2017-04-08 00:52:04+00:00,7.32,,2,1,2017-04-08 00:52:04+00:00,7.32,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1306,createSpyObj() with a return value for each spy method,"I use Jasmine to mock a lot of AngularJS services that return promises. For this purpose, I'd like to use the createSpyObj method and have a certain return value for each. For example:
var UserService  = jasmine.createSpyObj('UserService', ['query', 'get', 'post', 'remove', 'put'])
.and.returnValue(new Promise())

However, Jasmine does not allow me to tack on .and.returnValue at the end of this function call. It throws an error. As a result, I'm stuck writing this significantly more verbose syntax:
var UserService = {
   query: jasmine.createSpy('query').and.returnValue(new Promise()),
   get: jasmine.createSpy('get').and.returnValue(new Promise()),
   post: jasmine.createSpy('post').and.returnValue(new Promise()),
   delete: jasmine.createSpy('delete').and.returnValue(new Promise()),
   put: jasmine.createSpy('put').and.returnValue(new Promise()),
}

Is there any way I can, by default, return a specific value for every method created by a createSpyObj factory?
Additional info:

What version are you using? Jasmine 2.4
What environment are you running Jasmine in (node, browser, etc)? Browser
How are you running Jasmine (standalone, npm, karma, etc)? Chutzpah for Visual Studio",jongunter,NONE,2017-03-31 22:16:00+00:00,True,2017-04-10 14:39:39+00:00,9.68,,5,8,2017-04-08 00:32:26+00:00,7.09,slackersoft,MEMBER,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1307,.clock().mockDate() is one month off,"When I use mockDate() to simulate a specific date it's a month off...
    xit(""cookie_expiration() is 30 days out"", function () {
        console.info(new Date()); // Fri Mar 31 2017 16:21:28 GMT-0700 (PDT)
        var baseTime = new Date(2016, 10, 1, 0, 0, 0, 0);
        jasmine.clock().mockDate(baseTime);
        console.info( new Date() ); // Tue Nov 01 2016 00:00:00 GMT-0700 (PDT)
       ...
    });



What version are you using?
2.5.3


What environment are you running Jasmine in (node, browser, etc)?
node (unit test)


How are you running Jasmine (standalone, npm, karma, etc)?
karma",emersonthis,NONE,2017-03-31 23:22:39+00:00,True,2017-04-03 22:46:40+00:00,2.98,,2,1,2017-04-03 22:46:40+00:00,2.98,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1308,Test Category or Attribute for Jasmine Tests,"Is there a way to add Test Category or attribute like Nunit test framework in Jasmine?
We have a lot of specs and would like an ability to mark flaky tests and run them in separate suite.

What version are you using? 2.0
What environment are you running Jasmine in (node, browser, etc)? Node.Js
How are you running Jasmine (standalone, npm, karma, etc)? Standalone -Protractor test
If possible, include an example spec that demonstrates your issue.",sharvarik,NONE,2017-04-06 10:41:47+00:00,True,2017-07-26 00:43:11+00:00,110.58,,2,2,2017-04-10 20:59:42+00:00,4.43,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1309,"expect(spy) Causes Error While expect(obj[""functionName""]) Functions as Expected","I'm running Jasmine npm 2.5.3, and running the unit test via a web browser.  The Spec Runner is testing multiple JS files, and when I run all tests, I get a test that fails, that shows the name of the test being in a completely different file, than the stack trace shown.
Here is the code from the stack trace:

It is failing on this
expect(get).toHaveBeenCalledTimes(expectedCalls);
line.
If I run either test one at a time, no issues.  I did figure out that if I change the line that is in error to not reference the spy directly, there are no issues:
expect(webApi[spyFunctionName]).toHaveBeenCalledTimes(expectedCalls);
I would have thought that expect(get) and expect(webApi[spyFunctionName])) would have been equivalent in this case.
Am I not understanding how spies work, or did I stumble onto a bug?
Here is the stack trace in case it is helpful:
Expected spy GetList to have been called 0 times. It was called 1 times.
    at stack (http://localhost:1130/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1640:17)
    at buildExpectationResult (http://localhost:1130/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1610:14)
    at Spec.expectationResultFactory (http://localhost:1130/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:655:18)
    at Spec.addExpectationResult (http://localhost:1130/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:342:34)
    at Expectation.addExpectationResult (http://localhost:1130/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:599:21)
    at Expectation.toHaveBeenCalledTimes (http://localhost:1130/node_modules/jasmine-core/lib/jasmine-core/jasmine.js:1564:12)
    at http://localhost:1130/test/spec/Allgnt.RestLibSpec.js:166:34",daryllabar,NONE,2017-04-07 03:06:26+00:00,True,2017-04-11 02:00:59+00:00,3.95,,2,2,2017-04-10 21:10:25+00:00,3.75,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1310,Does beforeAll and afterAll support 'done' callback ?,"Hi All,
I have read that beforeEach and afterEach in Jasmine supports done callbacks for asynchronous code the same way as it.Is done callback supported in beforeAll and afterAll too ?
Regards,
Kunal",kunalshokeen,NONE,2017-04-07 06:09:49+00:00,True,2017-04-08 00:23:12+00:00,0.76,,2,1,2017-04-08 00:23:12+00:00,0.76,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1311,After hooks fire in an inconsistent order.,"Are you creating an issue in the correct repository?
I think so 🤔 .
When submitting an issue, please answer the following:

What version are you using? 2.5.3
What environment are you running Jasmine in (node, browser, etc)? node v4.6.2
How are you running Jasmine (standalone, npm, karma, etc)? jasmine ./path/to/spec.js
If possible, include an example spec that demonstrates your issue. See below.

Given the following test file
describe('stuff', function() {
  beforeAll(console.log.bind(null, 'beforeAll1'));
  beforeAll(console.log.bind(null, 'beforeAll1'));

  beforeEach(console.log.bind(null, 'beforeEach1'));
  beforeEach(console.log.bind(null, 'beforeEach2'));

  afterEach(console.log.bind(null, 'afterEach1'));
  afterEach(console.log.bind(null, 'afterEach2'));

  afterAll(console.log.bind(null, 'afterAll1'));
  afterAll(console.log.bind(null, 'afterAll2'));

  it('should pass', console.log.bind(null, 'test'));
});
I get the following output:
❯ jasmine ./test/what_spec.js --silent
Started
beforeAll1
beforeAll1
beforeEach1
beforeEach2
test
afterEach2
afterEach1
.afterAll1
afterAll2

Note that afterEach gets its order reversed while afterAll does not.
Personally I'd like to see neither of them reversed, but that doesn't matter as much as consistency.  I found this while working on a tool that helps automate some setup/teardown, and noticed that the teardown was happening in the wrong order.",gdborton,CONTRIBUTOR,2017-04-08 01:41:00+00:00,True,2017-04-10 20:37:27+00:00,2.79,,2,3,2017-04-08 02:45:53+00:00,0.05,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1313,stopSpecOnExpectationFailure not work as expected,"I am using Webdriver with JasmineJs. In WDIO configuration I have set
jasmineNodeOpts: {
    stopSpecOnExpectationFailure: true
  },

I am expecting that in that test case:
describe('Log to the site', () => {
 
  it('authorize', () => {
    //some webdriver steps
  });

  it('go to other site', () => {
      //some webdriver steps
  });
});

When my steps in authorize it failed, my tests not go to next it , but continue executing next describe.
I am right?",netmajor,NONE,2017-04-11 11:55:53+00:00,True,2017-07-26 00:44:12+00:00,105.53,,2,4,2017-04-11 13:54:15+00:00,0.08,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1314,Mocks' toHaveBeenCalledWith method behaves incorrectly with promise arguments,"Calling a mock with a promise will make any later assertions on that mock's calls with other promises it was not called with fail.
In other words, calling a mock with a promise will make that mock behave as if it were called with any other promises, even when it was not called with another promise.

jasmine and jasmine-core version 2.5.2
Running with Karma through Chrome 56.0.2924.87

Failing reproduction spec:
    it('verifies a method was not called with promise2 as a parameter', () => {
        const promise1 = new Promise(resolve => resolve({
            data: 'foo'
        }))
        const promise2 = new Promise(resolve => resolve({
            data: 'bar'
        }))

        const someMock = jasmine.createSpy('something')
        someMock(promise1)

        expect(someMock).not.toHaveBeenCalledWith(promise2)
    })

In Chrome, running promise1 === promise2 and promise1 == promise2 returns false for both cases.
Please let me know if additional info would help :)",austinmckinley,NONE,2017-04-12 22:07:05+00:00,True,2017-11-03 00:18:32+00:00,204.09,,2,1,2017-04-14 21:02:17+00:00,1.96,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1315,Really Important Question.,"Hi I am new to jasmine and javascript in general,
i know i should have asked this question on stackoverflow, but i think this is the right place , as i have tried stackoverflow.
the question is .
in a spec , e.g in the it function , if i have a promise that gets rejected.
can i return a pending on this. e.g
describe ('blah' ,() => {
it('blah blah', ()=>{
checkBlah().
then((result) => {
if(result != ok){
return pending();
}
return doBlahBah() .....
});
});
});",,NONE,2017-04-13 15:33:09+00:00,True,2017-04-14 20:35:20+00:00,1.21,,1,1,2017-04-14 20:35:20+00:00,1.21,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1317,Calling toThrowError with no arguments errors via assuming the undefined argument is a regex,"The current behavior of toThrowError assumes that if the first argument isn't a string or a function, then it must be a regex; it subsequently calls .test on the undefined first argument and throws the error TypeError: expected.test is not a function (error partially suppressed by Protractor wrapping Jasmine).
The behavior should change to .toThrowError() being identical to .toThrowError(Error).
I am running Jasmine 2.4.1 (The 2.5 docs do not include an argumentless example so I think this carries through to 2.5) in node/protractor.",tsclaus,NONE,2017-04-17 19:44:20+00:00,True,2017-07-20 05:09:04+00:00,93.39,,2,2,2017-04-17 20:53:14+00:00,0.05,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1318,"'expect' was used when there was no current spec, this could be because an asynchronous test timed out","Version details:
""jasmine"": ""2.5.2"",
""jasmine-core"": ""2.5.2"",
""jasmine-expect"": ""3.7.0"",
""karma"": ""1.3.0"",
""phantomjs"": ""2.1.7""
""karma-phantomjs-launcher"": ""1.0.2"",

Log messages
=============================== Coverage summary ===============================
Statements   : 87.93% ( 1217/1384 ), 64 ignored
Branches     : 80.57% ( 456/566 ), 43 ignored
Functions    : 86.18% ( 399/463 ), 20 ignored
Lines        : 90.2% ( 1086/1204 )
================================================================================
�[1A�[2KPhantomJS 2.1.1 (Linux 0.0.0) ERROR
  Error: 'expect' was used when there was no current spec, this could be because an asynchronous test timed out
  at node_modules/jasmine-core/lib/jasmine-core/jasmine.js:970
PhantomJS 2.1.1 (Linux 0.0.0): Executed 171 of 182 (skipped 11) ERROR (4.388 secs / 0.768 secs)
�[1A�[2KPhantomJS 2.1.1 (Linux 0.0.0): Executed 171 of 182 (skipped 11) ERROR (4.424 secs / 0.768 secs)

=============================== Coverage summary ===============================
Statements   : 87.93% ( 1217/1384 ), 64 ignored
Branches     : 80.57% ( 456/566 ), 43 ignored
Functions    : 86.18% ( 399/463 ), 20 ignored
Lines        : 90.2% ( 1086/1204 )
================================================================================
npm ERR! weird error 1
npm WARN This failure might be due to the use of legacy binary ""node""
npm WARN For further explanations, please read
/usr/share/doc/nodejs/README.Debian
 
npm ERR! not ok code 0
Build step 'Execute shell' marked build as failure

I can't identify which line of code is causing this issue. Could someone help on how can I trace the issue and its from which source file.
I have tried following:
jasmine.getEnv().defaultTimeoutInterval = 15000;

and in karma conf
browserNoActivityTimeout: 100000,

But this error doesn't gets resolved.",cksachdev,NONE,2017-04-23 14:57:37+00:00,True,2017-04-24 21:21:14+00:00,1.27,,2,1,2017-04-24 21:21:13+00:00,1.27,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1320,"it, beforeEach, etc. no longer accept async functions","Summary
Version 2.6.0 includes #1222 which forces functions as the argument for it, beforeEach, and the like. This introduces a breaking change because we can no longer pass async functions.
Example
describe('some suite', () => {
    it('is good', async (done) => {
        expect(await someAsyncLogic()).toBe(1);
        done();
    });
});
Expected result
Test should pass.
Actual result
Error: it expects a function argument; received [object AsyncFunction]

Environment
Jasmine: v2.6.0
Node.js: v7.9.0
Runner: gulp-jasmine v2.4.2",pe8ter,NONE,2017-04-25 03:04:56+00:00,True,2017-05-19 21:03:30+00:00,24.75,,4,4,2017-04-25 20:52:24+00:00,0.74,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1321,TypeError: undefined is not a constructor (evaluating 'allKeys[i].match(/^[0-9]+$/)'),"Hi, this issue seems to have resurfaced. Works with 2.5.2 but not with 2.6.0.


2.6.0


node with karma
it(""should calculate correct when xAxisLabels length less than 8"", () =>
expect(buildDefaultDataZoom({}, []))
.toEqual(
[{
startValue: 0,
endValue: 0
}, {
type: ""inside""
}]
)
)


regards",jonashartwig,NONE,2017-04-25 06:26:21+00:00,True,2017-04-25 20:48:54+00:00,0.6,,3,2,2017-04-25 06:53:48+00:00,0.02,EstartuPrime,NONE,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1322,Very slow tests after update from 2.5.3 to 2.6.0 ,"After upgrading Jasmine and Jasmine only, suddenly the tests were running dramatically slower than usual. The test duration increased from approximately 15 minutes to more than 30 minutes.
The tests run in chrome via karma.",rryter,NONE,2017-04-25 07:29:18+00:00,True,2017-05-01 20:48:48+00:00,6.56,,3,2,2017-04-27 12:36:22+00:00,2.21,olivierbelzile,NONE,1,0,0,1,['duplicate'],False,False,False,False,False,False,False,False,False,False,True,False,False,False,False
1323,2.6 breaks support of using `toEqual(null)` and `toEqual(undefined)`,"Version: 2.6
Env: Browser.
Running using: Karma
In some cases we don't care wether the resultant value is null or undefined, so long as it's one of those.
For example, this helps especially when using a 3rd party library that may return one the former in one version, the the latter in another.
And so when attempting to assert that a value is either null or undefined, we have simply used something like:
expect(result).toEqual(null);
In Jasmine 2.5, that worked as expected -
expect(null).toEqual(null); // pass
expect(undefined).toEqual(undefined); // pass
expect(undefined).toEqual(null); // pass
expect(0).toEqual(null); // fails
Jasmine 2.6 however, seems to introduce a breaking change:
expect(result).toEqual(null); // RangeError: Invalid string length",roni-frantchi,NONE,2017-04-25 11:45:28+00:00,True,2017-04-27 15:47:07+00:00,2.17,,3,7,2017-04-26 20:40:34+00:00,1.37,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1324,2.6.0 causes regression of 1188,"Since updating to Jasmine 2.6.0, we have noticed the same issue described here: #1188
This appears to be a regression; downgrading to 2.5.2 resolved it for us.
Seems to have been caused by the fix (c0a9d20) either not being applied to the 2.6 branch, or being reverted.",davidje13,NONE,2017-04-25 12:45:25+00:00,True,2017-04-25 20:48:54+00:00,0.34,,3,2,2017-04-25 13:06:23+00:00,0.01,Darkein,NONE,0,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1325,2.6.0 Breaks CSP in Atom,"EvalError: Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive: ""script-src 'self'""
UziTech/atom-jasmine2-test-runner#14",UziTech,CONTRIBUTOR,2017-04-25 15:18:02+00:00,True,2017-04-26 20:36:47+00:00,1.22,,1,2,2017-04-25 18:37:23+00:00,0.14,UziTech,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1327,"Karma - Disconnected, because no message in 10000 ms.","So after I did a rm -r node_modules;npm install today, my jasmine tests (ran via karma) started failing with a Disconnected, because no message in 10000 ms.
After half a day debugging... it all came down to jasmine-core causing the issue. After you guys upped your version to 2.6.0 I started getting the Disconnected, because no message in 10000 ms. message).
So I did a binary commit search until I found the commit that broke my test build. This is the commit 2f01f64, which is part of the 2.6.0 release
Before this commit, my karma tests run just fine.
For now my solution was to go back jasmine-core@2.5.2 in my package.json without any carret or tilde.
Seems some people in here karma-runner/karma-phantomjs-launcher#126 are having issues the last days, not sure, but it might be related to the commit mentioned:

What version are you using?
These are the dependencies in my package.json:

""devDependencies"": {
    ""async"": ""^1.5.1"",
    ""beeper"": ""^1.1.0"",
    ""del"": ""^1.2.0"",
    ""eslint"": ""^2.13.1"",
    ""eslint-plugin-angular"": ""^0.11.0"",
    ""eslint-plugin-jasmine"": ""^1.8.0"",
    ""eslint-plugin-lodash"": ""^1.9.0"",
    ""glob"": ""^6.0.3"",
    ""gulp"": ""^3.9.0"",
    ""gulp-angular-templatecache"": ""^1.7.0"",
    ""gulp-autoprefixer"": ""^2.3.1"",
    ""gulp-clean-css"": ""^2.0.7"",
    ""gulp-concat"": ""^2.6.0"",
    ""gulp-eslint"": ""^2.1.0"",
    ""gulp-filter"": ""^3.0.0"",
    ""gulp-help"": ""^1.6.0"",
    ""gulp-htmlhint"": ""^0.3.1"",
    ""gulp-if"": ""^1.2.5"",
    ""gulp-imagemin"": ""^2.3.0"",
    ""gulp-inject"": ""^1.5.0"",
    ""gulp-json-editor"": ""^2.2.1"",
    ""gulp-load-plugins"": ""^1.0.0-rc.1"",
    ""gulp-minify-html"": ""^1.0.4"",
    ""gulp-ng-annotate"": ""^1.1.0"",
    ""gulp-notify"": ""^2.2.0"",
    ""gulp-plumber"": ""^1.0.1"",
    ""gulp-print"": ""^1.1.0"",
    ""gulp-rename"": ""^1.2.2"",
    ""gulp-replace"": ""^0.5.3"",
    ""gulp-rev"": ""^5.1.0"",
    ""gulp-rev-replace"": ""^0.4.2"",
    ""gulp-sass"": ""^2.1.0"",
    ""gulp-shell"": ""^0.4.2"",
    ""gulp-size"": ""^2.1.0"",
    ""gulp-sourcemaps"": ""^1.5.2"",
    ""gulp-symlink"": ""^2.1.2"",
    ""gulp-uglify"": ""^1.2.0"",
    ""gulp-uncss"": ""^1.0.2"",
    ""gulp-useref"": ""^1.2.0"",
    ""gulp-util"": ""^3.0.6"",
    ""gulp-watch"": ""^4.3.5"",
    ""gulp-zip"": ""^3.0.2"",
    ""jasmine-ajax"": ""^3.2.0"",
    ""jasmine-core"": ""^2.4.1"",
    ""karma"": ""^1.3.0"",
    ""karma-beep-reporter"": ""^0.1.4"",
    ""karma-chrome-launcher"": ""^2.0.0"",
    ""karma-coffee-preprocessor"": ""^1.0.1"",
    ""karma-coverage"": ""^1.1.1"",
    ""karma-firefox-launcher"": ""^1.0.0"",
    ""karma-growl-reporter"": ""^1.0.0"",
    ""karma-html2js-preprocessor"": ""^1.1.0"",
    ""karma-jasmine"": ""^1.0.2"",
    ""karma-junit-reporter"": ""^1.1.0"",
    ""karma-ng-html2js-preprocessor"": ""^1.0.0"",
    ""karma-phantomjs-launcher"": ""^1.0.2"",
    ""karma-requirejs"": ""^1.1.0"",
    ""karma-script-launcher"": ""^1.0.0"",
    ""karma-spec-reporter"": ""0.0.26"",
    ""lazypipe"": ""^1.0.1"",
    ""lodash"": ""^3.10.1"",
    ""map-stream"": ""0.0.6"",
    ""node-notifier"": ""^4.2.3"",
    ""phantomjs"": ""^2.1.7"",
    ""require-dir"": ""^0.3.0"",
    ""requirejs"": ""^2.1.18"",
    ""run-sequence"": ""^1.1.2"",
    ""vinyl-paths"": ""^1.0.0"",
    ""yargs"": ""^3.15.0"",
    ""bower"": ""^1.8.0""
  },


What environment are you running Jasmine in (node, browser, etc)?
Running karma with phanthomjs@2.1.7 on a OSX Sierra machine, but it is also happening in a unix machine
How are you running Jasmine (standalone, npm, karma, etc)?
karma

Thanks!!!",cafesanu,NONE,2017-04-25 18:17:18+00:00,True,2017-06-15 21:30:59+00:00,51.13,,45,65,2017-04-25 18:49:57+00:00,0.02,jgornick,NONE,2,1,0,41,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1328,Error: it expects a function argument; received [object Undefined],"ensureIsFunction throws an error when it, describe, etc. are called with their function arguiment as undefined which acording to the documentation is allowed.",UziTech,CONTRIBUTOR,2017-04-25 20:07:25+00:00,True,2017-04-26 20:50:20+00:00,1.03,,2,4,2017-04-25 20:59:23+00:00,0.04,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1331,Expected $[0] not to have properties     invocationOrder:,"same error that is on the bottom of your documentation
https://jasmine.github.io/2.6/introduction.html",UziTech,CONTRIBUTOR,2017-04-25 20:26:08+00:00,True,2017-04-25 21:23:54+00:00,0.04,,2,4,2017-04-25 21:25:06+00:00,0.04,slackersoft,MEMBER,1,1,0,0,['docs'],False,False,False,False,False,False,False,True,False,False,False,False,False,False,False
1334,2.6 upgrade from 2.5.2 generates errors,"Jasmine 2.5.2 -> 2.6.0
I am running my tests using Karma and PhantomJS and until yesterday everything was running smoothly but since then my Jenkins tests have been failing. After downgrading to jasmine 2.5.2 explicitly everything went back to normal.
> karma start ./config/karma.conf.js

PhantomJS 2.1.1 (Mac OS X 0.0.0) ERROR
  TypeError: undefined is not a constructor (evaluating 'global.process.listeners('uncaughtException')')
  at node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2180
PhantomJS 2.1.1 (Mac OS X 0.0.0) ERROR
  TypeError: undefined is not a constructor (evaluating 'global.process.listeners('uncaughtException')')
  at node_modules/jasmine-core/lib/jasmine-core/jasmine.js:2180

PhantomJS 2.1.1 (Mac OS X 0.0.0): Executed 0 of 44 ERROR (0.002 secs / 0 secs)

npm ERR! Test failed.  See above for more details.
I am fine with 2.5.2, but I am just putting it here in case someone else really needs 2.6 and needs this fixed",samudurand,NONE,2017-04-26 10:24:29+00:00,True,2017-08-02 00:45:44+00:00,97.6,,13,25,2017-04-26 10:34:44+00:00,0.01,maksimluzik,NONE,1,0,0,11,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1335,  Failed: Uncaught (in promise): [throw error....],"What version are you using?
""jasmine-core"": ""~2.5.2"",
""jasmine-spec-reporter"": ""~3.2.0"",


What environment are you running Jasmine in (node, browser, etc)?
Angular 4.0.1 via angular cli


How are you running Jasmine (standalone, npm, karma, etc)?
ng test


If possible, include an example spec that demonstrates your issue.


I have a login page which call authentication service to authenticate the users. If there user's credentials are invalid then it throws an observable error back to login method (which is of type void).. The unit test is throwing uncaught exception like..
Failed: Uncaught (in promise): The username or password is invalid
I have tried to use following but it didn't help
expect(app.login()).toThrow( new Error(""The username or password is invalid""));",yasiryc,NONE,2017-04-26 20:38:05+00:00,True,2017-05-02 21:07:20+00:00,6.02,,2,2,2017-05-02 21:07:20+00:00,6.02,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1337,beforeAll is not defined,"recently I use jasmine to run my api testing,and I also install karma,the karma is configed by other people.
When I write scripts,
beforeEach can be used,but beforeAll is not defined and always report an error.
I have searched and tried to upgrade my jasmine-node and karma-jasmine to @v0.3.5 and the problem still exist.I think it is due to  the version relative to jasmine
the package.json is as follows:
""dependencies"": {
""@angular/common"": ""2.0.0"",
""@angular/compiler"": ""2.0.0"",
""@angular/core"": ""2.0.0"",
""@angular/forms"": ""2.0.0"",
""@angular/http"": ""2.0.0"",
""@angular/platform-browser"": ""2.0.0"",
""@angular/platform-browser-dynamic"": ""2.0.0"",
""@angular/router"": ""3.0.0"",
""@angular/upgrade"": ""2.0.0"",
""angular2-in-memory-web-api"": ""0.0.20"",
""body-parser"": ""~1.16.0"",
""bootstrap"": ""^3.3.6"",
""cookie-parser"": ""~1.4.3"",
""core-js"": ""^2.4.1"",
""debug"": ""~2.6.0"",
""express"": ""~4.14.1"",
""express-session"": """",
""frisby"": ""^0.8.5"",
""jasmine-core"": ""^2.5.2"",
""jasmine-node"": ""^1.14.5"",
""jasmine-node-karma"": ""^1.6.1"",
""jasmine-xml-reporter"": ""^1.0.6"",
""kerberos"": ""~0.0.23"",
""mongodb"": ""~2.2.25"",
""morgan"": ""~1.7.0"",
""passport"": """",
""passport-cas2"": ""*"",
""reflect-metadata"": ""^0.1.3"",
""requirejs"": ""^2.3.3"",
""rxjs"": ""5.0.0-beta.12"",
""serve-favicon"": ""~2.3.2"",
""systemjs"": ""0.19.27"",
""vertx3-min"": ""^3.0.0-1"",
""zone.js"": ""^0.6.23""
},
""devDependencies"": {
""angular2-cookie"": ""^1.2.6"",
""angular2-template-loader"": ""^0.6.2"",
""awesome-typescript-loader"": ""^3.1.2"",
""babel-cli"": ""^6.24.1"",
""babel-core"": ""^6.24.1"",
""babel-loader"": ""^6.4.1"",
""babel-preset-es2015"": ""^6.24.1"",
""concurrently"": ""^2.2.0"",
""copy-webpack-plugin"": ""^4.0.1"",
""css-loader"": ""^0.28.0"",
""expect.js"": ""^0.3.1"",
""file-loader"": ""^0.11.1"",
""html-loader"": ""^0.4.5"",
""inline-source-map"": ""^0.6.2"",
""istanbul"": ""^0.4.5"",
""istanbul-instrumenter-loader"": ""^2.0.0"",
""istanbul-merge"": ""^1.1.1"",
""jasmine"": ""^2.5.2"",
""jasmine-core"": ""^2.5.2"",
""jasmine-supertest"": ""^1.0.0"",
""jasmine-webpack-plugin"": ""^0.1.1"",
""karma"": ""^1.6.0"",
""karma-chrome-launcher"": ""^2.0.0"",
""karma-cli"": ""^1.0.1"",
""karma-coverage"": ""^1.1.1"",
""karma-coverage-istanbul-reporter"": ""^1.2.0"",
""karma-jasmine"": ""^0.3.5"",
""karma-jasmine-html-reporter"": ""^0.2.2"",
""karma-junit-sonarqube-reporter"": ""0.0.1"",
""karma-phantomjs-launcher"": ""^1.0.4"",
""karma-requirejs"": ""^1.1.0"",
""karma-sourcemap-loader"": ""^0.3.7"",
""karma-spec-reporter"": ""0.0.31"",
""karma-webpack"": ""^2.0.3"",
""less-vars-loader"": ""^1.1.0"",
""lite-server"": ""^2.2.2"",
""nodemon"": ""^1.11.0"",
""npm-run-all"": ""^4.0.2"",
""null-loader"": ""^0.1.1"",
""raw-loader"": ""^0.5.1"",
""rimraf"": ""^2.6.1"",
""should"": ""^11.2.1"",
""style-loader"": ""^0.16.1"",
""supertest"": ""^3.0.0"",
""ts-loader"": ""^0.8.1"",
""tslint"": ""^5.1.0"",
""typescript"": ""^2.0.2"",
""typings"": ""^1.3.2"",
""webpack"": ""^2.4.1"",
""webpack-node-externals"": ""^1.5.4"",
""webpack-shell-plugin"": ""^0.5.0""
},
So pls tell me the jasmine version or karma-jasmine and others' version
THX",qblslion,NONE,2017-04-28 01:50:37+00:00,True,2017-05-23 20:56:24+00:00,25.8,,4,4,2017-05-02 09:04:39+00:00,4.3,askarby,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1338,Feature Request,"If theres a console.log in the JS under test, pl display output on SpecRunner.html",hippikon,NONE,2017-04-28 22:51:32+00:00,True,2017-05-02 20:44:52+00:00,3.91,,2,1,2017-05-02 20:44:52+00:00,3.91,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1341,Confused about MO vs MT,"Hello!
First of all, Jasmin is awesome in the couple of tests I've run so far, so many thanks to everyone involved.  I'm not sure if I'll get an answer here because this is more of a support/conceptual question than an issue. Apologies in advance.
I'm pretty confused when it comes to receiving messages. Our situation is as follows: we have our own numbers but we're not a mobile service provider. We would like to send messages to our clients (through the actual mobile providers) and be abale to receive answers (Like standardized YES or NO answers or prompts) and act on them through an API. This would be covered by the MO messages you refer to in your architecture:

But to interconnect with the actual providers they require an SMPP connection where they are the client, while also getting DLRs and everything. This is obviously covered by the ""SMPP Server"" part of your architecture.

The connection works with the one provider we've tried so far, but every message through that channel gets identified as an MT message...and we have nowhere to forward it because our numbers aren't actual devices. (We get this error:
""2017-04-28 19:17:01 ERROR    1 SMPPC [cid:virgin] is not bound: Requeuing ...""
So, to sum it up, is there any way to force messages to be identified as MO (How would they ever be MO and not MT?) to be able to trigger the scripts associated with Receiving SMS-MO as described in your documentation, while at the same time delivering DLRs to the SMPP client. Or if thats impossible, a way to save SMS-MT in a database and respond with DLRs while not actually delivering them to the destination number.
I hope that wasn't too confusing. Thanks in advance for any kind reply.",AndreaAltamirano,NONE,2017-05-02 21:28:12+00:00,True,2017-05-02 21:32:34+00:00,0.0,,3,2,2017-05-02 21:32:33+00:00,0.0,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1342,Upgrade from 2.5.2 to 2.6.1 get strange error,"today when I upgraded jasmine-core from 2.5.2 to 2.6.1, got a strange error:

if one test case failed, caused all the rest of cases failed with same error:
failed case:

the rest part cases:

also during them, there's some other errors:


But if I add breakpoint to debug, the result is right(one case fail, other passed):
just 3 errors for the failed case

Karma version used : 1.6.0
Karma-jasmine : 1.1.0
Karma-chrome-launcher: 2.1.0
thanks for your help",Teamop,NONE,2017-05-04 12:12:56+00:00,True,2017-05-10 20:57:49+00:00,6.36,,2,1,2017-05-10 20:57:49+00:00,6.36,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1345,Why not also returning the actual value of a failing test?,"My test is failing:

I'd also like as a user to be able to inspect the actual value of the offending variable of my failing test, like below for example:
Expected 6589 to equal 663.
Actual value is 3424234

Disclaimer: The only related issue I found -and please correct me if I'm wrong- is adding a custom error message when a test fails.",thodorisbais,CONTRIBUTOR,2017-05-06 10:49:24+00:00,True,2017-05-06 10:54:19+00:00,0.0,,1,1,2017-05-06 10:54:19+00:00,0.0,thodorisbais,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1346,No Spec Setting for console output ,"What version are you using?
""jasmine"": ""^2.5.2""
What environment are you running Jasmine in (node, browser, etc)?
node v6.5.0 (different OS's all same result)
How are you running Jasmine (standalone, npm, karma, etc)?
just jasmine at the command line

not sure if that is an issue. I get a tests result just as
Started
......
6 specs, 0 failures
Finished in 0.01 seconds
But I don't get anything as in the examples which mentions the describe or it sections. Only if there is a fault. Is there any spec setting which simply shows the same as a SepcRunner.html would ?",vkuehn,NONE,2017-05-08 14:52:41+00:00,True,2017-05-10 20:56:59+00:00,2.25,,2,2,2017-05-10 20:56:59+00:00,2.25,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1349,Async errors are sometimes routed to many specs,"This looks like it might be similar to #1342 except that it only reproduces in Node as far as I can tell. When a spec causes an uncaught exception after telling Jasmine that it's done (in this case by returning from a synchronous spec), Jasmine will sometimes report the error on multiple unrelated specs.
Here's the spec that causes it:
  it(""fails in several different ways"", function(done) {
    var env = new jasmineUnderTest.Env(),
        reporter = jasmine.createSpyObj('fakeReporter', [
          ""jasmineStarted"",
          ""jasmineDone"",
          ""suiteStarted"",
          ""suiteDone"",
          ""specStarted"",
          ""specDone""
        ]);
    env.randomizeTests(true);
    env.seed('123456');

    reporter.jasmineDone.and.callFake(function(doneArg) {
      throw new Error('oops!');
    });

    env.addReporter(reporter);
    env.execute();
  });

But it's at least somewhat dependent on random seed, what specs run after it, and moonphase so it's probably best to just grab the misrouted-errors branch https://github.com/sgravrock/jasmine/ and play with that.
And here's output that shows several different behaviors, including 51 specs failing with the same error.
Script started on Mon May  8 12:19:41 2017
bash-3.2$ grunt execSpecsInNode
Running ""execSpecsInNode"" task
Started
....[ snipped page-widening dots]/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/GlobalErrors.js:8
      handler.apply(null, Array.prototype.slice.call(arguments, 0));
             ^

TypeError: Cannot read property 'apply' of undefined
  at process.onerror (/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/GlobalErrors.js:8:14)
  at emitOne (events.js:101:20)
  at process.emit (events.js:188:7)
  at process._fatalException (bootstrap_node.js:297:26)

bash-3.2$ grunt execSpecsInNode
Running ""execSpecsInNode"" task
Started
...[ snipped page-widening dots]
Failures:
1) Env integration fails in several different ways
  Message:
    Error: oops!
  Stack:
    Error: oops!
      at Object.<anonymous> (/Users/pivotal/workspace/jasmine-stuff/jasmine/spec/core/integration/EnvSpec.js:1407:13)
      at dispatch (/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/ReportDispatcher.js:39:28)
      at ReportDispatcher.jasmineDone (/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/ReportDispatcher.js:10:11)
      at Immediate.<anonymous> (/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/Env.js:268:18)
      at runCallback (timers.js:672:20)
      at tryOnImmediate (timers.js:645:5)
      at processImmediate [as _immediateCallback] (timers.js:617:5)
    

[... snipped another 49 specs that failed with the same erorr ...]

51) Env integration suiteDone reporting reports when an async afterAll fails an expectation
  Message:
    Error: oops!
  Stack:
    Error: oops!
      at Object.<anonymous> (/Users/pivotal/workspace/jasmine-stuff/jasmine/spec/core/integration/EnvSpec.js:1407:13)
      at dispatch (/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/ReportDispatcher.js:39:28)
      at ReportDispatcher.jasmineDone (/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/ReportDispatcher.js:10:11)
      at Immediate.<anonymous> (/Users/pivotal/workspace/jasmine-stuff/jasmine/src/core/Env.js:268:18)
      at runCallback (timers.js:672:20)
      at tryOnImmediate (timers.js:645:5)
      at processImmediate [as _immediateCallback] (timers.js:617:5)
    

Ran 689 of 693 specs
689 specs, 51 failures
Finished in 0.931 seconds

Randomized with seed 95427
Warning: Task ""execSpecsInNode"" failed.� Use --force to continue.

Aborted due to warnings.
bash-3.2$ grunt execSpecsInNode
Running ""execSpecsInNode"" task
Started
..[ snipped page-widening dots]


Ran 689 of 693 specs
689 specs, 0 failures
Finished in 0.93 seconds

Randomized with seed 28208

Done.
bash-3.2$ exit

Script done on Mon May  8 12:19:54 2017",sgravrock,MEMBER,2017-05-08 19:39:17+00:00,True,2017-05-10 20:51:25+00:00,2.05,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1350,Does jasmine 2.6.0 not support ES7 async await functions?,"I am trying to use Jasmine to test functions that use ES7 async await features. Jasmine although works for promises and async functions, it fails for ES7 async function. For example:
describe(""async-test"", () => {
  it('should run test', (async function(done) {
     var x = await fakeRequest();
     expect(x).toBeDefined();
     done();
  }));
 
});

async function fakeRequest() {
     let result = await another_request();
     return result;
}

async function another_request(){
    // returns promise resolution or some async function call return
}

it always gives this error:
async-test
    ✖ should run test
      PhantomJS 2.1.1 (Mac OS X 0.0.0)
    Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL. in config/karma-shim.js (line 98794)
    ZoneAwareError@webpack:///~/zone.js/dist/zone.js:999:0 <- config/karma-shim.js:98794:28

How can I make it work. Jasmine works when I am only dealing with promises but as soon as ES7 come in, it stops working. How can I make it work with functions that use ES7 features?
I am running
""jasmine-core"": ""^2.6.0"",""karma"": ""^1.6.0"", ""typescript"": ""~2.2.2"" and Node 7.10.0",thepiyush13,NONE,2017-05-08 23:41:11+00:00,True,2017-05-19 21:03:30+00:00,10.89,,3,3,2017-05-10 21:08:44+00:00,1.89,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1351,What about including toBeNumber method?,The concept and the reason I thought about it is more or less similar to #1294.,thodorisbais,CONTRIBUTOR,2017-05-09 21:32:29+00:00,True,2017-05-11 20:56:59+00:00,1.98,,2,1,2017-05-11 20:56:59+00:00,1.98,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1353,and.returnValue is undefined on Spy [2.6.0],"I use jasmine 2.6.0 in my test js:
var qbitFunction = jasmine.createSpy('qbitFunction');
      console.log(88, qbitFunction, qbitFunction.add);
      qbitFunction.add.returnValue({amplitudeOf0: real(0.2), amplitudeOf1: real(0.3)});
but got error:
TypeError: Cannot read property 'returnValue' of undefined.
Here is the log:
88 { [Function: spy]
  and: 
   SpyStrategy {
     identity: [Function],
     exec: [Function],
     callThrough: [Function],
     returnValue: [Function],
     returnValues: [Function],
     throwError: [Function],
     callFake: [Function],
     stub: [Function] },
  calls: 
   CallTracker {
     track: [Function],
     any: [Function],
     count: [Function],
     argsFor: [Function],
     all: [Function],
     allArgs: [Function],
     first: [Function],
     mostRecent: [Function],
     reset: [Function],
     saveArgumentsByValue: [Function] } } undefined
Anyone can help?

typo!!! sorry.",tearsofphoenix,NONE,2017-05-10 07:16:16+00:00,True,2017-05-10 07:49:22+00:00,0.02,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1354,it timeput confusing,"Hi, documentation says that using timeout parameter in it function should wait for runs the function associated, but runs always immediately, why?",alienator,NONE,2017-05-10 16:27:31+00:00,True,2017-05-10 20:42:11+00:00,0.18,,2,1,2017-05-10 20:42:11+00:00,0.18,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1355,Jasmine 2.6 fails to pretty print Set on Safari 8,"Hi,
The pretty print function of Jasmine fails (throw an error) to pretty print Set instances on Safari 7.1 and Safari 8. The reason is that the pretty print function use the Set.values but the iterators returned by them lack a next method.
The fix could be to:

Not try to pretty-print Set on browsers with incomplete Set features.
Use forEach functions of Set which is correctly implemented in all browsers that support Set (even with partial support).

@slackersoft What do you think? I would be happy to submit a PR if you think it's worth it.",mjeanroy,NONE,2017-05-11 10:11:51+00:00,True,2018-01-13 01:34:08+00:00,246.64,,2,1,2017-05-11 20:52:37+00:00,0.44,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1357,How do I run jasmine using node's --trace-warnings?,"I'm using jasmine 2.5.3
I submitted this question to jasmine-js@googlegroups.com but got a mailer error.",SeanHayes,NONE,2017-05-13 05:43:03+00:00,True,2017-07-26 00:45:01+00:00,73.79,,2,2,2017-05-16 20:59:25+00:00,3.64,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1358,Expecting array of object 'toContain' array of objects fails,"When I try to check if an array of objects contains objects from another array, the test fails.
I have made a jsFiddle which outlines my expectations of the 'toContain' method which may be wrong but they would be nice!

All version info is shown in the fiddle!",Tom-Hudson,NONE,2017-05-22 11:49:17+00:00,True,2017-05-22 21:32:20+00:00,0.4,,2,2,2017-05-22 21:32:19+00:00,0.4,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1359,Default parameters,"Given a class like this:
class Example {
  constructor(fn = (a, b) => b) {
    this.fn = fn;  
  }
}
Is it possible to test whether the function assigned to the property fn of the class is the default parameter or not? One approach would be to test the function itself which gets assigned to the class property fn. But this won't work for all cases - for example:
const eg = new Example((a,b,c) => b);
The second function applied to the parameter fn isn't the same as the default parameter. This is just a very basic example and the use case for this test is indeed very rare.",emanuelbuholzer,NONE,2017-05-23 11:48:06+00:00,True,2017-05-25 19:25:21+00:00,2.32,,2,2,2017-05-25 18:55:45+00:00,2.3,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1360,`RangeError` when using `toEqual(jasmine.any(Class)`,"Continuing thread from #1323.
Running Jasmine via Karma.
Jasmine: 2.6.2
Node: 6.9.5
Karma: 1.7.0
Karma Jasmine: 1.1.0
Launchers I've been using are Chrome and Phantom; both show the same issue.
I found this kind of issue as well doing this type of test for Angular 4 components:
expect(componentInstance).toEqual(jasmine.any(ComponentClass));
That would give me RangeError: Invalid string length. I've checked and both expressions evaluate to valid objects, as far as I can tell, i.e., they're not undefined, null, or something I wouldn't expect. Removing the jasmine.any inside the toEqual seems to be what did it for me; I was able to ""work around"" this issue like so:
expect(componentInstance instanceof ComponentClass).toBeTruthy()
That said, it makes me think that somehow Jasmine is running out of memory? The expressions are individually calculated correctly; it's just equality + .any that messes it up. Not sure how helpful it might be, but below is the stack trace that I'm getting:
Uncaught RangeError: Invalid string length
    at Object.<anonymous> (http://localhost:9999/base/src/test.ts:34288:45)
    at ZoneDelegate.invoke (http://localhost:9999/base/src/test.ts:28493:1154)
    at ProxyZoneSpec.onInvoke (http://localhost:9999/base/src/test.ts:28429:2160)
    at ZoneDelegate.invoke (http://localhost:9999/base/src/test.ts:28493:1050)
    at Zone.run (http://localhost:9999/base/src/test.ts:28477:2925)
    at Object.<anonymous> (http://localhost:9999/base/src/test.ts:28363:131)
    at http://localhost:9999/base/src/test.ts:6511:46
    at ZoneDelegate.invoke (http://localhost:9999/base/src/test.ts:28493:1154)
    at AsyncTestZoneSpec.onInvoke (http://localhost:9999/base/src/test.ts:28268:156)
    at ProxyZoneSpec.onInvoke (http://localhost:9999/base/src/test.ts:28429:2040)
    at ZoneDelegate.invoke (http://localhost:9999/base/src/test.ts:28493:1050)
    at Zone.run (http://localhost:9999/base/src/test.ts:28477:2925)
    at AsyncTestZoneSpec._finishCallback (http://localhost:9999/base/src/test.ts:6510:13)
    at http://localhost:9999/base/src/test.ts:28265:139
    at ZoneDelegate.invokeTask (http://localhost:9999/base/src/test.ts:28493:2120)
    at Zone.runTask (http://localhost:9999/base/src/test.ts:28482:417)
    at ZoneTask.invoke (http://localhost:9999/base/src/test.ts:28495:975)
    at timer (http://localhost:9999/base/src/test.ts:28627:248)
Also worth noting is that I get a [Violation] 'setTimeout' handler took 14605ms warning in ""Verbose"" log mode in the Chrome Dev Tools. I believe that's because whatever's causing the error takes a bit before ending up in the RangeError.

The at Object.<anonymous> [...]/test.ts:34288:45 reference at the very top refers to exactly the point where .toEqual is called. In my tests, I have only two instances of .toEqual(jasmine.any(ComponentClass)), both of which fail in the same manner. Changing to the instanceof approach not only removes the error but also doesn't cause a delay, therefore avoiding the Violation warning.",emilio-martinez,NONE,2017-05-24 09:44:24+00:00,True,2017-06-14 20:36:47+00:00,21.45,,2,2,2017-06-15 10:20:17+00:00,22.02,emilio-martinez,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1361,Not working expectationFAilOutput.,"What version are you using?
'2.6.0'
What environment are you running Jasmine in (node, browser, etc)?
'nodejs'
How are you running Jasmine (standalone, npm, karma, etc)?
'included in protractor'
If possible, include an example spec that demonstrates your issue.
users.createUser(someUser);
expect(users.isUser(someUser)).toEqual(true, 'There isnt user:' + someUser.name)

if it fails, there isn't fail output there: ""There isnt user: someUser""
it's just output:
Expected false to equal true.",Niyarlatotep,NONE,2017-05-25 07:09:20+00:00,True,2017-05-25 21:13:43+00:00,0.59,,3,2,2017-05-25 21:13:42+00:00,0.59,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1363,How do you pronounce Jasmine,"We are having a bit of a pedantic argument in the office and are wondering about the correct pronunciation of Jasmine.
Is it jaz-min or yas-meen ?",DavePilks,NONE,2017-05-31 09:41:33+00:00,True,2017-06-07 21:26:42+00:00,7.49,,3,2,2017-05-31 11:39:58+00:00,0.08,jaapz,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1364,"""expect"" call executed in incorrect test for an async test","In a case where I'm subscribing to the statusChanges observable of a FormBuilder and calling updateValueAndValidity after setting the value of the FormBuilder, for some reason, the expect isn't being executed until the next test, which is causing that test to fail.
import { TestBed, ComponentFixture, async } from '@angular/core/testing';
import { ActivatedRoute, Router } from '@angular/router';
import { Logger, Level } from 'angular2-logger/core';
import { SharedModule } from '../../common/shared.module';
import { CommonModule } from '@angular/common';
import { FormsComponent } from './forms.component';
import { ReactiveFormsModule } from '@angular/forms';

import { environment } from '../../environments/environment';

import { DebugElement } from '@angular/core';
import { Observable } from 'rxjs/Rx';

const LOGGER_LEVEL: Level = Level.OFF;

const STATUS = {
  VALID: 'VALID',
  INVALID: 'INVALID',
  PENDING: 'PENDING'
};

describe('FormsComponent', () => {

  let de: DebugElement;
  let fixture: ComponentFixture<FormsComponent>;
  let app: FormsComponent;
  let logger: Logger;

  beforeEach(async(() => {
    environment.logger.level = LOGGER_LEVEL;

    TestBed.configureTestingModule({
      declarations: [
        FormsComponent
      ],
      imports: [
        SharedModule.forRoot(),
        CommonModule,
        ReactiveFormsModule
      ],
      providers: [
        {
          provide: ActivatedRoute,
          useValue: {
            params: Observable.of({})
          }
        },
        {
          provide: Router,
          useValue: {
            params: Observable.of({}),
            navigate: function (routes: any[]) {
              return true;
            }
          }
        }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(FormsComponent);
    app = fixture.componentInstance;
    de = fixture.debugElement;
    logger = TestBed.get(Logger);
    app.ngOnInit();
  }));

  it('should be valid for these test cases.', async(() => {
    const TEST_CASES = [
      {
        name: 'John',
        power: 'Invisibility'
      },
      {
        name: 'Aaron',
        power: 'Flight'
      },
      {
        name: 'Dan',
        power: 'Super Strength'
      },
      {
        name: '#$%^$@',
        power: 'power'
      },
      {
        name: '1234',
        power: 'ppppppppppppppppppppppppppppppppppppppp'
      },
      {
        name: '123456789012',
        power: ';fgsdpr[bsdf['
      }
    ];

    TEST_CASES.forEach(testCase => {
      expect(true).toEqual(false);
      app.heroForm.statusChanges.filter(status => status !== STATUS.PENDING).subscribe(status => {
        expect(status).toEqual(STATUS.INVALID);
      });
      app.heroForm.setValue(testCase);
      app.heroForm.updateValueAndValidity();
    });
  }));

  it('should have heroForm created', async(() => {
    expect(app.heroForm).toBeTruthy();
  }));

});

Chrome 58.0.3029 (Linux 0.0.0) FormsComponent should be valid for these test cases. FAILED
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
Chrome 58.0.3029 (Linux 0.0.0): Executed 15 of 46 (1 FAILED) (0 secs / 2.242 secs)
Chrome 58.0.3029 (Linux 0.0.0) FormsComponent should be valid for these test cases. FAILED
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
	    at ZoneDelegate.invoke (webpack:///~/zone.js/dist/zone.js:391:0 <- src/app/polyfills.ts:3039:26)
	Expected true to equal false.
	    at webpack:///src/app/app/forms/forms.component.spec.ts:96:19 <- src/app/test.ts:65198:26
	    at Array.forEach (native)
	    at Object.<anonymous> (webpack:///src/app/app/forms/forms.component.spec.ts:95:15 <- src/app/test.ts:65197:20)
Chrome 58.0.3029 (Linux 0.0.0) Component: GridComponent should create component FAILED
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
Chrome 58.0.3029 (Linux 0.0.0): Executed 17 of 46 (2 FAILED) (0 secs / 2.358 secs)
Chrome 58.0.3029 (Linux 0.0.0) Component: GridComponent should create component FAILED
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
	    at Subscriber.Array.concat.Subscriber._next (webpack:///~/rxjs/Subscriber.js:125:0 <- src/app/test.ts:23250:26)
	Expected 'VALID' to equal 'INVALID'.
	    at SafeSubscriber._next (webpack:///src/app/app/forms/forms.component.spec.ts:98:23 <- src/app/test.ts:65200:32)
	    at SafeSubscriber.Array.concat.SafeSubscriber.__tryOrUnsub (webpack:///~/rxjs/Subscriber.js:238:0 <- src/app/test.ts:23363:16)
	    at SafeSubscriber.Array.concat.SafeSubscriber.next (webpack:///~/rxjs/Subscriber.js:185:0 <- src/app/test.ts:23310:22)
Chrome 58.0.3029 (Linux 0.0.0): Executed 46 of 46 (2 FAILED) (2.618 secs / 2.401 secs)
npm ERR! Test failed.  See above for more details.",yanisin13,NONE,2017-06-01 18:32:18+00:00,True,2017-06-02 12:37:38+00:00,0.75,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1366,HTML Snippet on README is Wrong,"Looking at the current README, I see instructions on putting the following HTML in your page (for in-browser usage)
<link rel=""shortcut icon"" type=""image/png"" href=""jasmine/lib/jasmine-core/jasmine_favicon.png"">
<link rel=""stylesheet"" type=""text/css"" href=""jasmine/lib/jasmine-core/jasmine.css"">

<script type=""text/javascript"" src=""jasmine/lib/jasmine-core/jasmine.js""></script>
<script type=""text/javascript"" src=""jasmine/lib/jasmine-core/jasmine-html.js""></script>
<script type=""text/javascript"" src=""jasmine/lib/jasmine-core/boot.js""></script>

If you download the latest release package, these links are not correct. The jasmine-core directory does not exist under `jasmine/lib'.",jongunter,NONE,2017-06-06 22:46:17+00:00,True,2017-06-06 22:59:35+00:00,0.01,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1367,(Some) async test fail after update to jasmine-core 2.6.3,"Our build started to fail on a few async tests after updating to jasmine 2.6.3
TypeError: JSON.stringify cannot serialize cyclic structures.

It's really easy to reproduce, by creating an async test that doesn't call done
it('tests nothing', (done) => {});
Might be related to commit 578f63b9bd34f75074a00b9a404b48d567dbe180
Using
jasmine 2.6.0
jasmine-core 2.6.3
webpack 2.6.1
karma 1.7.0
karma-jasmine 1.1.0",ambvdijk,NONE,2017-06-08 12:56:43+00:00,True,2017-07-28 17:40:08+00:00,50.2,,3,7,2017-06-12 21:16:46+00:00,4.35,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1369,"jasmine-html ""Ran X of Y specs - run all"" link clobbers the query string","Jasmine 2.6.3, after clicking on the Ran X of Y specs - run all link, none of the existing query string parameters are preserved, with the exception of random.
Expected result: the query string is preserved, and only the spec parameter is cleared out.",vais,NONE,2017-06-16 07:57:20+00:00,True,2017-06-16 21:08:16+00:00,0.55,,1,1,2017-06-16 08:06:53+00:00,0.01,vais,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1370,Did you forget to signal async completion?,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine (Jasmine npm, karma, etc),
consider filing an issue with that library if appropriate

When submitting an issue, please answer the following:

What version are you using?
What environment are you running Jasmine in (node, browser, etc)?
How are you running Jasmine (standalone, npm, karma, etc)?
If possible, include an example spec that demonstrates your issue.

Thanks for using Jasmine!",crvora,NONE,2017-06-16 14:52:32+00:00,True,2017-06-16 20:51:18+00:00,0.25,,2,3,2017-06-16 14:57:16+00:00,0.0,crvora,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1371,'npm package' test specs fail on Windows because tar is not a valid Windows command,"When running node_modules\.bin\grunt.cmd execSpecsInNode in Windows, six test specs consistently fail because tar is not a command available on Windows.
Failing specs are:

npm package has bootFiles
npm package has an imagesDir
npm package has a bootDir
npm package has a root path
npm package has cssFiles
npm package has jsFiles

Error message is the same in all of them:
  Message:
    Expected 1 to be 0.
  Stack:
    Error: Expected 1 to be 0.
      at Object.<anonymous> (c:\repos\jasmine\spec\npmPackage\npmPackageSpec.js:15:24)
      at ontimeout (timers.js:365:14)
      at tryOnTimeout (timers.js:237:5)
      at Timer.listOnTimeout (timers.js:207:5)
The output of require('shelljs').exec(...) reveals the followign error:
  stderr: '\'tar\' is not recognized as an internal or external command,\r\noperable program or batch file.\r\n',
  code: 1,
I guess this is expected since I can see from the setup instructions Ubuntu is the recommended dev environment.
Thanks,
Gilberto",kiewic,CONTRIBUTOR,2017-06-17 02:59:50+00:00,False,,,,2,1,2017-06-19 19:10:55+00:00,2.67,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1372,Trying to send an SMS via SMPP,"Hi there!
I'm actually trying to send a SMS via SMPP by using Jasmin, but i can't find the way to do it.
Once I'm designed smppcm
#Connector id                        Service Session          Starts Stops
#SMPP_INX                            started BOUND_TRX        1      0
a user:
#User id          Group id         Username         Balance MT SMS Throughput
#AN             J*                     AN         0.0     ND     ND/20.0
a group:
#Group id
#J*
a mtrouter:
#Order Type                    Rate       Connector ID(s)                                  Filter(s)
#0     DefaultRoute            0.01000    smppc(SMPP_INX)
In Logs:
2017-06-21 12:11:47 INFO     838 Added amqpBroker to SMPPClientManagerPB
2017-06-21 12:11:47 INFO     838 Added Redis Client to SMPPClientManagerPB
2017-06-21 12:11:47 INFO     838 Added RouterPB to SMPPClientManagerPB
2017-06-21 12:11:47 INFO     838 Loading/Activating [jcli-prod] profile configuration from //etc/jasmin/store/jcli-prod.smppccs
2017-06-21 12:11:47 INFO     838 Binding submit.sm.SMPP_INX queue to submit.sm.SMPP_INX route_key
2017-06-21 12:11:47 INFO     838 Added a new connector: SMPP_INX
2017-06-21 12:11:47 INFO     838 SMPPClientFactory-SMPP_INX is consuming from queue: submit.sm.SMPP_INX
2017-06-21 12:11:47 INFO     838 Started connector [SMPP_INX]
2017-06-21 12:12:06 INFO     838 Returning a list of 1 connectors
2017-06-21 13:04:06 INFO     838 Returning a list of 1 connectors
3091 SMS-MO [cid:SMPP_INX] [queue-msgid:XXXX] [status:ESME_ROK] [prio:LEVEL_0] [validity:None] [from:XXXX] [to:XXXX] [content:'Test']
If I execute this file:
GNU nano 2.3.1                        Fichero: file.py
import logging
from twisted.internet import reactor, defer
from jasmin.vendor.smpp.twisted.client import SMPPClientTransceiver, SMPPClientService
from jasmin.vendor.smpp.twisted.config import SMPPClientConfig
class SMPP(object):
def __init__(self, config=None):
    if config is None:
        config = SMPPClientConfig(host='IP', port=2775, username='A*N*', password='XXX')

        # Uncomment line below to recv SMS via ### only
        # config = SMPPClientConfig(host='localhost', port=999, username='uname', password='pwd', addressTon=$
    self.config = config

@defer.inlineCallbacks
def run(self):
    try:
        #Bind
        smpp = yield SMPPClientTransceiver(self.config, self.handleMsg).connectAndBind()
        #Wait for disconnect
        yield smpp.getDisconnectedDeferred()
    except Exception, e:
        print ""ERROR: %s"" % str(e)
    finally:
        reactor.stop()

def handleMsg(self, smpp, pdu):
    """"""
    NOTE: you can return a Deferred here
    """"""
    print ""Received pdu %s"" % pdu

if name == 'main':
logging.basicConfig(level=logging.DEBUG)
SMPP().run()
reactor.run()
python file.py
WARNING:smpp.twisted.client:Establishing TCP connection to 10.22.20.21:2775
WARNING:smpp.twisted.protocol:SMPP connection established from 10.22.20.21 to port 41628
WARNING:smpp.twisted.protocol:Requesting bind as transceiver
DEBUG:smpp.twisted.protocol:Sending PDU: PDU [command: bind_transceiver, sequence_number: 1, command_status: ESME_ROK
system_id: 'AN'
password: 'XXX'
system_type: ''
interface_version: 52
addr_ton: None
addr_npi: None
address_range: None
]
DEBUG:smpp.twisted.protocol:Sending data [00000025000000090000000000000001416972654e657400343172336e3374000034000000]
DEBUG:smpp.twisted.protocol:Outbound transaction started with message id 1
INFO:smpp.twisted.protocol:SMPP Client received PDU [command: bind_transceiver_resp, sequence_number: 1, command_status: ESME_ROK]
DEBUG:smpp.twisted.protocol:Received PDU: PDU [command: bind_transceiver_resp, sequence_number: 1, command_status: ESME_ROK
system_id: 'AN'
]
DEBUG:smpp.twisted.protocol:Receiving data [00000018800000090000000000000001416972654e657400]
DEBUG:smpp.twisted.protocol:Outbound transaction finished with message id 1
WARNING:smpp.twisted.protocol:Bind succeeded...now in state BOUND_TRX
INFO:smpp.twisted.protocol:SMPP Client received PDU [command: enquire_link, sequence_number: 1, command_status: ESME_ROK]
DEBUG:smpp.twisted.protocol:Received PDU: PDU [command: enquire_link, sequence_number: 1, command_status: ESME_ROK
]
DEBUG:smpp.twisted.protocol:Receiving data [00000010000000150000000000000001]
DEBUG:smpp.twisted.protocol:Sending PDU: PDU [command: enquire_link_resp, sequence_number: 1, command_status: ESME_ROK
]
DEBUG:smpp.twisted.protocol:Sending data [00000010800000150000000000000001]
So, what is exactly the purpose of this? What exactly do i have to do?
The map of all of this is that i'm connected to a SMSC which will send a SMS if I send a SMS to it but the only way to do this is via SMPP because this SMSC doesn't understand HTTP POST messages.
What I have to do is to create a phyton file to execute it and send the SMS to the SMSC?
Kind regards.",JFnine,NONE,2017-06-21 11:18:24+00:00,True,2017-06-21 14:43:08+00:00,0.14,,2,1,2017-06-21 14:43:08+00:00,0.14,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1373,"[Bug] Async expect fail not triggering done.fail(), timeout reached","Env info
Jasmine version: 2.6.0
Environment: Node 7.10.0
Test runner: karma with karma-jasmine
Description
Async tests that fail still wait for the timeout, an example below
it('Should be able to query existing products', (done) => {
        (async () => {
          try {
            const query = `{
              products {
                product_id
              }
            }`;

            const resp = await graphql(Schema, query, {}, context);
            expect(() => graphqlSpecErrorHandler(resp, `Product addProduct error`)).not.toThrow();
In example above the graphqlSpecErrorHandler function will throw, the spec is marked as failed but still waits for the timeout, in such case currently we're forced to use this boilerplate instead:
try {
    graphqlSpecErrorHandler(resp, `Product addProduct error`)
} catch (e) {
    done.fail(e)
}
However how to achieve the same with other simple expects? like this one for example:
expect(resp).toBeDefined()
If the previous expect succeeded, it would go on, but if failed, it will mark as failed but also wait for timeout, what to do here then?",luchillo17,NONE,2017-06-21 13:55:53+00:00,True,2017-06-21 18:42:38+00:00,0.2,,2,4,2017-06-21 18:42:38+00:00,0.2,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1374,Calling done.fail() after done() fails the test,"What version are you using?
2.6.4
What environment are you running Jasmine in (node, browser, etc)?
Chrome 59 on Windows 10
How are you running Jasmine (standalone, npm, karma, etc)?
Standalone
If possible, include an example spec that demonstrates your issue.
https://jsfiddle.net/w8q0xdsz/1/
https://jsfiddle.net/200nr56k/3/

It seems that an async test will fail if you call done.fail() after calling done():
describe('test', function() {
  it('an async test', function(done) {
    done();
    done.fail();
  });
});

I would have expected the done.fail() call to be ignored, as we have already said done(). So the test should be over and done. Nothing should be able to come back and fail it.
I ran in to this problem when I had the bright idea that I should make sure that my rxjs subscriptions are cleaned up after each test. So I used takeUntil and make sure that it was triggered in the afterEach method. But I was already making sure that complete wasn't being called, by calling done.fail inside the complete callback, and this now gets triggered when takeUntil triggers.",samal84,NONE,2017-06-21 16:15:59+00:00,True,2017-06-21 17:11:48+00:00,0.04,,2,1,2017-06-21 17:11:48+00:00,0.04,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1376,jasmine.any() runs out of memory on 2.6.4,"What version are you using?
2.6.4
What environment are you running Jasmine in (node, browser, etc)?
6.10.3
How are you running Jasmine (standalone, npm, karma, etc)?
Karma and yarn
If possible, include an example spec that demonstrates your issue.
it('should extend TagRequestsComponent', () => { expect(component).toEqual(jasmine.any(TagRequestsComponent)); });

After upgrading from 2.5.2 to 2.6.4 (also tested on 2.6.0 and issue happened too), the spec above stopped working. It's task is to check if the component extends TagRequestsComponent.
What happens is that my test times out and fails for being out of memory (Chrome reaches some 2.5gb of RAM usage). The other tests of this component and of TagRequestsComponent run normally (what makes me think that the problem is not on the component itself then).
The output follows (though it seems of little help):

RangeError: Invalid string length
at StringPrettyPrinter.append (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3831:20)
at StringPrettyPrinter.formatProperty (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3821:12)
at http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3814:12
at StringPrettyPrinter.PrettyPrinter.iterateObject (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3706:7)
at StringPrettyPrinter.emitObject (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3807:10)
at StringPrettyPrinter.PrettyPrinter.format (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3692:16)
at StringPrettyPrinter.formatProperty (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3826:14)
at http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3814:12
at StringPrettyPrinter.PrettyPrinter.iterateObject (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3706:7)
at StringPrettyPrinter.emitObject (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3807:10)",VictorJuliani,NONE,2017-06-22 11:43:02+00:00,True,2017-06-22 18:53:45+00:00,0.3,,2,1,2017-06-22 18:53:44+00:00,0.3,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1377,Uncaught ReferenceError: jasmineRequire is not defined,"I found the example on https://github.com/jasmine/jasmine#installation can be done by the webpack with html-webpack-plugin. Therefore I try to wire them up instead of hardcoding the script
// webpack.config.js

const path = require(""path""),
      webpack = require(""webpack""),
      HtmlWebpackPlugin = require('html-webpack-plugin'),
      ExtractTextPlugin = require(""extract-text-webpack-plugin""),
      jasmineCore = require(""jasmine-core"");

module.exports = {
  ""devServer"": {
    ""compress"": true,
    ""host"": ""0.0.0.0"",
    ""disableHostCheck"": true,
    ""clientLogLevel"": ""error""
  },
  ""entry"": {
    ""client"": path.resolve(__dirname, ""src/pages/Spec/Spec.web.tsx"")
  },
  ""module"": {
    ""rules"": [
      {
        ""test"": /\.spec\.tsx?$/,
        ""enforce"": ""pre"",
        ""loader"": ""tslint-loader"",
        ""options"": {
          ""configuration"": require(""./tslint.json""),
          ""tsConfigFile"": ""tsconfig.json"",
          ""fix"": true
        }
      },
      {
        ""test"": /\.tsx?$/,
        ""exclude"": /node_modules/,
        ""loader"": ""awesome-typescript-loader""
      },
      {
        ""test"": /jasmine\.css$/,
        ""use"": ExtractTextPlugin.extract({
          ""fallback"": ""style-loader"",
          ""use"": [""css-loader""]
        })
      },
      {
        ""test"": /\.scss$/,
        ""use"": ""null-loader""
      }
    ]
  },
  ""resolve"": {
    ""alias"": {
      ""jasmine"": path.resolve(jasmineCore.files.path, ""jasmine.js""),
      ""jasmine-core"": path.resolve(jasmineCore.files.path)
    },
    ""extensions"": ["".ts"", "".tsx"", "".js"", "".json"", "".jsx""]
  },
  ""output"": {
    ""filename"": ""[name].spec.js"",
    ""libraryTarget"": ""umd"",
    ""path"": path.resolve(__dirname, `spec`),
  },
  ""plugins"": [
    new HtmlWebpackPlugin({
      ""minify"": {
        ""removeComments"": true,
        ""collapseWhitespace"": true
      },
      ""filename"": ""index.html"",
      ""template"": path.resolve(__dirname, ""src/pages/Spec/Spec.ejs""),
      ""favicon"": path.resolve(jasmineCore.files.imagesDir, ""jasmine_favicon.png"")
    }),
    new ExtractTextPlugin(""[name]-[contenthash].css""),
  ],
  ""target"": ""web""
};


It compiles successfully but it fails in runtime. The error is Uncaught ReferenceError: jasmineRequire is not defined Then I compared the execution flow between the example and my webpack version. The issue in jasmine-core/lib/jasmine-core/jasmine.js
var jasmineRequire;

if (typeof module !== 'undefined' && module.exports && typeof exports !== 'undefined') {
           ^^^^^^

module and exports are Objects in my webpack version. But in standalone example, they are undefined. How can I move forward?",wood1986,NONE,2017-06-23 02:06:32+00:00,True,2017-06-23 18:01:28+00:00,0.66,,2,5,2017-06-23 05:18:57+00:00,0.13,wood1986,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1378,(promise) expect() instructions are not executed in finally clause without a catch clause,"jasmine-core 2.6.4 - expect() are not executed in finally clause when there is no catch clause.
Here is a plunker demo.
Run the tests with jasmine 2.6.4 :

the first test shows that expect in finally is not executed
the second test is the same as the first, with a catch clause in addition (spy is returning a resolved promise so catch is not ran here). Everything works fine in that case.

All of this is invisible before jasmine 2.6.3, because with jasmine <= 2.6.2, no expect are executed in finally clause at all.
To see this, activate the third test and link jasmine 2.6.2 instead (or any lower version) of 2.6.4 in the index.html.",MarcLoupias,NONE,2017-06-23 15:15:56+00:00,True,2017-10-26 19:27:07+00:00,125.17,,3,7,2017-06-24 00:30:20+00:00,0.38,sgravrock,MEMBER,2,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1379,Create a version of createSpyObj that accepts a constructor instead of a name.,"This is a feature request. And is useful mainly for typescript users.
The proposal is to have a version of createSpyObj that can be called with a constructor rather than a name. Maybe it could be called createSpyOf(ClassConstructor, ...params).
This would make typings in Typescript much easier to write and work with. For an overview of why it's hard to type the current function in an accurate way, see here: microsoft/TypeScript#10571 (comment)
By having a constructor as first argument rather than a string, both the mocked type as well as the list of keys being spied on could be inferred just from the parameters, and typescript developers would not need to specify them as generic parameters, which, as you can see from the comment linked above, is annoying for the list of keys being mocked.
In order to work with other things besides classes (e.g. typescript interfaces), ideally it would just get as first argument an object with a ""name"" property on it (something like a constructor). This way, we can pass a class constructor, but also anything else that has a name and carries a type.
The implementation in the jasmine world is pretty straightforward:
function createSpyOf(constructorLike, params) {
   return createSpyObj(constructorLike.name, params);
}
My second proposal would be to extend createSpyObj, but I notice from the implementation that it supports a mode of operation in which you only pass one JSON object as first argument and it mocks all its properties. Changing that behavior would break existing clients.
In any case, this increases the API surface of jasmine, and I understand it might be marginally useful to javascript developers, so I wanted to gather your feedback.",rubenlg,NONE,2017-06-23 18:03:30+00:00,True,2017-07-25 00:45:26+00:00,31.28,,2,2,2017-07-12 13:27:33+00:00,18.81,rubenlg,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1380,Please release this.emitMap soon,"Thanks for the great ES6 map fix, exactly what I was looking for. Is it possible to get a new npm release for jasmine-core with the commit please? It was committed almost two months ago.
Thanks!
5ee03f0",michaelcm,NONE,2017-06-23 18:46:47+00:00,True,2017-07-26 00:48:40+00:00,32.25,,2,3,2017-06-23 19:20:52+00:00,0.02,michaelcm,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1382,toBeCloseTo fails when expected value is different of exactly half of the allowed precision,"expect(350).toBeCloseTo(350.4, 0); => true as expected
expect(350).toBeCloseTo(350.5, 0); => false should be true
expect(350.5).toBeCloseTo(350.54, 1); => true as expected
expect(350.5).toBeCloseTo(350.55, 1); => false should be true
I think Math.abs(expected - actual) < (Math.pow(10, -precision) / 2) should be Math.abs(expected - actual) <= (Math.pow(10, -precision) / 2).",pvdlg,CONTRIBUTOR,2017-06-25 19:59:27+00:00,True,2017-06-26 17:56:33+00:00,0.91,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1384,Customise Report,https://sqa.stackexchange.com/questions/27936/unable-to-add-attach-screenshot-and-test-steps-in-report,vedant05,NONE,2017-06-26 09:13:17+00:00,True,2017-08-04 17:35:09+00:00,39.35,,3,2,2017-06-26 16:29:39+00:00,0.3,sgravrock,MEMBER,2,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1387,Not able to create spy on method,"My service is :
  var testappserviceone = angular.module('testappserviceonemodule',[])
    testappserviceone.factory('testappServiceone',[ function(){
    return function (x,y) {

         function addobj (x,y){
             return x+y;
         }

         return{
            add:addobj
         }
    }
   }]);

My test suite is :
describe('testappserviceone add method functionality', function(){
    beforeEach(function () {
        spyOn(testappServiceone(10,15),'add').and.callThrough();
    });

    it('testappServiceone add method functionality', function() {
        testappServiceone(10,15).add();
        expect(testappServiceone(10,15).add).toHaveBeenCalled();
    });
});

The Exception I am getting is :
Error: <toHaveBeenCalled> : Expected a spy, but got Function.
Usage: expect(<spyObj>).toHaveBeenCalled()

I think spy() is not creating a spy object . Please help me in understanding and solving this problem.",tak2ashokkumar,NONE,2017-06-28 09:04:06+00:00,True,2017-07-12 17:42:59+00:00,14.36,,4,4,2017-06-28 16:58:44+00:00,0.33,sgravrock,MEMBER,2,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1388,"If toEqual() fails, the error message always include all properties compared to jasmine.any()","When toEqual() fails, and the expected value uses jasmine.any(), all comparisons to jasmine.any() are listed as errors.
For example, the next spec succeeds:
it(""foo property equal"", function() {
    var actual = {
        foo: true,
        bar: 1987
    };
    var expected = {
        foo: true,
        bar: jasmine.any(Number),
    };
    expect(actual).toEqual(expected);
});
But changing only foo makes the test fail, and the error indicates foo and bar do not have the expected value.
it(""foo property different"", function() {
    var actual = {
        foo: false,
        bar: 1987
    };
    var expected = {
        foo: true,
        bar: jasmine.any(Number),
    };
    expect(actual).toEqual(expected);
});
This is the error message:
Expected $.foo = false to equal true.
Expected $.bar = 1987 to equal <jasmine.any(Number)>.

I'm using Jasmine 2.6.4 in a browser environment.
Thx",kiewic,CONTRIBUTOR,2017-06-29 02:01:53+00:00,True,2017-08-04 17:28:53+00:00,36.64,,2,1,2017-07-18 04:50:01+00:00,19.12,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1389,Error in object with toString having a jasmine.any value,"Using version 2.6.4 in node an browsers.
I have an error when expecting an object to have toString function using jasmine.any()
Example:
expect( {
  toString: () => {}
} ).toEqual( jasmine.objectContaining( {
  toString: jasmine.any( Function )
} ) )
These thows the error TypeError: value.toString is not a function.
It appears to be trying to use the toString, but it has an Any value.",roddolf,NONE,2017-06-29 17:47:01+00:00,True,2017-07-18 05:01:51+00:00,18.47,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1390,testing http calls from angular services,"My service is
var testappserviceone = angular.module('testappserviceonemodule',[])
testappserviceone.factory('testappServiceone',[function(){
    return function (handler) {
     function getData (){
        $http.get(handler.selection.selected.url).then(function (response) {
            handler.obj = JSON.parse(JSON.stringify(response.data));
       });
     }
     return{
        getData : getData
     }
   }
 }]);

From My controller , I will call the service like
  $scope.config = **testappServiceone(handler);

I am trying to test $http call made from testappServiceone.getData and test suite is
 describe('testappServiceone getData method functionality', function(){

    var apiSuccessResponse = {
          statuscode : 200,
          data : {
             responsedata : 'responsedata'
          }
     } 

    beforeEach(function (done) {
        spyOn(testappServiceone(handler),'edit').and.callThrough();
        httpBackend.expect('GET', handler.selection.selected.url).respond(apiSuccessResponse);
        testappServiceone(handler).edit();
        done();
    });

    it('method invokation', function() {
        expect(testappServiceone(handler).edit).toHaveBeenCalled();
    });

    it('http call mock part', function() {
        expect(handler.obj).toEqual(JSON.parse(JSON.stringify(apiSuccessResponse.data)));
    });

    afterEach(function(){
        httpBackend.flush();
        httpBackend.verifyNoOutstandingExpectation();
        httpBackend.verifyNoOutstandingRequest();
    });
 });

Every thing is working properly except
 it('http call mock part', function() {
     expect(handler.obj).toEqual(JSON.parse(JSON.stringify(apiSuccessResponse.data)));
 });

Exception is showing as
  Expected undefined to equal Object({ responsedata: 'responsedata' }).

Please help me in handling these scenarios",tak2ashokkumar,NONE,2017-06-30 06:01:11+00:00,True,2017-06-30 12:22:20+00:00,0.26,,1,1,2017-06-30 12:22:20+00:00,0.26,tak2ashokkumar,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1391,unexpected error throwed by jasmine at regular intervals,"I have a test file, which works fine, but at times an error is be thrown. For example if execute the test now it does not throw any error but if i execute few minutes later it throws this error
An error was thrown in an afterAll
AfterAll Expected null to be undefined.

And am not even using an afterAll in my test. I only used a beforeEach and afterEach
jasmine version:- jasmine v2.6.0
jasmine-core version: jasmine v2.6.1
Am presently using jasmine in node
This test is been ran with npm
I can't pinpoint which spec causes the above specified error, because it occurs whenever it wants to occur",zombieleet,NONE,2017-06-30 06:08:33+00:00,True,2017-06-30 10:43:50+00:00,0.19,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1392,Adding metadata to suites and specs,"Hi everyone,
thank you for the good job you made and you're making with Jasmine which is by far my favourite testing framework.
Before putting my hands in the code and creating a fork of Jasmine I would like to know if there's a less hacky way to achieve what I want.
Basically I'd like to add some metadata to suites and specs in order to have more detailed reports.
For example:
describe('Suite name', {date: Date.now(), detailedDescription: 'Super detailed description'}, function() {
    it('should work', {detailedDescription: 'Another super detailed description'}, function() {
        expect(true).toBeTruthy()
    });
})
I'd like to use the extended object this way:
const Reporter = {
    suiteStarted: (suite) => {
        console.log(`Suite started at ${suite.metdata.date}`)
    },
    specDone: (spec) => {
        console.log(`Description ${spec.metadata.detailedDescription}`)
    },
}
Is there any way to extend the object returned by describe or by spec?
I have of course tried (without any success):
let suite = describe('Suite name', function() {
    suite.date = Date.now();
   ...
})
Thank you in advance!",shikaan,NONE,2017-06-30 11:44:12+00:00,True,2017-10-26 19:29:08+00:00,118.32,,3,1,2017-07-20 04:27:28+00:00,19.7,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1393,Creating a spy on service not working,"** My target service is **
  var app = angular.module('testapp');
  app.factory('testAppServiceOne', function () {
         return function (count, page) {
               this.count = 0;
               this.currentPage = page;
          };
  });

** My current service is **
  var app = angular.module('testapp');
  app.factory('testAppService', function () {
         return function (count, currentPage) {
                     var getPageModel = function(){
                           return new testAppServiceOne(count, currentPage);
                     }
                      return {
                          getPageModel: getPageModel
                      };
          };
  });

** I am unit testing 'testAppService().getPageModel()' method and my test case is as follows**
describe('testAppService getPageModel method functionality -->', function(){
    var windowobj,testAppServiceObj;
    beforeEach(function (done) {
        testAppServiceObj = testAppService();
        spyOn(testAppServiceObj,'getPageModel').and.callThrough();
        windowobj = jasmine.getGlobal();
        spyOn(windowobj, testAppServiceOne);
        testAppServiceObj.getPageModel();
        done();
    });
    it('method should return testAppServiceOne object', function(){
        expect(windowobj.testAppServiceOne).toHaveBeenCalled();
    });

});

** The exception I am getting is **
   Error: <spyOn> : function (count,page)
   {__cov_yZntKTPynIMLK8OsQyDl5w.f['63']++;__cov_yZntKTPynIMLK8OsQyDl5w.s['145']++; 
   this.count=0; 
   __cov_yZntKTPynIMLK8OsQyDl5w.s['146']++; 
   this.currentPage=page;}() method does not exist

Please help in understanding and solving this issue.",tak2ashokkumar,NONE,2017-06-30 12:24:33+00:00,True,2017-07-06 05:09:47+00:00,5.7,,2,2,2017-07-05 16:39:01+00:00,5.18,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1395,Inconsistent behavior between matcher on Promise ,"I noticed a strange behavior when I was testing an Angular/TypeScript application with Jasmine matchers. Matchers that I believed should function similarly was not equally happy about promises.
I simplified the behavior to this:
// Won't compile
expect(Promise.resolve(42)).toBe(42);
expect(Promise.resolve(42)).toEqual(42);

// Will compile and asserts without problem
expect(Promise.resolve(42)).not.toBeGreaterThan(42);
expect(Promise.resolve(42)).toBeCloseTo(42);
expect(Promise.resolve(42)).toBeLessThan(43);
The compiler tells me that:
Argument of type '42' is not assignable to parameter of type 'Expected<Promise<number>>'.
Is this by design or a bug?
Versions
""jasmine-core"": ""2.6.4"",
""typescript"": ""2.3.4"", // (with 'es5' as target)
""angular/core"": ""4.2.3"",
""karma"": ""1.7.0"",
""protractor"": ""5.1.2""

Test runners
Same behavior in both karma and protractor.",jonatanskogsfors,NONE,2017-07-10 15:11:35+00:00,True,2017-07-10 16:22:24+00:00,0.05,,2,1,2017-07-10 16:22:24+00:00,0.05,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1396,spy.reset() not working for toHaveBeenCalledTimes ,"Jasmine: 2.5.2
Karma: 1.4.1
The method toHaveBeenCalledTimes does not get reseted when called spy.reset()
sample:

  it(""should get available years only once"", fakeAsync(() => {
    // Arrange
    getAvailableYearsSpy = spyOn(service, ""getAvailableYears"").and.returnValue(Promise.resolve([2015,2016,2017]);

    fixture.detectChanges();

    expect(getAvailableYearsSpy).toHaveBeenCalledTimes(1); // True

    getAvailableYearsSpy.reset();

    // Act
    anyMethodWhichCallsGetAvailableYearsAgain();

    tick();

    // Assert
    expect(getPrognoseMeldungSpy).toHaveBeenCalledTimes(1); // False -> called twice
  }));",dgroh,NONE,2017-07-11 21:32:46+00:00,True,2017-07-12 08:47:16+00:00,0.47,,3,4,2017-07-12 00:25:40+00:00,0.12,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1402,Sets & Maps should be compared irrespective of order,"Expected Behavior
ES6 Sets and Maps are most often used as unordered sets and maps, and I would expect the following tests to pass:
var setA = new Set([3, 6]);
var setB = new Set([6, 3]);
expect(setA).toEqual(setB); // pass

var mapA = new Map([['a', 3], [6, 1]]);
var mapB = new Map([[6, 1], ['a', 3]]);
expect(mapA).toEqual(mapB); // pass
Current Behavior
Jasmine matchers would fail the tests above, since the insertion order is considered for equality.
I would consider this behaviour a bug, since it's surprising to require the same order. As an analogy, Objects also retain insertion order, but Jasmine matches ignore the insertion order when comparing Objects.
Possible Solution
Can we change the tests and implementation to ignore insertion order for Sets and Maps, and thus match the expected behaviour?
If not, why not? Is there an alternative approach to providing order-agnostic matchers?
Suite that reproduces the behavior (for bugs)
The behaviour described above is enforced by the tests.",theefer,CONTRIBUTOR,2017-08-01 14:26:43+00:00,True,2017-08-04 16:23:45+00:00,3.08,,2,2,2017-08-02 00:43:40+00:00,0.43,slackersoft,MEMBER,1,1,0,0,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
1403,saveArgumentsByValue() saves primitive arguments as Object({ }),"Expected Behavior
saveArgumentsByValue() should save arguments of primitive types (passed by value) as it is.
Current Behavior
saveArgumentsByValue() saves arguments of primitive types (passed by value) as Object({ })
Suite that reproduces the behavior (for bugs)
it('test', () => {
            let service = { test: (x, y)=> { x.key = y; } };
            let testSpy = spyOn(service, 'test').and.callThrough();
            testSpy.calls.saveArgumentsByValue();
            let a = { key: 1 };
            let b = 2;
            service.test(a, b);
            expect(testSpy).toHaveBeenCalledWith(jasmine.objectContaining({ key: 1 }), 2);
        });
Message:
    Expected spy test to have been called with [ <jasmine.objectContaining(Object({ key: 1 }))>, 2 ] but actual calls were [ Object({ key: 1 }), Object({  }) ].

I went ahead and tried to run the condition check at 
  
    
      jasmine/src/core/CallTracker.js
    
    
         Line 14
      in
      9cb2f06
    
    
    
    

        
          
           if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\[object/)) { 
        
    
  

. I got the following results, so this check would always be true, which is incorrect.
λ node                                          
> Object.prototype.toString.apply(1)            
'[object Number]'                               
> Object.prototype.toString.apply('adad')       
'[object String]'                                
> Object.prototype.toString.apply({a:1})        
'[object Object]'                              
> Object.prototype.toString.apply(new Date())   
'[object Date]'                                 

Your Environment

Version used: 2.6.0
Environment name and version (e.g. Chrome 39, node.js 5.4): node 8.2.1
Operating System and version (desktop or mobile): Windows 10",kapil-ms,NONE,2017-08-01 18:58:55+00:00,True,2017-08-04 16:55:19+00:00,2.91,,2,1,2017-08-01 19:28:32+00:00,0.02,slackersoft,MEMBER,1,0,0,0,"['bug', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,True,False,False,False
1405,spyOn removes angular implict injector signiture,"Using Jasmine 2.6.4; Angular 1.5.12
class Foo {
  static bar($rootScope) {
    return true;
  }
}
describe('SpyOn', () => {
  it('static method foo should be called', inject(($injector) => {
       spyOn(Foo, 'bar');
       expect($injector.invoke(Foo.bar)).toBe(true);
     }));
});

Fails with this error:
Error: [$injector:unpr] Unknown provider: aProvider <- a
https://docs.angularjs.org/error/$injector/unpr?p0=aProvider%20%3C-%20a
For implicit injection, angular calls toString() on the method to get the argument names.   Here is what i see:
Foo.bar.toString() -> function (a) { return fn.apply(this, arguments); }
I believe the behavior changed with this change:
686d815
I have a workaround, where the test sets Foo.bar.$inject =[..] to make injection work.",dspattison-google,NONE,2017-08-01 22:17:02+00:00,True,2017-11-17 20:44:31+00:00,107.94,,2,2,2017-08-02 00:33:59+00:00,0.1,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1409,Clarify suite failed expectations and exceptions,"Current Behavior


Failed expectation or exception during beforeAll:
All children specs are reported as failed with the beforeAll failure.
It could be easier to spot the issue if it is clearer that the issue comes from beforeAll.


Failed expectation or exception during afterAll:
Failure is added as a failed expectation for the suite.


Exception during suite declaration:
An extra spec is added with the encountered exception.


Possible Solution

For beforeAll failures, disable specs and children suites in order to not report them.
Add beforeAll failed expectations in suite.failedExpectations (like afterAll does).
Add beforeAll, afterAll and suite declaration exceptions in a new suite.exceptions field.

In order to display it in a generic way, we could add an extra field origin in suite failed expectation and exception filled with ""beforeAll"", ""afterAll"" or ""suite declaration"".
Context
I am maintaining jasmine-spec-reporter and it would be very nice to provide the most specific and consistent information for these cases.
I would be glad to help if you think that it could be useful.",bcaudan,CONTRIBUTOR,2017-08-06 18:41:10+00:00,True,2018-01-26 18:00:54+00:00,172.97,,3,5,2017-08-10 00:37:05+00:00,3.25,slackersoft,MEMBER,2,1,0,0,"['feature request', 'has Tracker story', 'ready for work']",False,True,False,False,False,False,False,False,True,True,False,False,False,False,False
1410,Making toThrowError work with async function,Is there a way to leverage toThrowError in the context of an async function throwing an error?,DamienCassou,CONTRIBUTOR,2017-08-09 07:12:50+00:00,True,2017-10-26 19:38:43+00:00,78.52,,7,6,2017-08-09 22:40:05+00:00,0.64,slackersoft,MEMBER,2,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1413,"Disconnected, because no message in 10000 ms.","Jasmine 2.7.0 fails to launch headless Chrome (--no-sandbox) on Shippable node_js 7.4.0. As a workaround, reverting to 2.6.4 resolves the issue.
Logs copied below, for reference.
$ xvfb-run --server-args=""-ac"" yarn test

yarn run v0.24.5
$ ng test -cc -sr --progress false --reporters coverage-istanbul,junit,spec 

15 08 2017 04:11:53.934:INFO [karma]: Karma v1.7.0 server started at http://0.0.0.0:9876/
15 08 2017 04:11:53.937:INFO [launcher]: Launching browser Chrome --no-sandbox with unlimited concurrency
15 08 2017 04:11:53.943:INFO [launcher]: Starting browser Chrome
15 08 2017 04:12:36.062:INFO [Chrome 58.0.3029 (Linux 0.0.0)]: Connected on socket UAp0xuAyNMjtm4f6AAAA with id 80303544
15 08 2017 04:12:46.065:WARN [Chrome 58.0.3029 (Linux 0.0.0)]: Disconnected (1 times), because no message in 10000 ms.
Chrome 58.0.3029 (Linux 0.0.0) ERROR
  Disconnected, because no message in 10000 ms.
Chrome 58.0.3029 (Linux 0.0.0) ERROR
  Disconnected, because no message in 10000 ms.
Chrome 58.0.3029 (Linux 0.0.0) ERROR
  Disconnected, because no message in 10000 ms.

Chrome 58.0.3029 (Linux 0.0.0): Executed 0 of 0 DISCONNECTED (10.004 secs / 0 secs)

error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.

Please let me know if I can provide any further context or logs. 🙂 If you are already aware, please feel free to close this issue.",byrondover,NONE,2017-08-15 04:52:19+00:00,True,2017-10-15 10:30:00+00:00,61.23,,6,8,2017-08-15 16:54:04+00:00,0.5,slackersoft,MEMBER,1,0,0,6,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1414,Cannot spy on individual functions that are individually exported,"Having done a lot of research I cannot find a way to mock functions that are exported with no parent object. For example I'm trying to mock functions exported the following way:
module.exports = function thing(event) {};

OR in ES6
export function thing(event) {};

When importing these into a test file I try importing like this:
import {thing} from 'emvio-util-responses;  


//call some function that calls thing()

spyOn(???, 'thing').and.returnValue({});
expect(???.thing).toHaveBeenCalled();

I have tried many ways of accomplishing this but the mock is not called.
Some suggest importing * and providing an alias as a parent object. like this:
import * as SomeObj from 'emvio-util-responses;  


//call some function that calls thing()

spyOn(SomeObj , 'thing').and.returnValue({});
expect(SomeObj .thing).toHaveBeenCalled();

This doesn't work.
Others suggest using the window object
spyOn(window, 'thing').and.returnValue({});

But I'm in node :(.",kevinlbatchelor,NONE,2017-08-22 17:31:00+00:00,False,,,,13,28,2017-08-23 00:49:11+00:00,0.3,slackersoft,MEMBER,2,0,0,11,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1415,spyOnProperty does not work with object literals.,"Expected Behavior
I seem completely unable to override existing object literals to provide mock data during tests. Initially I tried with object properties 2 levels deep, but it seems that it also does not work even at the first level.
var foo = { 
  bar: ""test"",
  pizza: {
    toppings: ""cheese""
  }
};
spyOnProperty(foo, ""bar"", ""get"").and.returnValue(""baz"");
spyOnProperty(foo.pizza, ""toppings"", ""get"").and.returnValue(""pineapple"");
expect(foo.bar).toEqual(""baz"");
expect(foo.pizza.toppings).toEqual(""pineapple"");

Current Behavior
- Error: Property bar does not have access type get

Suite that reproduces the behavior (for bugs)

describe(""BASIC test of object properties"", () => {
    const foo = {
        bar: ""test"",
        pizza: {
            toppings: ""cheese""
        }
    };
    it(""test base-level object property"", () => {
        spyOnProperty(foo, ""bar"", ""get"").and.returnValue(""baz"");
        expect(foo.bar).toEqual(""baz"");
    });
    it(""test second level object property"", () => {
        spyOnProperty(foo.pizza, ""toppings"", ""get"").and.returnValue(""pineapple"");
        expect(foo.pizza.toppings).toEqual(""pineapple"");
    });
});

//   BASIC test
//    ✗ test base-level object property
//      - Error: Property bar does not have access type get
//    ✗ test second level object property
//      - Error: Property toppings does not have access type get
Your Environment

jasmine v2.7.0
jasmine-core v2.7.0
node.js v8.2.1
Mac OS X - Sierra",silverbucket,NONE,2017-08-23 12:31:09+00:00,True,2017-08-23 23:49:47+00:00,0.47,,2,2,2017-08-23 23:49:47+00:00,0.47,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1416,Behaviour of the “this” keyword,"After reading https://jasmine.github.io/2.8/introduction.html#section-The_%3Ccode%3Ethis%3C/code%3E_keyword I expected this to be empty for every single beforeEach/it/afterEach run. But when testing with jasmine 2.8 (on node 6.10) I found that it is only reinitialized for different spec files.
Thus it has no advantage over normal variables except that it has not to be declared.
If being reset on every it cycle it would become really good because one has not to worry about cleaning up the fragments of earlier specs.
Therefore I suggest that either:

this should be reinitialized on every beforeEach/it/afterEach cycle. This would disable the current available possibility to use it to share data from beforeAll, but that could be done with variables instead.

or:

this should be replaced by two global context objects (like spec and suite) which serve the purpose of this in the spec and suite context. spec would then be cleared on every it cycle while suite would be cleared on every spec file, only.",toaster,NONE,2017-08-27 07:21:56+00:00,True,2017-09-01 00:22:43+00:00,4.71,,2,5,2017-08-29 00:15:17+00:00,1.7,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1417,toThrowError(Error) does not fail the test correctly,"Suite that reproduces the behavior (for bugs)
This suit checks if the function throws TypeError:
describe('The function',function(){
  it('should throw TypeError',function(){
    function fun(){
      throw Error('message');
    }
    expect(fun).toThrowError(TypeError,'message');
  });
});
This sample works fine, it fails the test and return the message:
Expected function to throw TypeError with message 'message', but it threw Error with message 'message'.
This suit  checks if the function throws Error:
describe('The function',function(){
  it('should throw Error',function(){
    function fun(){
      throw TypeError('message');
    }
    expect(fun).toThrowError(Error,'message');
  });
});
And this sample does not work fine.
Expected Behavior
For me, it should fail the test and return the message:
Expected function to throw Error with message 'message', but it threw TypeError with message 'message'.
Current Behavior
It passed the test.
Your Environment


Version used: 2.8.0
Environment name and version (e.g. Chrome 39, node.js 5.4): 8.3.0
Operating System and version (desktop or mobile): Windows 10",devrafalko,NONE,2017-08-28 00:56:23+00:00,True,2017-08-29 01:09:36+00:00,1.01,,2,1,2017-08-29 00:27:09+00:00,0.98,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1419,It can't do some async work in the reporter hooks.,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Expected Behavior
I want to do some async work during the custom reporter hooks.
Current Behavior
It can't do async work in the custom reporter hooks.
custom reporter:
var reporter = {
    ....
    suiteDone () {
        //  It log nothing after 1s
         setTimeout(() => {
             console.log(123)
       }, 1000)
    },
    jasmineDone() {
        // It log nothing after 2s
          setTimeout(() => {
               console.log(456)
         }, 2000)
    }
}
Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context


Your Environment


Version used: 2.8.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 62
Operating System and version (desktop or mobile): Desktop
Link to your project:",CommanderXL,NONE,2017-09-07 03:26:48+00:00,True,2017-10-23 17:01:13+00:00,46.57,,2,1,2017-10-23 17:01:13+00:00,46.57,sgravrock,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1420,beforeEach timeout not reporting where the timeout occurs.,"Here is a trivial example where jasmine is not helping. It should at least say it failed in the beforeEach block on line 2
Using
jasmine v2.8.0
jasmine-core v2.8.0
TEST
describe('Timeout', () => {
  beforeEach((done) => {

  });

  it('Should work', () => {
    expect(true).toBe(true);
  });
});
FAILURE
Started
F

Failures:
1) Timeout Should work
  Message:
    Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
  Stack:
    Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.
        at ontimeout (timers.js:386:14)
        at tryOnTimeout (timers.js:250:5)
        at Timer.listOnTimeout (timers.js:214:5)

1 spec, 1 failure
Finished in 5.02 seconds",agirorn,NONE,2017-09-14 12:25:35+00:00,False,,,,4,5,2017-10-26 15:31:20+00:00,42.13,sgravrock,MEMBER,2,0,0,1,"['feature request', 'has Tracker story', 'ready for work']",False,True,False,False,False,False,False,False,True,True,False,False,False,False,False
1421,[Improvement] Spy on all functions in a class/object,"This is similar to issue #909. But, instead of just being able to have an object with spies on multiple functions with one function call, I would like to have a method like spyOnAllMethods(Instance of some class/object) which returns a spy object with all the functions of the provided instance are spies of the original functions.
Thanks!",yxliang01,NONE,2017-09-17 08:00:07+00:00,True,2018-07-25 00:55:57+00:00,310.71,,6,6,2017-11-17 20:57:42+00:00,61.54,slackersoft,MEMBER,1,1,0,4,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1422,[2.8.0] - Running out of memory on false(y) expectation.,"Hello,
I'm trying to run an expectation against a variable containing a DOM element for my Angular 4 specs, and one of the specs are causing the browser to go into an infinite loop and crash. I stumbled upon this when I changed the implementation of my tests. Where the element variable used to be null (see example below), it's now present on the DOM and is an instance of the DebugElement class. When it hits the expectation line it freezes, and with Task Manager open I can watch my computer's memory usage skyrocket (I actually let it go a bit too long once and my screen went black and had to reboot).
Expected Behavior
The test suite should not freeze, and my computer should not run out of memory and crash.
Current Behavior
The test suite freezes at the current spec and fills up my computer's memory until it crashes.
Possible Solution
I haven't gone through the jasmine source yet, so I'm not sure :/
Suite that reproduces the behavior (for bugs)
it('should not crash the computer', () => {
    let element = fixture.debugElement.query(By.css('div#container'));
    expect(element).toBeFalsy();
    expect(element).toBe(null); // this makes it crash as well...
});

Your Environment


Version used: jasmine-core@2.8.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 61.0.3163.100, Angular 4.0.0
Operating System and version (desktop or mobile): Windows 10 Professional
Link to your project: It's a private repository, sorry.",elliotwesoff,NONE,2017-09-28 13:29:14+00:00,True,2018-02-14 00:51:26+00:00,138.47,,5,5,2017-10-18 20:29:20+00:00,20.29,scottmcmaster,NONE,2,0,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1423,It block executed before beforeEach done() called,"Current Behaviour
I have a test which has some setup which does some async requests. I do the setup in a beforeEach function, and when all the promises resolve, it calls done(). However, I'm seeing that the it block is executed before the done() callback is executed. I've put a simple test together to show this.
Note that if I use beforeAll instead, it works.
Expected Behaviour
it block should not be executed until the done callback of beforeEach is called.
Suite that reproduces the behaviour (for bugs)
Example simple test:
describe('Test', function () {
    let flag = false;

    describe('simple test -', function () {
        beforeEach(function (done) {    
            var xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function () {
                if (this.readyState == 4 && this.status == 200) {
                    flag = true;
                    done();
                }
            };
            xhttp.open('GET', 'https://api.github.com/zen', true);
            xhttp.send();
        });
        it('should wait for done and set flag correctly', function () {
            expect(flag).toBe(true);
        });
    });
});

Context
I need to wait for network requests (promises) to resolve before running tests.
Your Environment
Jasmine v2.8.0
Karma v1.7.1
Webpack
Mac OS Sierra. Suite run inside Vagrant.
Console errors posted here: https://stackoverflow.com/questions/46604310/jasmine-beforeeach-not-waiting-for-done-callback",PhilBroadbent,NONE,2017-10-06 14:15:19+00:00,True,2018-01-22 20:39:34+00:00,108.27,,2,2,2017-10-23 17:39:38+00:00,17.14,sgravrock,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1425,Add command line option like --disallow-focused for jasmine which cause fail if there is any focused suites or specs,"It would be nice to have option like this, which can be used in pre-commit hook preventing not to commit focused suites or specs.",profiprog,NONE,2017-10-11 09:15:06+00:00,True,2018-02-14 00:02:50+00:00,125.62,,3,2,2017-10-23 16:56:11+00:00,12.32,sgravrock,MEMBER,2,0,0,0,"['has Tracker story', 'ready for work']",False,False,False,False,False,False,False,False,True,True,False,False,False,False,False
1426,fake clock does not allow one timer to clear another when they are scheduled for the same time,"The following test should pass, but it fails:
it('one timer can clear another even if they expire concurrently', () => {
  jasmine.clock().install();

  let timerId2;

  setTimeout(() => {
    console.log('timer1');
    expect(timerId2).not.toBeUndefined();
    clearTimeout(timerId2);
  }, 100);

  timerId2 = setTimeout(() => {
    console.log('timer2');
    fail();
  }, 100);

  jasmine.clock().tick(1000);

  jasmine.clock().uninstall();
});
I can see an argument that the order of these two might not be guaranteed, or shouldn't be relied upon, so maybe timer2 could fire first so timer1 can't clear it. However, the log output shows that timer1 does in fact fire first, so timer2 was cleared, and should not fire.
Tested using 2.8.0.",voltrevo,NONE,2017-10-11 09:17:42+00:00,True,2018-01-02 16:17:58+00:00,83.29,,2,1,2017-10-11 13:14:53+00:00,0.16,leahciMic,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1430,"Since Jasmine 2.7.0, it's not possible to spyOn(window, 'Function')","Are you creating an issue in the correct repository?

Expected Behavior
It should be possible to spyOn(window, 'Function')
Note that this is the Function constructor, not a user-defined function.


Current Behavior
jasmine throws a hard error that keeps the spec and suite from completing:
TypeError: Function.prototype.apply is undefined   jasmine.js:4236:11
clearTimeout jasmine.js:4236:11
  attempt/cleanup< jasmine.js:4247:11
  once/< jasmine.js:4172:9
  attempt jasmine.js:4306:7
  QueueRunner.prototype.run jasmine.js:4217:20
  QueueRunner.prototype.execute jasmine.js:4199:5
  queueRunnerFactory jasmine.js:909:7
  TreeProcessor/this.execute jasmine.js:5187:7
  Env/this.execute jasmine.js:983:7
  window.onload boot.js:144:5

Same happens for window.Function = jasmine.createSpy().and.callThrough();


Possible Solution


Suite that reproduces the behavior (for bugs)

it('should do something', function() {
  spyOn(window, 'Function');
  expect(true).toBe(true);
});
Live repro here: http://plnkr.co/edit/sCxS40pqfQuHdeKuZnNM?p=preview
In the plnkr, if your revert to 2.6.4 it works.
Context
We are using spyOn(window ... in the AngularJS test suite to check if the Function constructor is accessed, see https://github.com/angular/angular.js/blob/e58bcfab99450d2c4777d87a7ddfea19b9f38b5c/test/AngularSpec.js#L1041
We test this with karma. For some reason, in the karma setup, the 2.6.4 tests also fail. Not sure why it works in the plnkr.


Your Environment


Version used: 2.8.0, 2.7.0. Worked last in 2.6.4
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:",Narretz,NONE,2017-10-16 12:05:39+00:00,True,2017-10-24 15:30:21+00:00,8.14,,2,3,2017-10-23 15:58:05+00:00,7.16,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1431,jasmine.any(Symbol) does not match Symbol instances,"Expected Behavior
symbolObj instanceof Symbol actually returns false, so perhaps this is working as intended (even if a bit non-intuitive). But I'd expect a symbol instance to be treated as equal to jasmine.any(Symbol).
Current Behavior
Symbol instances are not equal to jasmine.any(Symbol).
Possible Solution
We could special-case Symbols in the equality checker to work with .any(Symbol).
Suite that reproduces the behavior (for bugs)
https://codepen.io/anon/pen/rGoXMz
Context


Your Environment


Version used: 2.8.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 61
Operating System and version (desktop or mobile): Linux",voithos,CONTRIBUTOR,2017-10-18 17:19:10+00:00,True,2017-10-24 15:18:29+00:00,5.92,,2,1,2017-10-23 21:52:10+00:00,5.19,sgravrock,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1432,[2.8.0] jasmine.anything() does not match Symbols as keys in Maps,"Expected Behavior
A Map object with a Symbol key is neither null nor undefined, so per the documentation for .anything(), it should be considered equal to a Map object with jasmine.anything() as the key.
Current Behavior
expect(symbol).toEqual(jasmine.anything()) works fine, but comparing 2 Map objects with Symbol and jasmine.anything() as keys, respectively, fails.
This used to be working in an earlier version of Jasmine, so is likely a regression?
Suite that reproduces the behavior (for bugs)
https://codepen.io/anon/pen/rGoXMz
Your Environment


Version used: 2.8.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 61
Operating System and version (desktop or mobile): Linux",voithos,CONTRIBUTOR,2017-10-18 17:22:35+00:00,True,2017-10-24 15:26:34+00:00,5.92,,2,2,2017-10-23 21:57:08+00:00,5.19,sgravrock,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1433,PhantomJs unable to process jasmine spyOnProperty,"Are you creating an issue in the correct repository?
Yes

I am spying on 2 of my properties using spyOnProperty and they are working good in intellij console for karma testing and debug mode in browser but when I run them using phantomjs they give me error mentioned below.
Code I am using to test
const div = fixture.debugElement.query(By.css('.xxxx'));
div.triggerEventHandler('mouseover', null);
fixture.detectChanges();
expect(component.tooltip.isOpen()).toBeFalsy();

// now spying on to see if its behavior changes
spyOnProperty(div.nativeElement, 'clientWidth', 'get').and.returnValue(1400);
spyOnProperty(div.nativeElement, 'scrollWidth', 'get').and.returnValue(2400);

###Error
PhantomJS 2.1.1 (Mac OS X 0.0.0) EllipsisOverflowComponent should show tooltip on mouse over of the element FAILED
	Error: clientWidth is not declared configurable in http://localhost:9877node_modules/jasmine-core/lib/jasmine-core/jasmine.js (line 4410)
	http://localhost:9877/_karma_webpack_/main.bundle.js:8593:22
	invoke@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12949:31
	onInvoke@http://localhost:9877/_karma_webpack_/vendor.bundle.js:136846:45
	invoke@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12948:40
	run@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12699:49
	http://localhost:9877/_karma_webpack_/vendor.bundle.js:136543:37
	http://localhost:9877/_karma_webpack_/vendor.bundle.js:183754:31
	invoke@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12949:31
	onInvoke@http://localhost:9877/_karma_webpack_/vendor.bundle.js:136080:45
	onInvoke@http://localhost:9877/_karma_webpack_/vendor.bundle.js:136843:47
	invoke@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12948:40
	run@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12699:49
	http://localhost:9877/_karma_webpack_/vendor.bundle.js:183749:28
	http://localhost:9877/_karma_webpack_/vendor.bundle.js:136069:46
	invokeTask@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12982:36
	runTask@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:12749:57
	invoke@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:13044:45
	timer@http://localhost:9877/_karma_webpack_/polyfills.bundle.js:14070:34

When debugged deep it looks like the error is in these lines and throwing this
  if (!descriptor.configurable) {
    throw new Error(propertyName + ' is not declared configurable');
  }

https://github.com/jasmine/jasmine/blob/master/src/core/SpyRegistry.js#L82-L95
https://github.com/jasmine/jasmine/blob/master/src/core/util.js#L62-L76
Expected Behavior


Should spy on properties
Current Behavior


Throwing Error: clientWidth is not declared configurable in http://localhost:9877node_modules/jasmine-core/lib/jasmine-core/jasmine.js (line 4410)
Possible Solution


Should work in all condition
Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context


Unable to run the test
Your Environment


Version used: 2
Environment name and version (e.g. Chrome 39, node.js 5.4): angular cli phantomjs
Operating System and version (desktop or mobile): mac
Link to your project: internal",aniruddhadas9,NONE,2017-10-18 22:55:22+00:00,True,2017-10-23 22:18:12+00:00,4.97,,2,1,2017-10-23 22:18:12+00:00,4.97,sgravrock,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1434,angular.mock.module causing a break in testing,"I am attempting to run some tests but keep getting a break in the build, here is my error:
 C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:443181 forEach@C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:172615 loadModules@C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:440391 createInjector@C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:301303 WorkFn@C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:164286 inject@C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:162795 C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:3371 TypeError: undefined is not a constructor (evaluating '$compile('<bss></bss>')') in C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js (line 9) C:/Users/schmitzb/Projects/RCO/rco-project/test/index.js:9:4189 PhantomJS 2.1.1 (Windows 7 0.0.0): Executed 4 of 4 (1 FAILED) (0.109 secs / 0.084 secs)
Here is the test I am trying to run:
`import * as angular from 'angular';
 import 'angular-mocks';
 import 'modules/bss/bss.component';

describe('bssGrid', function () {
beforeEach(angular.mock.module('app.modules.bss'));

var $compile: angular.ICompileService;
var $rootScope: angular.IRootScopeService;
var $q: angular.IQService;

beforeEach(function () {
	inject(function (_$compile_, _$rootScope_, _$q_) {
		console.log('hey there');
		$compile = _$compile_;
		$rootScope = _$rootScope_;
		$q = _$q_;
	});
});

it('should display the component', function () {
	// Compile a piece of HTML containing the directive
	var element = $compile('<bss></bss>')($rootScope);

	// fire all the watches
	$rootScope.$digest();

	// Check
	var html = element.html();
	expect(html).toBe(true);
 });
});`

I am trying to test this component:
 `angular.module('app.modules.bss', [
   'app.services.bss',
   'ui.grid',
  'ui.grid.edit',
  'ui.grid.treeView',
  'ui.grid.resizeColumns',
  'ui.grid.cellNav',
  'ui.grid.selection',
  'ui.grid.autoResize',
  'ui.grid.exporter',
  'ui.grid.pinning',
  'app.modules.newVolumeTarget',
  // 'app.modules.targetDefType',
  'app.modules.newVolumeType',
  'app.modules.uigridtemplates.bss-cell',
  'app.modules.targetDefType.select-formula'
   ]).component('bss', {
	bindings: {},
	controller: BssComponent,
	template: require('./bss.html')
})`

   `export class BssComponent {
     public static $inject = ['bssService', 'uiGridTreeBaseService', '$timeout', '$scope', 'ersModalService', '$location', '$window', '$q', '$interval', 'uiGridConstants', '$uibModal'];

           // variables defined here

     constructor(bssService: BssService, uiGridTreeBaseService, $timeout, $scope, ersModalService, $location, $window, $q, $interval, uiGridConstants, $uibModal) {
         // rest of controller code sits here
   }
 }

`
This line of code seems to be breaking my test:
beforeEach(angular.mock.module('app.modules.bss'));
When I run this test, it works fine:
 `import * as angular from 'angular';
  import 'angular-mocks';
  import 'components/layout/header-bar/header-bar.component';

describe('heaaderBar', function() {

beforeEach(angular.mock.module('app.components.layout.header-bar'));

var $compile: angular.ICompileService;
var $rootScope: angular.IRootScopeService;
var $q: angular.IQService;	

var mockFilter = function(value) {
	return value;
};

beforeEach(function() {
	angular.mock.module(function($provide) {
		$provide.value('translateFilter', mockFilter);
	});
});

beforeEach(angular.mock.inject(function(_$compile_, _$rootScope_, _$q_) {
	// The injector unwraps the underscores (_) from around the parameter names when matching
	$compile = _$compile_;
	$rootScope = _$rootScope_;
	$q = _$q_;
}));

it('should display the component', function() {
	// Compile a piece of HTML containing the directive
	var element = $compile('<header-bar></header-bar>')($rootScope);

	// fire all the watches
	$rootScope.$digest();

	// Check
	var html = element.html();
	expect(html).toBeTruthy();
 });	
 });

`
Is there something that has changed that I need to update in regards to using a specific test?
I am using Angular 1.5.5 and Angular Mocks 1.5.5. Thanks!",bschmitz9,NONE,2017-10-20 21:37:05+00:00,True,2017-12-21 16:03:58+00:00,61.77,,2,2,2017-10-23 16:14:10+00:00,2.78,sgravrock,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1438,jasmine.createSpy() with no arguments - is it discouraged?,"Coming from the world of Sinon where stub()/spy() doesn't take in a string name, jasmine.createSpy(""methodName"") seems unnecessary:
const stubLogger = () => {
    const clock = lolex.createClock();
    const { setTimeout } = clock;
    const onLog = jasmine.createSpy(""onLog"");

    const logger = new Logger({ onLog, setTimeout });

    return { clock, logger, onLog };
};
All the jasmine.github.io samples pass a string to createSpy, and the TypeScript definition marks name as mandatory:
function createSpy(name: string, originalFn?: (...args: any[]) => any): Spy;
Is it discouraged to not pass a name? I'd prefer not to unless there's a good technical reason?",JoshuaKGoldberg,NONE,2017-10-26 03:09:25+00:00,True,2017-10-26 18:22:30+00:00,0.63,,2,2,2017-10-26 14:56:18+00:00,0.49,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1439,Expected undefined to equal 'G'. at UserContext.<anonymous> (...\rna-transcription.spec.js:6:39),"# This is my rna-transcription.js
var DnaTranscriber = function (input) {
this.Dna = input;
};
DnaTranscriber.prototype.toRna = function () {
var DNA = this.Dna;
if(DNA == 'G'){
      return 'C';
} else if(DNA == 'C'){
    return 'G';
} else if(DNA == 'T'){
    return 'A';
} else if(DNA == 'A'){
    return 'U';
}

//
};
module.exports = DnaTranscriber;
# This is rna-transcription.spec.js
var DnaTranscriber = require('./rna-transcription');
var dnaTranscriber = new DnaTranscriber();
describe('toRna()', function () {
it('transcribes cytosine to guanine', function () {
expect(dnaTranscriber.toRna('C')).toEqual('G');
});
xit('transcribes guanine to cytosine', function () {
expect(dnaTranscriber.toRna('G')).toEqual('C');
});
xit('transcribes adenine to uracil', function () {
expect(dnaTranscriber.toRna('A')).toEqual('U');
});
xit('transcribes thymine to adenine', function () {
expect(dnaTranscriber.toRna('T')).toEqual('A');
});
xit('transcribes all dna nucleotides to their rna complements', function () {
expect(dnaTranscriber.toRna('ACGTGGTCTTAA'))
.toEqual('UGCACCAGAAUU');
});
xit('correctly handles completely invalid input', function () {
expect(function () { dnaTranscriber.toRna('XXX'); }).toThrow(
new Error('Invalid input')
);
});
xit('correctly handles partially invalid input', function () {
expect(function () { dnaTranscriber.toRna('ACGTXXXCTTAA'); }).toThrow(
new Error('Invalid input')
);
});
});
I got this failure:

toRna() transcribes cytosine to guanine
Message:
Expected undefined to equal 'G'.
Stack:
Error: Expected undefined to equal 'G'. at UserContext. (..\rna-transcription.spec.js:6:39)",jfmojicas,NONE,2017-10-26 05:01:38+00:00,True,2017-11-03 00:56:21+00:00,7.83,,2,1,2017-10-26 15:39:06+00:00,0.44,sgravrock,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1441,Type definition of custom matchers cannot be merged to Matcher<T> interface,"I'm working on Typescript. I created following custom matcher.

matcher.ts

export const customMatchers: any = {
  toBeAt: (util, customEqualityTesters) => {
    return {
      compare: (actual, expected) => {
        return {
          pass: actual.isClose(expected, 0.00001)
        }}}}
};

... and this is the type definition to be merged to jasmine.Matcher<T> interface.


matcher.d.ts

declare namespace jasmine {
  interface Matchers<T> {
    toBeAt(expected: any): boolean;
  }

But typescript compiler complains TS2551: Property 'toBeAt' does not exist on type 'Matchers<any>'. why?",kota65535,NONE,2017-10-28 10:19:52+00:00,True,2017-11-03 00:56:41+00:00,5.61,,2,2,2017-11-02 16:42:02+00:00,5.27,sgravrock,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1442,extend createSpyObj to support properties,"Expected Behavior
Currently i cant create nicely spy object full of methods, but what if i need to mix some properties and methods?
Current Behavior
currently createSpyObj creates only methods
Possible Solution
another array argument 'propertyNames' just like ;methodNames' could solve problem.
Properties would return default values until i use spyOnProperty.
Context
That's my typescript,  i hope it could be less ugly:
let mockRouter: jasmine.SpyObj<Router>;

mockRouter = jasmine.createSpyObj('mockRouter', ['navigateByUrl']);

mockRouter = {
  ...mockRouter,
  events: Observable.of(...routerEvents),
} as jasmine.SpyObj<Router>;",Plondrein,NONE,2017-10-28 20:44:42+00:00,True,2019-06-25 23:27:15+00:00,605.11,,12,18,2017-11-02 16:43:05+00:00,4.83,sgravrock,MEMBER,2,1,0,8,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
1443,How to await async functions wrapped with spyOn() ?,"In my test code I got undefined returned for some async functions wrapped with spyOn().
I then created a codepen to reproduce, and here it times out.
https://codepen.io/anon/pen/wPvLeZ
Can I use spyOn() with async functions and how do I await them?",angularsen,NONE,2017-10-29 17:01:58+00:00,True,2017-10-30 17:35:02+00:00,1.02,,3,3,2017-10-30 15:20:06+00:00,0.93,sgravrock,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1444,Set comparison is broken.,"I'm using jasmine version 2.8.0
Expected Behavior
describe(""test"", function() {
  it(""work"", function() {
    const refs1 = new Set([
      ['a', 'a'],
      ['b', 'b'],
    ]);
    const refs2 = new Set([
      ['a', 'a'],
      ['b', 'b'],
    ]);
    expect(refs1).toEqual(refs2);
  });
});


I'm expecting this test to pass.
Current Behavior
The test does not pass.
Possible Solution
Revert acc8c23
or merge #1445",b-3-n,CONTRIBUTOR,2017-10-31 20:07:32+00:00,True,2017-11-02 15:17:19+00:00,1.8,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1447,Suggestion: Expect should also handle promises,"Expected Behavior
Currently Jasmine supports async code in before*, after* and it blocks. I think it would be a great addition to the framework if the expect function could handle promises as well. The main reasons that come to my mind are:

Code would be less verbose
We would be able to use some existent matchers, improving the console output

Current Behavior
Currently, if one wants to test if an async function throws, this is one possible way out:
it('throws an error on invalid argument', async () => {
  let error;
  try {
    await methodBeingTested(invalidArgument);
  } catch (err) {
    error = err;
  }
  expect(error).toEqual(ExpectedError);
});
If expect did handle async code, one could just do:
it('throws an error on invalid argument', async () => {
  expect(async () => {
    await methodBeingTested(invalidArgument);
  }).toThrow(ExpectedError);
});
Possible Solution
I don't know how Jasmine's internals work, so I think any solution I could provide here would be too naive. =/
Context
There's much async code to be tested nowadays. Async before*, after* and it blocks handle almost every situation I can think of, except by the case described above. If expect could handle async code as well, I think the framework would be more feature complete. =)",danielalves,NONE,2017-11-07 16:21:52+00:00,True,2017-11-07 17:13:05+00:00,0.04,,5,6,2017-11-07 17:13:05+00:00,0.04,sgravrock,MEMBER,2,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1449,calling pending() on async fn will fail the test,"Suite that reproduces the behavior (for bugs)
describe('GIVEN I have pending scenarions ', () =>  {
  it('and initial test callback is marked as async', async () => {
    pending('it causes a failure');
  });
  it('and second one is just with a normal done callback', done => {
    pending('it gets marked as pending and does not cause a failure');
    done();
  });
});
Output:
Started
F*

Failures:
1) GIVEN I have pending scenarions  and initial test callback is marked as async
  Message:
    Failed: => marked Pendingit causes a failure
  Stack:
    Error: Failed: => marked Pendingit causes a failure
        at <anonymous>
        at runMicrotasksCallback (internal/process/next_tick.js:121:5)
        at _combinedTickCallback (internal/process/next_tick.js:131:7)
        at process._tickCallback (internal/process/next_tick.js:180:9)
Pending:

1) GIVEN I have pending scenarions  and second one is just with a normal done callback
  it gets marked as pending and does not cause a failure

2 specs, 1 failure, 1 pending spec
Finished in 0.005 seconds

Expected outcome:
Both tests should be marked as pending and who spec should not have failures.
Current behaviour:
First testcase fails.
Context


Your Environment
node version: 8.7.0
jasmine: 2.8.0
windows 10 cmd & cygwin console.",rasjani,NONE,2017-11-13 11:03:50+00:00,True,2017-11-29 16:57:09+00:00,16.25,,3,1,2017-11-29 01:37:40+00:00,15.61,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1450,Async `pending` fails the spec when used with Promises,"The work done to handle global errors in async specs using the done callback correctly collects the pending exception and marks the spec appropriately. When calling pending from within a Promise returned by a spec, it is treated as a Promise failure and doesn't mark the spec as pending.
Example suite:
it('done pends', function(done) {
  setTimeout(pending, 10);
});

it('promise pends', function() {
  return new Promise(function () {
    pending('promise');
  });
});
Output:
npm test

> tester@ test /Users/gregg/workspace/tester
> jasmine --config=jasmine.json

Started
*F

Failures:
1) promise pends
  Message:
    Failed: => marked Pendingpromise
  Stack:
    Error: Failed: => marked Pendingpromise
        at runMicrotasksCallback (internal/process/next_tick.js:58:5)
        at _combinedTickCallback (internal/process/next_tick.js:67:7)
        at Immediate._tickCallback (internal/process/next_tick.js:98:9)
        at runCallback (timers.js:651:20)
Pending:

1) done pends
  No reason given

2 specs, 1 failure, 1 pending spec
Finished in 0.022 seconds

Possible Solution
It looks like the Spec object only checks for the isPendingSpecException when handling an exception, but the QueueRunner passes Promise failures along via fail which causes them to skip this logic and go directly to the expectation failure handler.
The goal of using fail in QueueRunner was to not have to duplicate the continuation logic, but it probably needs to change to handle a Promise rejection as an Error and then continue on after that.
Your Environment

Version used: jasmine 2.8
Environment name and version nodejs v7.5.0 (and others)

We would be happy to review a pull request that addresses this issue.",slackersoft,MEMBER,2017-11-17 21:17:57+00:00,True,2017-11-29 16:57:09+00:00,11.82,,6,14,2017-11-29 01:37:32+00:00,11.18,slackersoft,MEMBER,2,0,0,4,"['bug', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,True,False,False,False
1451,Run code before beforeEach for each it,"Context
I would like to have a new type of test with I can reduce the repetition or code.
The problem happens if I have mocked something for the component and little changes needed to be done to the mocks. (e. g. for this test I need another value for test 6) In the beforeEach I create the component, with the dependencies. If I do the modification in the it the component is created and I can't apply changes to the mock for the creation part.
Current Behavior
class Component {
  constructor(service) {
    this.data = service.ex();
  }
}
Fails:
describe('component', () => {
  const mock = {
    ex() { return 1; }
  };
  let component;
  beforeEach(() => {
    component = new Component(mock);
  });
  it('test 1', () => {
    expect(component.data).toEqual(1);
  });
  it('test 2', () => {
    spyOn(mock, 'ex').and.returnValue(2); // The component is created, it is too late to set value.
    expect(component.data).toEqual(2);
  });
});
A workaround can be:
describe('component', () => {
  const mock = {
    ex() { return 1; }
  };
  let component;
  it('test 1', () => {
    component = new Component(mock);
    expect(component.data).toEqual(1);
  });
  it('test 2', () => {
    spyOn(mock, 'ex').and.returnValue(2);
    component = new Component(mock);
    expect(component.data).toEqual(2);
  });
});
Possible Solution
describe('component', () => {
  const mock = {
    ex() { return 1; }
  };
  let component;
  beforeEach(() => {
    component = new Component(mock);
  }, {
    name: 'creation'
  });
  it('test 1', () => {
    expect(component.data).toEqual(1);
  });
  it('test 2', () => {
    expect(component.data).toEqual(2);
  }, {
    before:{
      creation: () =>  spyOn(mock, 'ex').and.returnValue(2); // The component is not created.
    }
  });
});
Sometimes the code of creation is not one line and it is really annoying if the test file has the same lines in most of the tests. E. g. in angular code, that uses jasmine to test.",csutorasr,NONE,2017-11-20 18:41:25+00:00,True,2018-02-27 01:10:46+00:00,98.27,,2,2,2017-11-21 01:09:16+00:00,0.27,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1452,Failing to add custom matchers. v2.8.0,"This is my test-runner.js which i run with npm test command.
const jasmine = new Jasmine({ projectBaseDir: __dirname });
jasmine.loadConfig({});

jasmine.addMatchers(customMatchers);
jasmine.execute(
  glob.sync('tests/e2e/**/*.spec.js')
      .map(p => path.relative(__dirname, p))
);
What is going wrong
I see an error TypeError: this.jasmine.Expectation.addMatchers is not a function
Environment

jasmine v2.8.0
node v7.7.3",EugenAz,NONE,2017-11-26 12:18:24+00:00,True,2017-11-28 01:38:31+00:00,1.56,,2,1,2017-11-28 01:39:59+00:00,1.56,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1453,Jasmine fails on errors in React 16 components,"Expected Behavior


The test should be green
Current Behavior


Test fails.
Possible Solution


Suite that reproduces the behavior (for bugs)

A React component has an error which is caught by an Error Boundary. React prints the error in console and Jasmine fails the test.
CodePen
Context


Not sure if it's desired behavior in Jasmine.
Your Environment


Version used: 2.8.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 62, Node 8.9.1
Operating System and version (desktop or mobile): Ubuntu 17.04 (4.10.0-40-generic)
Link to your project:",the-spyke,NONE,2017-11-27 14:38:47+00:00,False,,,,5,11,2017-11-27 16:55:30+00:00,0.09,sgravrock,MEMBER,2,0,0,3,"['React', 'ready for work']",False,False,False,False,False,False,True,False,False,True,False,False,False,False,False
1454,Possible to wait for stdin before continuing tests ?,"https://stackoverflow.com/questions/47588851/waiting-for-stdin-from-a-jasmine-test-script
pseudo code:
describe(""Checking OTP"", function () {

    it(""it should be valid "", function () {
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        rl.question('Enter OTP:', (answer) => {

            rl.close();

            fetch.post(""/verifyOTP"", {
                otp: answer
            }).then(response => {

                it(""..testing the next step"", function () {
                    //...
                })
            })
        });
    })
})",jigarvyas,NONE,2017-12-01 11:53:15+00:00,True,2017-12-21 16:04:31+00:00,20.17,,2,1,2017-12-01 16:51:59+00:00,0.21,sgravrock,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1455,Async test passes in 2.6.2 but fails in 2.8.0,"This issue is related to nrwl/nx#127
The following test runs fine with version 2.6.2 but fails with version 2.8.0
  describe('someEffect', () => {
    it('should work', async () => {
      actions = hot('-a-|', { a: { type: 'LOAD_DATA' } });
      expect(await readAll(effects.loadData)).toEqual([{ type: 'DATA_LOADED', payload: {} }]);
    });
  });

In version 2.8.0, I get this error:
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.

Do I need to change any settings to make the test work?",dereklin,NONE,2017-12-02 00:19:02+00:00,True,2017-12-02 01:57:30+00:00,0.07,,3,4,2017-12-02 00:36:01+00:00,0.01,sgravrock,MEMBER,2,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1456,Jasmine doesn't unregister some spy on IE11,"I am using spyOn(window, 'onerror') to test some uncaught exceptions. It works well in most browsers, except on IE11 where I get a Error: <spyOn> : onerror has already been spied upon in the second test case using this pattern.
Expected Behavior
Jasmine should remove the spy on window.onerror after the first test case.
Current Behavior
Jasmine isn't removing the spy on window.onerror after the first test case.
Possible Solution
This issue is caused by a bug in IE11 (and probably before, but I guess we don't care anymore):
function foo() {}
window.onerror = foo;
console.log(window.hasOwnProperty(""onerror"")); // false
delete window.onerror;
console.log(window.onerror === foo); // true
Because of this, jasmine doesn't remove the spy in SpyRegistry, because it never do obj[methodName] = originalMethod.
Suite that reproduces the behavior (for bugs)
You can reproduce this by running this jsbin in IE11: http://jsbin.com/xumakorezo/1/edit?js,output
describe(""aa"", function() {
  it(""bb"", function () {
    spyOn(window, ""onerror"");
  })
  it(""cc"", function () {
    spyOn(window, ""onerror"");
  })
});
Your Environment


Version used: 2.8
Environment name and version: IE11
Operating System and version (desktop or mobile): Windows 10",BenoitZugmeyer,NONE,2017-12-04 15:49:35+00:00,True,2017-12-19 00:53:41+00:00,14.38,,2,2,2017-12-04 16:46:06+00:00,0.04,sgravrock,MEMBER,1,0,0,0,"['bug', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,True,False,False,False
1457,toEqual doesn't display given failure message,"When using the toEqual matcher and passing in the optional expectationFailOutput message, the message will not display when the assertion fails.
Expected Behavior
The expectationFailOutput message should display for .toEqual when the assertion it is attached to fails.
Current Behavior
the expectationFailOutput message does not display for .toEqual when the assertion it is attached to fails.
Possible Solution
Not sure why this is happening; perhaps it was changed in a recent build.
Suite that reproduces the behavior (for bugs)
https://codepen.io/willwsharp/pen/LOvxJd?editors=1010
Context
It's very helpful to immediately see which assertion failed when working in specs with multiple assertions.
Your Environment
Jasmine 2.8",willwsharp,NONE,2017-12-05 15:27:03+00:00,True,2017-12-06 01:22:40+00:00,0.41,,4,5,2017-12-06 01:22:40+00:00,0.41,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1458,Hide disabled specs/gray balls in the html report,"Expected Behavior
When running single spec- expected to only see html reporter only show focused spec. This used to be the case in 2.2.0, not anymore in 2.5.0 for example.
Current Behavior
It shows all the specs - which if you have thousands of tests makes the UI/run slow.
Possible Solution
display: none; in jasmine.css for disabled specs like in AlexBerson/karma-jasmine-html-reporter@f263fa6 ?
Suite that reproduces the behavior (for bugs)
N/A for this issue?
Context
Debugging/running single spec while watching html is painfully slow on newer versions of Jasmine.
Your Environment

Version used: 2.8.0, 2.5.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 62, node 7
Operating System and version (desktop or mobile): N/A
Link to your project: N/A I guess?",mkj28,NONE,2017-12-06 07:25:39+00:00,True,2018-10-22 18:55:04+00:00,320.48,,3,3,2017-12-06 16:37:42+00:00,0.38,sgravrock,MEMBER,2,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1459,Testing asnyc (Promise) methods in Angular 2 Services,"This is an interesting problem: I'm trying to test a Service, that uses the Ionic BarcodeScanner. I have a repo based on the ionic unit-testing repository in order to try testing. I'm mocking the BarcodeScanner.scan method via spyOn(..).and.callFake(..)
Expected Behavior


The following test code should work for both components and services.
Current Behavior


It just works for components.
Possible Solution


Suite that reproduces the behavior (for bugs)

This works (component).
it(""should be able to set a spy on the scanner and test the component"", done => {
        const testBC = ""123456"";
        const spy = spyOn(TestBed.get(BarcodeScanner), ""scan"");
        spy.and.callFake(() => {
            return new Promise((resolve, reject) => {
                resolve(testBC);
            })
        });

            component.testScanner().then(res => {
                expect(res).toBe(testBC);
                done();
            }, reason => {
                expect(true).toBe(false);
                done();
            })
    });
This does not work (service):
it(""should be able to set a spy on the scanner and test the service"", done => {
        const testBC = ""123456"";
        const spy = spyOn(TestBed.get(BarcodeScanner), ""scan"");
        spy.and.callFake(() => {
            return new Promise((resolve, reject) => {
                resolve(testBC);
            })
        });

        inject([TestService], (service) => {
            service.testScanner().then(res => {
                expect(res).not.toBe(testBC);
                done()
            }, reason => {
                expect(true).toBe(false);
                done();
            })
        })
    });
Context


I'm trying to unit test a service that uses the barcode-scanner and then does some stuff with the result..
Your Environment


Version used: 2.5.3
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome Version 62.0
Operating System and version (desktop or mobile): Arch Linux (desktop)
Link to your project: https://github.com/ionic-team/ionic-unit-testing-example",dasois,NONE,2017-12-06 18:38:47+00:00,True,2017-12-11 07:26:05+00:00,4.53,,3,4,2017-12-08 06:05:54+00:00,1.48,sgravrock,MEMBER,2,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1462,What about adding a toBeOfLength() method?,"There are cases where IMHO it would be handier to have a check (i.e. toBeOfLength(2) for the fore-mentioned case) regarding the length of a variable, instead of pure equality.",thodorisbais,CONTRIBUTOR,2017-12-11 01:38:43+00:00,True,2017-12-12 01:11:03+00:00,0.98,,2,1,2017-12-12 01:11:03+00:00,0.98,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1463,While using 'fit' all other 'it' tests are skipped. How to make 'it' run?,"Hi,
I am not sure if this is an expected way but while using fit all other it tests are skipped. How to make 'it' run?
I searched on google and didn't find any answers and also looked in the documentation with no luck. Have posted a question on stack overflow.
Thanks.",pbalan,NONE,2017-12-14 06:05:05+00:00,True,2017-12-15 01:11:02+00:00,0.8,,2,2,2017-12-15 01:11:02+00:00,0.8,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1464,testFunction in it() should be required,"I am wondering, why the parameter testFunction in it() is optional, but in the function fit() it is not.
Background:
I had the following code and was struggling to find the error:
describe('foo', () => { it('bar'),async(inject([BarService], (classUnderTest: BarService)=>{ //some test code })); });
This is two expressions ( it('bar') AND async(...) ) separated by a comma. As it('bar') is valid code, the compiler is perfectly fine with it.
At some point i changed to fit (to just run this one test) and immediately got an error message, that the testFunction is missing, which helped me to find my mistake.
Is there an use case to call it() with just a name. I can not image one.
Therefore I would recommend to keep the signature of both methods the same.",sefo2810,NONE,2017-12-15 08:48:36+00:00,True,2017-12-17 00:35:04+00:00,1.66,,3,2,2017-12-15 08:59:02+00:00,0.01,tymfear,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1465,"Show a warning when a beforeEach, afterEach, beforeAll and afterAll block contains tests","This is a feature suggestion.
Expected Behavior


Nesting describes, or its, or any expectations inside of a beforeEach, afterEach, beforeAll or afterAll should throw a warning or an error that's easy to notice.
Current Behavior


Currently, nesting tests inside of the aforementioned hooks will go unnoticed and will not throw a warning or an error.
Possible Solution


I haven't looked at Jasmine's code too much, but I'd love to jump in and solve this myself if it gets approval.
Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
  beforeEach(() => {
    it('renders', () => { // Jasmine won't complain about this test being here
      expect(true).toBe(false)
    })
  })
});
Context


Using jasmine I've come across the situation where I edit my tests and accidentally move blocks or closing curly brackets and end up with a describe, an it or expectations inside of a beforeEach or any of its counterparts.
This goes unnoticed except for the fact that the tests in particular don't run anymore. In my company's projects we've discovered in many occasions that a couple of our tests hadn't been running for several months.
Your Environment


Version used: Jasmine 2.8.0
Environment name and version: Chrome 59.0.3071, Karma 1.7.1",brainlessdeveloper,NONE,2017-12-15 14:06:47+00:00,True,2017-12-15 22:00:27+00:00,0.33,,2,2,2017-12-15 16:20:51+00:00,0.09,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1466,Is it possible to define specs during configuration time?,"I'm wondering if there's some hidden gem so I can do something like this:
jasmine.addSpec(x => {
     x.describe(""foo"", () => {
             x.it(""bar"", () => {
                   // Stuff here
             })
     })
})",mfidemraizer,NONE,2017-12-15 15:34:58+00:00,True,2017-12-16 01:14:47+00:00,0.4,,2,3,2017-12-15 16:56:20+00:00,0.06,mfidemraizer,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1467,Failing test with no expectations,"Expected Behavior
Would you agree on failing a test that doesn't have any expectations?
Possible Solution
Maybe adding:
result.status = 'failed'
after this line:
https://github.com/jasmine/jasmine/blob/master/lib/jasmine-core/jasmine-html.js#L107
Thanks!!",francittadini,NONE,2017-12-16 23:39:39+00:00,True,2017-12-17 00:29:13+00:00,0.03,,6,11,2017-12-17 00:29:13+00:00,0.03,sgravrock,MEMBER,2,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1468,Affix function - Pattern attribute with square brackets?,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Expected Behavior
Expected some sort of escape behaviour - but it is not building the pattern correctly when rendering the test page.
Current Behavior


Example, using the affix method I have this;
[id=""testInput""][type=""text""][required=""true""][pattern=""[a-zA-Z0-9-]{1,20}""]
but the above does not work, its having a problem with the square brackets within the pattern.
Possible Solution


Is there any escape mechanism - note I have already tried , with no joy.
Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {

it('should be invalid', function (){
var testInput = 'input[id=""testInput""][type=""text""][required=""true""][pattern=""[a-zA-Z0-9-]{1,20}""][value=""#123123""]';

affix(testInput);

//does not need an assert, as the pattern does not render correctly.
})
});
Context


Testing element against some real JS, but need to affix elements as part of the DOM - had this working by manually creating the element but wanted to clean it up by using affix.
Your Environment


Version used:
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:

localhost.",sreaney1989,NONE,2017-12-19 10:31:04+00:00,True,2018-01-12 00:17:35+00:00,23.57,,3,3,2017-12-19 14:33:22+00:00,0.17,sreaney1989,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1469,Fake setTimeout/setInterval is missing Node methods,"I'm running into a problem trying to write tests for a Node project that uses the brakes module since it uses Node's Timeout.unref() method and Jasmine's fake setInterval returns a number.
Expected Behavior
Running test shouldn't cause uncaught exceptions
Current Behavior
Tests cause this uncaught exception TypeError: this._spinningInterval.unref is not a function
Possible Solution
Return a fake Timeout object if we're using Node. I don't mind doing this myself if people are cool with it.
Context
I'm trying to switch our circuit breaker implementation, the new module we want to use seems incompatible with Jasmine
Environment

Version used: 2.8.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Node
Operating System and version (desktop or mobile): OS X
Link to your project: https://github.com/Tinder/sharded-redis-client",chris--young,CONTRIBUTOR,2017-12-19 23:07:59+00:00,True,2017-12-21 21:23:48+00:00,1.93,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1471,Feature Request: differentiate tests that have run 0 expect,"It would be cool to see the tests that are in success because they have run 0 expect from the ones that are in success because they actually run some expects. It would be even cooler to have a count of the expect run.
Exemple:
it('should warn', () => {
    // 0 expect here
});

it('should success', () => {
    expect(true).toBe(true);
});

// Success: 1 expect run
it('should success again', () => {
    if (true) {
        expect(true).toBe(true);
    } else {
        expect(null).toBe(null);
    }
});",sound-matt,NONE,2017-12-22 13:54:27+00:00,True,2018-02-13 23:48:37+00:00,53.41,,3,3,2017-12-23 17:12:33+00:00,1.14,sgravrock,MEMBER,2,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1472,Maps comparison always passes in IE11,"This is the same bug as #1257 but happens only in IE11
Possible Solution
Also take care of the unsupported Map/Set methods and contructor in IE11 see Kangax table

keys
values
entries

Suite that reproduces the behavior (for bugs)
it('Test', function() {
  const map1 = new Map();
  map1.set(1, 2);
  const map2 = new Map();
  map2.set(1, 3);
  map2.set(2, 3);
  expect(map1).toEqual(map2);
});
Your Environment

Version used: ~2.8.0
Environment name and version: IE11
Operating System and version: Windows 10",Volox,NONE,2018-01-03 11:57:29+00:00,True,2018-01-12 01:51:59+00:00,8.58,,2,3,2018-01-05 01:47:54+00:00,1.58,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1474,Spy objects with properties ,"I'm currently working on a tech test, and would like to be able to create a spy object that has properties, as a JS constructor function might have, in order to be able to properly isolate tests. I feel this functionality would be a useful addition to the spyOnProperty functionality that was released relatively recently.
Expected Behavior
When writing a test, it should be possible to create a spy object with properties that can be accessed using constructorFunction.property, as you might call constructorFunction.method() on a Jasmine spy object that had been created as follows (from the Jasmine documentation:
beforeEach(function() {
    tape = jasmine.createSpyObj('tape', ['play', 'pause', 'stop', 'rewind']);

    tape.play();
    tape.pause();
    tape.rewind(0);
  });

Current Behavior
As things stand currently, I have been unable to find another way to create a Jasmine spy object that holds properties as well as methods. This means it is not possible to isolate tests for functions that alter the properties of a different constructor (see below for example).
Possible Solution
One possible implementation that suggests itself to me is to add a second, optional array of properties as key/value pairs when creating a Jasmine spy object. In practice, this would look something like this:
beforeEach(function() {
    tape = jasmine.createSpyObj('tape', ['play', 'pause', 'stop', 'rewind'], ['title': 'Guardians of the Galaxy Awesome Mix: Vol. 1', 'artist': 'Various artists', 'tracks': 12, 'playingTime': 42]);

    tape.play();
    tape.pause();
    tape.rewind(0);

    console.log(tape.title); // Guardians of the Galaxy Awesome Mix: Vol. 1 
  });

Suite that reproduces the behavior (for bugs)
This is code to write a simple command-line banking application.
// account.js
'use strict';

var Deposit = require('./deposit.js').Deposit;
var Withdrawal = require('./withdrawal.js').Withdrawal;
const DEFAULT_BALANCE = 0;

var Account = function() {
  this._balance = DEFAULT_BALANCE;
  this._transactions = [];
};

Object.defineProperty(Account.prototype, 'balance', {
  get: function() { return this._balance },
  set: function(newBalance) { this._balance = newBalance },
  configurable: true
});

Account.prototype.deposit = function(depositAmount) {
  var deposit = new Deposit(this, depositAmount);
  deposit.deposit();
};

// More code

// deposit.js
'use strict';

var Deposit = function(account, depositAmount) {
  this.date = new Date();
  this.account = account;
  this.depositAmount = depositAmount;
};

Deposit.prototype.deposit = function() {
  var currentBalance = this.account.balance;
  var newBalance = currentBalance + this.depositAmount;
  this.account.balance = newBalance;
};

exports.Deposit = Deposit;

// DepositSpec.js
'use strict';

describe('Deposit', function() {
  var Account = require('../lib/account.js').Account;
  var Deposit = require('../lib/deposit.js').Deposit;
  var account;
  var deposit;

  beforeEach(function() {
    account = new Account();
    deposit = new Deposit(account, 50);
  })

  describe('Date', function() {
    it('Should be a date object', function() {
      expect(deposit.date).toEqual(jasmine.any(Date));
    });
  });

  describe('#deposit', function() {
    it('Should reduce an account\'s balance', function() {
      spyOnProperty(account, 'balance', 'get').and.returnValue(0);
      var balanceSetterSpy = spyOnProperty(account, 'balance', 'set').and.returnValue(50);
      account.deposit(50);
      expect(balanceSetterSpy).toHaveBeenCalled();
    });
  });
});

Context
In the final test above, it is necessary to create a real account object in order to properly test the functionality of the deposit class, as it modifies the balance property of the account. However, in creating this real object, the test is no longer isolated.
Your Environment

Version used: 2.8.0
Ubuntu 16.04 run on a Chromebook Pixel via crouton
Node version: 4.2.6
Link to your project: https://github.com/peterwdj/bankTechTest",peterwdj,NONE,2018-01-04 09:36:21+00:00,True,2018-01-10 01:43:36+00:00,5.67,,2,2,2018-01-06 01:14:34+00:00,1.65,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1475,pretty printer doesn't handle symbols as args in toHaveBeenCalledWith,"I'm running some tests where a spy on a method is asserting that the method should be called with a symbol and a callback as parameters like:
const mySymbol = Symbol('test');
expect(mySpy).toHaveBeenCalledWith(mySymbol, jasmine.any(Function))
When the test fails, result.message() throws an uncaught TypeError: Cannot convert a Symbol to a string when the pretty printer tries to output expectedArgs
function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; }
Expected Behavior
The test log should output

Expected spy mySpy to have been called with [ Symbol(test), ...

Current Behavior
The test log shows

TypeError: Cannot convert a Symbol value to a string
TypeError: Cannot convert a Symbol value to a string
    at Array.toString (native)
    at StringPrettyPrinter.PrettyPrinter.format (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3681:42)
    at Object.pp (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3836:25)
    at Object.result.message (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:3288:124)
    at Expectation.toHaveBeenCalledWith (http://localhost:9876/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?da99c5b057693d025fad3d7685e1590600ca376d:2087:30)
    at Object.it (http://localhost:9876/_karma_webpack_/main.bundle.js:1514:22)
    at ZoneDelegate.webpackJsonp.../../../../zone.js/dist/zone.js.ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/polyfills.bundle.js:10585:26)
    at ProxyZoneSpec.webpackJsonp.../../../../zone.js/dist/proxy.js.ProxyZoneSpec.onInvoke (http://localhost:9876/_karma_webpack_/vendor.bundle.js:46246:39)
    at ZoneDelegate.webpackJsonp.../../../../zone.js/dist/zone.js.ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/polyfills.bundle.js:10584:32)
    at Zone.webpackJsonp.../../../../zone.js/dist/zone.js.Zone.run (http://localhost:9876/_karma_webpack_/polyfills.bundle.js:10335:43)


Possible Solution
JSON.stringify() the expectedArgs array, rather than relying on Array.toString to output the array.
Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
    it('fails to show symbols', () => {
        const mySymbol = Symbol('test');
        let mySpy = jasmine.createSpy('mySpy');
        expect(mySpy).toHaveBeenCalledWith(mySymbol, jasmine.any(Function));
    })
});
Context
I'm writing an events subsystem where events are uniquely identified by symbols. This events system has an EventService.subscribe() method, that expects a discriminating symbol and a callback.
In writing unit tests for other parts of the app that should be subscribing to events, I check that a particular symbol was the symbol passed into the subscribe method.
It's worth pointing out that if I were calling
expect(mySpy).toHaveBeenCalledWith({
    type: mySymbol,
    callback: jasmine.any(Function)
})
it would work (and does, in a different method and tests relating to it). This is only a problem when the symbol is a separate parameter.
Your Environment
""devDependencies"": {
    ""@angular/cli"": ""1.1.1"",
    ""@angular/compiler-cli"": ""^4.0.0"",
    ""@angular/language-service"": ""^4.0.0"",
    ""@types/jasmine"": ""2.5.45"",
    ""@types/node"": ""~6.0.60"",
    ""codelyzer"": ""~3.0.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""^1.7.1"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage"": ""^1.1.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.2.1"",
    ""karma-jasmine"": ""~1.1.0"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""karma-mocha-reporter"": ""^2.2.3"",
    ""karma-phantomjs-launcher"": ""^1.0.4"",
    ""ng2-mock-component"": ""0.0.6"",
    ""protractor"": ""~5.1.2"",
    ""ts-node"": ""~3.0.4"",
    ""tslint"": ""~5.3.2"",
    ""typescript"": ""~2.3.3""
  }
$ cat /etc/linuxmint/info
RELEASE=18.1
CODENAME=serena
EDITION=""Cinnamon 64-bit""
DESCRIPTION=""Linux Mint 18.1 Serena""
DESKTOP=Gnome
TOOLKIT=GTK
NEW_FEATURES_URL=http://www.linuxmint.com/rel_serena_cinnamon_whatsnew.php
RELEASE_NOTES_URL=http://www.linuxmint.com/rel_serena_cinnamon.php
USER_GUIDE_URL=help:linuxmint
GRUB_TITLE=Linux Mint 18.1 Cinnamon 64-bit",jamesona,NONE,2018-01-08 17:48:45+00:00,True,2018-01-09 16:08:12+00:00,0.93,,2,2,2018-01-09 01:23:11+00:00,0.32,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1476,A vulnerability in jasmine-core ,"NSP reported a vulnerability in the jasmine-core 2.8.0 , So this version should be upgraded to suppress this vulnerabiltiy !",ammy1999,NONE,2018-01-11 08:46:37+00:00,True,2018-02-17 21:30:52+00:00,37.53,,2,2,2018-01-11 16:14:12+00:00,0.31,sgravrock,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1479,Arguments for a call to a spy are not available when spy is called using .apply(),"Are you creating an issue in the correct repository?
I think so! I don't think this has anything to do with Karma, as the issue is with jasmine's spies. Forgive me if this should be posted somewhere else. I've tried to search through existing issues and on StackOverflow, but I can't find anything specific to my use case.
Expected Behavior
Given a function that is a spy
When said function is called using .apply
Then I should be able to see the arguments that were passed using argsFor
Current Behavior
The return value of argsFor() is an empty array when inspecting a spy after it's been called using .apply, instead of the arguments that were passed
Suite that reproduces the behavior (for bugs)
describe('spying and applying', function() {
  it('should store arguments when you use apply', () => {
    const spy = jasmine.createSpy('mySpy');
    spy.apply(['foo', 'bar', 'baz']);
    expect(spy.calls.count()).toEqual(1); // Passes
    expect(spy.calls.argsFor(0)).toEqual('foo', 'bar', 'baz'); // Fails
  });
});
Context
Basically I have a function that accepts both a string or an array, and if it is an array it applies said array to another function (which is spied in my tests). The code looks like this:
function trackBeforePushingTo(payload, pushTo, ...pushArgs) {
  if(Array.isArray(payload)) {
    track.apply(payload);
  } else {
    track(payload);
  }
  pushTo(...pushArgs);
}
When I test passing an array into this function, the value of count() is correct, but the value of argsFor() is an empty array.
Your Environment


Version used: 2.5.2
Environment name and version (e.g. Chrome 39, node.js 5.4): Node 6.9.1, PhantomJS (via Karma)
Operating System and version (desktop or mobile): MacOS Sierra

Thanks!",glosee,NONE,2018-01-16 22:45:47+00:00,True,2018-01-17 00:36:12+00:00,0.08,,2,3,2018-01-17 00:26:06+00:00,0.07,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1480,Nested focused describe(fdescribe) breaks sequence of beforeEach and beforeAll calls,"Issue is based on @Gerg's #873 (comment)
If I'm focusing nested describe like so:
describe(""foo"", function() {
    beforeEach(function() {
        console.log('each 0');
    });

    beforeAll(function() {
        console.log('all 0');
    });

    it('spec', function() {
        console.log('spec 0.0');
        expect(true).toBe(true);
    });

    it('another spec', function() {
        console.log('spec 0.1');
        expect(true).toBe(true);
    });

   fdescribe('suite', function() {
        beforeEach(function() {
            console.log('each 1');
        });

        beforeAll(function() {
            console.log('all 1');
        });

        it('spec', function() {
            console.log('spec 1.0');
            expect(true).toBe(true);
        });

        it('another spec', function() {
            console.log('spec 1.1');
            expect(true).toBe(true);
        });
    });
});
I'm getting sequence:
all 0
all 1
each 0
each 1
spec 1.0
each 0
each 1
spec 1.1

while I would expect something like:
all 0
each 0
all 1
each 1
spec 1.0
each 0
each 1
spec 1.1

Jasmine version is - 2.8.0
Question: am I expecting wrong behaviour?
Note: Please, let me know If I have to provide more details.",Nodarii,NONE,2018-01-17 17:06:51+00:00,True,2018-01-18 11:14:23+00:00,0.76,,1,2,2018-01-17 23:32:04+00:00,0.27,Nodarii,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1481,List of specs are no longer shown after upgrading to 2.8 from 2.4,"Expected Behavior
In 2.4.1, if one gives an invalid spec name in the url, all the specs were listed in the browser with their appropriate links which would allow the user to click on any specific test spec to run that spec.
Current Behavior
In 2.8, if one gives an invalid spec name in the url, the specs are not listed in the browser. This is inconvenient as one has to specifically enter the whole spec name in the url  ?spec=""this spec name is longer than i expected"".
Your Environment

Version used: 2.8
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome: Version 63, Node: Version 7.9.0
Operating System and version (desktop or mobile): Mac OS Sierra 10.12.6",applecool,NONE,2018-01-17 22:53:09+00:00,False,,,,2,3,2018-01-17 22:56:04+00:00,0.0,applecool,NONE,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1482,[2.9.0 regression] clearing a non-existing timeout id affects upcoming setTimeout,"#1427 introduced a regression.
After using jasmine.clock().install() in a browser, if the upcoming timeout id is cleared before setTimeout is called, tick() won't execute the callback:
Expected Behavior
clearTimeout shouldn't stop upcoming timers from executing.
Current Behavior
timeout callback never runs
Possible Solution
https://github.com/jasmine/jasmine/blob/master/src/core/DelayedFunctionScheduler.js#L55
Move deletedKeys.push(timeoutKey); to the first line of the if (i > -1) {
Suite that reproduces the behavior (for bugs)
this would only break in web browsers. not in node. see context below...
jasmine.clock().install();
describe(""sample"", function() {
  it(() => {
    let val =1
    clearTimeout(0)
    setTimeout(() => val = 2, 2000) // asuming this is the first setTimeout since install() was called.
    jasmine.clock().tick(2000)
    expect(val).toBe(2)
  })
});
Context
Real project. Real browser tests that pass (and should pass) with jasmine 2.8.0, but don't with 2.9.0
This issue can only happen in web browsers, where timeout ID is a primitive number. Node.js uses objects, so it's not affected.
Your Environment

Version used: 2.9.0
Environment name and version: Chrome 63
Operating System and version (desktop or mobile): win 10 x64",AviVahl,NONE,2018-01-18 16:58:16+00:00,True,2018-01-20 01:48:18+00:00,1.37,,2,5,2018-01-19 01:24:32+00:00,0.35,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1483,beforeAll runs after IT statement in my jasmine test,"Issue
In my node.js integration testing project , i have a config file defined with certain parameters.
I need to read those values in my beforeAll but my describe, it statements are executed first then the beforeAll.
     ` var environment;

beforeAll( () => {
console.log(’Step1………..: ');
browser.getProcessedConfig().then((config) => {
    environment = config.environment ;
    console.log(‘Step2: ' + environment);
});

})
describe('*Executing TestSuite', function () {
console.log(‘Step3: ');
console.log(environment);

it('value1 should be not null’, (done) => {
// code to use environment
done();
}
});`
Expected Behavior
Step1
Step 2
Step 3
I want to use the value of environment before it block and inside it block . But at this moment i only see undefined value being refered by the code in it block.
Current Behavior
Step 3
undefined
Step 1
Step 2
Context
Integration Testing
Your Environment
Mac, Visual Studio Code
""jasmine-node"": ""^1.14.5"",
""jasmine-data-provider"": ""^2.2.0"",
""jasmine-expect"": ""^3.7.1"",
""jasmine-json-test-reporter"": ""^1.0.0-beta"",
""jasmine-reporters"": ""^2.2.0"",
""jasmine-screenshot-reporter"": ""0.0.6""
""protractor""",bitquality,NONE,2018-01-18 22:25:17+00:00,True,2018-01-19 18:29:40+00:00,0.84,,4,5,2018-01-19 01:30:49+00:00,0.13,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1484,Missing custom message with toEqual(..) Failure,"Expected Behavior
The custom messages appended to .toEqual(..) should be included in results / logs upon expectation failure. The below suite should emit both 'GOOD: ...' and 'BAD: ...' messages.
Current Behavior
The 'BAD: ...' custom messages associated with .toEqual(..) is not present. The message for that expectation only includes the results from diffBuilder.getMessage().  See this live here: https://codepen.io/AnmAtAnm/pen/PEVPBO
This stopped working around v2.6.0.
Possible Solution
I don't know whether this is the responsibility of wrapCompare(..) or .toEqual(..). wrapCompare(..) has a var message that is never sliced from the args array. Instead, it is assigned the matcher's results, which received the full args array.
Suite that reproduces the behavior (for bugs)
https://codepen.io/AnmAtAnm/pen/PEVPBO
describe(""Expect test's custom message"", function() {
  it(""toEqual example"", function() {
    expect(0).toEqual(1,
        'BAD: This message does not appear')
  });
  it(""toBeGreater example"", function() {
    expect(0).toBeGreaterThan(1,
        'GOOD: This message appears')
  });
});
Context
Unable to annotate my errors with meaningful logs.
Your Environment

Version used: 2.9.1
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 63
Operating System and version (desktop or mobile): Mac dekstop",AnmAtAnm,NONE,2018-01-20 07:19:31+00:00,True,2018-02-27 01:12:08+00:00,37.74,,4,5,2018-01-20 08:36:02+00:00,0.05,AnmAtAnm,NONE,2,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1485,Confusing error message with toEqual(array) when array is too long.,"Expected Behavior
When testing expect(array).toEqual(shorterArray);, replace
Expected $[n] = 'extra array element' to equal undefined.

with
Unexpected $[n] = 'extra array element'

To remove the confusing (even though technically accurate) reference undefined.
Current Behavior
It outputs
Expected $[n] = ... to equal undefined.

which implies some $[n] was expected, when most likely the actual array was just longer than the expected.
Possible Solution
Unexpected $[n] = 'extra array element'

Suite that reproduces the behavior (for bugs)
https://codepen.io/AnmAtAnm/pen/ppGgjX
describe(""Expect a shorter array error message"", function() {
  it(""example .toEqual(shorterArray)"", function() {
    expect(['example']).toEqual([]);
  });
});
Context
Trying to grok the meaning of my errors quickly.
Your Environment

Version used: v2.9.1
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 63
Operating System and version (desktop or mobile): Mac laptop",AnmAtAnm,NONE,2018-01-20 07:35:06+00:00,True,2018-03-10 15:42:47+00:00,49.34,,2,1,2018-02-16 01:49:27+00:00,26.76,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1486,Executing `beforeEach` outside `describe` block fails since 2.9.0,"Hi,
Context
Since version 2.9.0, any beforeEach / afterEach functions must be put inside a describe block. Even if it was not really documented, it has always been possible to define a beforeEach function outside any describe and it was executed before any tests in the entire test suite.
This was really useful to:

Execute some initialization code before any test, without declaring it in every describe block.
Declaring additional matcher that would become available in the entire test suite.
Etc.

For example, I used to mock clock using jasmine.clock().install() in a ""global"" beforeEach and uninstalling it in a global afterEach.
I think this change comes from: #1411.
Not sure if it was intended. If so: what do you suggest to have initialization code shared across all describe blocks?
Expected Behavior

Do not fail if a beforeEach function is defined outside any describe block.

Current Behavior

Having a beforeEach function outside any describe block fail with this error: Error: 'beforeEach' should only be used in 'describe' function.

My Environment

Version used: 2.9.0 / 2.9.1",mjeanroy,NONE,2018-01-20 13:53:28+00:00,True,2018-01-20 20:27:48+00:00,0.27,,5,7,2018-01-20 17:09:25+00:00,0.14,sgravrock,MEMBER,2,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1487,Why doesn't jasmine support using async function for describe method?,"When I am using an async function as the second argument of describe function, I got an error message about using AsyncFuntion. Is there some reasons I cannot use async function or it's just an issue with the type checking?",LvChengbin,NONE,2018-01-22 16:40:03+00:00,True,2018-03-01 18:53:20+00:00,38.09,,5,8,2018-01-24 01:17:20+00:00,1.36,slackersoft,MEMBER,1,0,0,4,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1488,Jump to method in docs,"The new doc format is great, but since it's no longer a single long page, I can't use my browsers ""find"" to jump to the line I want.
It would be great to add some version of search to the docs. Or maybe just add a second level to the outline on the left side of the page.",KyleW,NONE,2018-01-23 22:15:57+00:00,False,,,,2,1,2018-01-31 00:02:35+00:00,7.07,slackersoft,MEMBER,1,0,0,0,"['docs', 'ready for work']",False,False,False,False,False,False,False,True,False,True,False,False,False,False,False
1489,Marking a successful test as failed in case of exception,"I'm writing a test to check exception scenario
it('would not be started when the port is not accessible', function (done) {
        var server = require('.././lib/server');
        server.setup({ ""-d"" : path.join(__dirname, ""spec/test_assets""), ""-p"" : ""8""});
        server.on(""start"",function(){
            fail(""Not expected"");
            done();
        });
        server.on(""error"",function(err){
            expect(err.code).toBe('EACCES');
            done();
        });
        server.on(""request"",function(err){
            fail(""Not expected"");
            done();
        });
        server.start();
    });

I have confirmed that expect(err.code).toBe('EACCES'); is passed and done() is being called in above test.

Expected Behavior
So It should mark the test successful.
Current Behavior
But It is marking it failed and printing the error on console.
1) server would not be started when the port is not accessible
  Message:
    Error: EACCES: Permission denied for use of port 8
  Stack:
    Error: EACCES: Permission denied for use of port 8
        at networkErrHandler (/home/amit/git/stubmatic/lib/server.js:100:8)
        at Server.server.on.err (/home/amit/git/stubmatic/lib/server.js:73:3)
        at emitOne (events.js:115:13)
        at Server.emit (events.js:210:7)
        at emitErrorNT (net.js:1325:8)
        at _combinedTickCallback (internal/process/next_tick.js:102:11)
        at process._tickCallback (internal/process/next_tick.js:161:9)
        at Function.Module.runMain (module.js:607:11)
        at startup (bootstrap_node.js:158:16)
        at bootstrap_node.js:575:3


Hence I have changed the test in following way.
it('would not be started when the port is not accessible', function () {
        var server = require('.././lib/server');
        server.setup({ ""-d"" : path.join(__dirname, ""spec/test_assets""), ""-p"" : ""8""});
        expect(function(){
            server.start();
        }).toThrow(""EACCES: Permission denied for use of port 8"");
    });

But now it fails saying no exception is thrown.
Your Environment


Version used: 2.9.0
Environment name and version (e.g. Chrome 39, node.js 5.4): node.js 8.0
Operating System and version (desktop or mobile): ubuntu 17.10
Link to your project: https://github.com/NaturalIntelligence/Stubmatic",amitguptagwl,NONE,2018-01-30 05:26:49+00:00,True,2018-01-31 02:20:38+00:00,0.87,,2,2,2018-01-30 23:56:56+00:00,0.77,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1490,Unable to query input element in Shadow DOM of Polymer 2 component inside Angular page,"Hi,
I am working with some Polymer 2 components which implement ShadowDOM v1 spec and I need to select elements (e.g. input) inside their shadowRoots to run unit tests and few integration tests using Jasmine.
Expected Behavior
W should be able to access Shadow DOM elements using Jasmine selectors.
var allInputs =  fixture.debugElement.queryAll(By.css('input'));

Current Behavior
Unable to access inside of Shadow DOM from unit test. We should have query selectors to query shadow DOM elements.
Suite that reproduces the behavior (for bugs)
describe('AppComponent', () => {
  let component: AppComponent;
  let fixture: ComponentFixture<AppComponent>;
  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
      imports: [
        FormsModule
      ],
      schemas: [CUSTOM_ELEMENTS_SCHEMA]
    }).compileComponents();
    fixture = TestBed.createComponent(AppComponent);
    component = fixture.componentInstance;
  }));
  it('should have default value set for first name and last name', () => {
    fixture.detectChanges();
    var allInputs =  fixture.debugElement.queryAll(By.css('input'));
    var firstNameInput = allInputs[0].nativeElement;
    var lastNameInput = allInputs[1].nativeElement;
    expect(firstNameInput.value).toBe('');
    expect(lastNameInput.value).toBe('');
  });
});
What is the best way I can test the Polymer Web Components inside Angular page?
Or whether we have a mechanism to mock web components while unit testing Angular component?
My environment:
Angular CLI: 1.6.4
Node: 6.10.0
Angular: 5.2.0
""devDependencies"": {
""karma-jasmine"": ""^0.3.6"",
""jasmine"": ""^2.4.1"",
""jasmine-core"": ""^2.2.0""
}",msbasanth,NONE,2018-01-31 07:37:37+00:00,True,2018-02-01 03:19:58+00:00,0.82,,2,2,2018-01-31 17:48:10+00:00,0.42,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1491,Frequently I get this error when I run test using protractor,"This issue occurs frequently but randomly, sometimes the test passes.
[16:05:16] I/update - chromedriver: file exists \c\someproject\node_modules\protractor\node_modules\webdriver-manager\selenium\chromedriver_2.35.zip
[16:05:16] I/update - chromedriver: unzipping chromedriver_2.35.zip
[16:05:16] I/update - chromedriver: chromedriver_2.35.exe up to date
[16:05:16] I/launcher - Running 1 instances of WebDriver
[16:05:16] I/direct - Using ChromeDriver directly...

DevTools listening on ws://127.0.0.1:12270/devtools/browser/39dae962-b401-4bd0-a9e0-5d79c4886a3a
Jasmine started
Mock Server started
\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:5277
    return children && children[0].result.status;
                                  ^

TypeError: Cannot read property 'result' of undefined
    at isAfterAll (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:5277:35)
    at Suite.onException (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:5240:8)
    at Suite.onException (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:5252:27)
    at Suite.onException (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:5252:27)
    at QueueRunner.onException (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:5490:34)
    at onException (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:4461:14)
    at handleError (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:4394:11)
    at process.onerror (\c\someproject\node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js:2455:17)
    at emitOne (events.js:115:13)
    at process.emit (events.js:210:7)
    at process.emit (\c\someproject\node_modules\source-map-support\source-map-support.js:439:21)
    at process._fatalException (bootstrap_node.js:329:26)
npm ERR! code ELIFECYCLE
npm ERR! errno 7
npm ERR! someproject@0.0.0 e2e: `node ./.npm-scripts/serve.js && ng e2e --port 4200`
npm ERR! Exit status 7
npm ERR!
npm ERR! Failed at the someproject@0.0.0 e2e script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     \c\Users\FOOBAR\AppData\Roaming\npm-cache\_logs\2018-02-01T10_35_23_646Z-debug.log

Error is thrown due to a missing null check for the first element of children array
function isAfterAll(children) {
    return children && children[0].result.status;
 }

Path: node_modules\jasmine\node_modules\jasmine-core\lib\jasmine-core\jasmine.js
Line: 5277
Context
Your Environment

Version 64.0.3282.119 (Official Build) (64-bit)
Windows 10 Pro
npm@5.1.0
node@v8.1.4
jasmine-core@2.9.1",mehdhi,NONE,2018-02-02 06:15:12+00:00,True,2018-02-22 10:15:52+00:00,20.17,,2,2,2018-02-07 19:57:01+00:00,5.57,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1492,Following Error shown When I Execute the test cases parallely with concurrently package Error: timeout - async callback was not invoked within timeout specified by jasmine.default_timeout_interval.,"Hai,
I'm new to TDD. Currently we have 3000 more test cases in our project.  If we run the coverage, these 3000 cases were executed parallell with npm-concurrently  package. I have configured my test cases folder structure into 10 subFolders.  For Example, Consider, Two Main Folders A and B is here.  Folder A has 5 subFolders and Folder B had  5 Sub Folders. Each SubFolders has minimum 5 count of spec files. I had configured separate karma configuration file for each subFolders and configured the separate gulp tasks for each sub folders too. We are using Chrome Headless Browser to run the test cases. The Sample Karma Configuration file is given below for your reference,
    `module.exports = function (config) {
     config.set({
    browsers: ['Chrome', 'IE', 'Firefox', 'ChromeHeadless'],
    frameworks: ['jquery-1.10.2', 'jasmine-jquery', 'jasmine'],
     files: [   
            'js/src/**/**/*.css',
           'js/src/assets/scripts/jquery-1.10.2.min.js',
           'js/src/assets/scripts/jquery.easing.1.3.min.js',
           'js/src/**/**/*.js',
           {
             pattern: 'js/**/**/Index.html',
             watched: true,
             served: true,
             included: false
           }
          ],
         concurrency: Infinity,
         browserDisconnectTolerance: 3,
         browserNoActivityTimeout: 1000000,
         browserDisconnectTimeout: 1000000,
         captureTimeout: 1000000,
         retryLimit: 5,
       htmlDetailed: {
               splitResults: false,
              dir: 'reoports/nunit/one',
              fileName: 'TestResult.html',
              autoReload: false
        },
       coverageReporter: {
           type: ""html"",
               check: {
                 each: {
                statements: 0,
                branches: 0,
                functions: 0,
                lines: 0
             }
          }
         }
    });
  }; `

Sample Gulp Configuration file is give below,
     `gulp.task('one', function (done) {
        return new Server({
           configFile: __dirname + '/karma.conf.one.js',
           action: 'run',
           singleRun: true,
           preprocessors: {
        'js/src/**/**/*.js': ['coverage'] 
           },
          reporters: ['progress', 'htmlDetailed', 'coverage'],
          coverageReporter: {
          dir: './reports',
          subdir: ""reporters/new"",
          reporters: [
             { type: 'json', file: ""one.json"" }
          ]
       },
      customLaunchers: {
        MyHeadlessChrome_Desktop: {
            base: 'ChromeHeadless',
            flags: ['--disable-translate', '--disable-extensions', '--remote-debugging-port=9223', ""--
            headless"", ""--disable-gpu"", ""--window-size=1228,1000""],
          },
        },
       browsers: ['MyHeadlessChrome']
      }, done).start();
   });
   `

My Package.JSON File is given below for your reference:-
    `{
     ""name"": ""gulp-karma"",
     ""version"": ""1.0.0"",
      ""description"": """",
      ""scripts"": {
      ""test"": ""gulp test"",
      ""ci"": ""gulp ci"",
      ""coverage"": ""concurrently \""gulp one\"" \""gulp two\"" \""gulp three\"" \""gulp four\"" \""gulp five\"" 
       \""gulp six\"" \""gulp seven\"" \""gulp eight\"" \""gulp nine\"" \""gulp ten\"""",
      ""lint"": ""gulp runeslint""
     },
  ""devDependencies"": {
   ""concurrently"": ""^3.5.1"",
    ""eslint-html-reporter"": ""^0.5.2"",
    ""ghooks"": ""^2.0.0"",
    ""gulp"": ""^3.9.1"",
    ""gulp-csslint"": ""^1.0.0"",
    ""gulp-eslint"": ""^2.0.0"",
    ""gulp-jasmine"": ""^3.0.0"",
    ""gulp-lesshint"": ""^4.0.0"",
    ""gulp-shell"": ""^0.6.5"",
    ""istanbul-combine"": ""^0.3.0"",
    ""jasmine"": ""^2.9.0"",
    ""jasmine-core"": ""^2.9.1"",
    ""jasmine-jquery"": ""^2.1.1"",
   ""jquery-1x"": ""^1.12.1"",
   ""karma"": ""^2.0.0"",
   ""karma-chrome-launcher"": ""^2.2.0"",
   ""karma-coverage"": ""^1.1.1"",
   ""karma-firefox-launcher"": ""^1.0.1"",
  ""karma-html-detailed-reporter"": ""^1.1.21"",
   ""karma-ie-launcher"": ""^1.0.0"",
   ""karma-jasmine"": ""^1.1.1"",
   ""karma-jasmine-jquery-2"": ""^0.1.1"",
   ""karma-jquery"": ""^0.2.2"",
   ""karma-safari-launcher"": ""^1.0.0"",
   ""clean-dir"": ""^1.0.3""
   },
 `

My Sample Test Case is given below for your reference
   `describe(""Checking AsynC Call"", function () {
    var originalTimeout;
     beforeEach(function (done) {
     originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
     jasmine.DEFAULT_TIMEOUT_INTERVAL = 30000;
     });
    it(""Ensure element a is visible"", function 
    (done) {
                  var num = document.find("".number"");
		num.trigger('click');
		setTimeout(function(){
		expect(document.find(""a"").is("":visible"")).toBeTruthy();
		done();
		},1000);
       });
    it(""Ensure element b is visible"", function 
    (done) {
                  var num = document.find("".num"");
		num.trigger('click');
		setTimeout(function(){
		expect(document.find(""b"").is("":visible"")).toBeTruthy();
		done();
		},5000);
       });

       afterEach(function (done) {
        jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;
        done();
      });
    });`

If i set the jasmine.DEFAULT_TIMEOUT_INTERVAL value into Math.pow(2, 31) - 1 value also, This ""Error-Async callback was not invoked within the jasmine.DEFAULT_TIMEOUT_INTERVAL"" exception was shown?
Can anybody tell me the solution for above issue?
And Tell me, what is the maximum timeout interval, we can set in **jasmine.DEFAULT_TIMEOUT_INTERVAL"" in this settings?
Regards,
Thiru",thirusabari,NONE,2018-02-05 12:16:08+00:00,True,2018-08-16 00:41:44+00:00,191.52,,4,7,2018-02-07 17:49:30+00:00,2.23,slackersoft,MEMBER,1,0,0,3,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1493,"Jasmine Timeout error in  jasmineBoot,js file ","Uncaught TypeError: Cannot assign to read only property 'setTimeout' of object '[object Object]'
throws at  jasmine boot.js file
the line is 107:21
window.clearTimeout = window.clearTimeout;",Artirobo,NONE,2018-02-06 15:20:03+00:00,True,2018-02-08 18:16:02+00:00,2.12,,2,3,2018-02-07 17:44:51+00:00,1.1,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1494,global beforeEach throws error,"Expected Behavior
Should be called before each test
Current Behavior
throws the error 'beforeEach' should only be used in 'describe' function
Possible Solution
could test for currentSpec instead of currentRunnable() in ensureIsNotNested

  
    
      jasmine/src/core/Env.js
    
    
        Lines 472 to 477
      in
      3d8e379
    
    
    
    

        
          
           function ensureIsNotNested(method) { 
        

        
          
             var runnable = currentRunnable(); 
        

        
          
             if (runnable !== null && runnable !== undefined) { 
        

        
          
               throw new Error('\'' + method + '\' should only be used in \'describe\' function'); 
        

        
          
             } 
        

        
          
           } 
        
    
  


change to:
    function ensureIsNotNested(method) {
      if (currentSpec !== null && currentSpec !== undefined) {
        throw new Error('\'' + method + '\' should only be used in \'describe\' function');
      }
    }
Suite that reproduces the behavior (for bugs)

beforeEach(function() {});
describe(""sample"", function() {
  it(""test"", function() {});
});
Context
This limits the ability to add a beforeEach for all tests when tests are in multiple files.
Your Environment
Jasmine 3.0.0
Node 9.4.0",UziTech,CONTRIBUTOR,2018-02-07 06:44:59+00:00,True,2018-02-07 14:58:25+00:00,0.34,,1,1,2018-02-07 14:58:25+00:00,0.34,UziTech,CONTRIBUTOR,0,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1495,You need to include some adapter that implements __karma__.start method,"I'm coming here since I received a PR to update jasmine: julmot/mark.js#196
Since this update, only in IE9 it throws an error:
You need to include some adapter that implements __karma__.start method

https://travis-ci.org/julmot/mark.js/builds/338176986#L3394
What's causing the issue? Is it a bug of jasmine when used in combination with Karma or an issue with the environment of mark.js?

Your Environment


Version used: 3.0.0
Environment name and version (e.g. Chrome 39, node.js 5.4): IE9
Operating System and version (desktop or mobile): Windows 7
Link to your project: https://github.com/julmot/mark.js",julmot,NONE,2018-02-07 09:27:01+00:00,True,2018-02-07 17:34:25+00:00,0.34,,2,2,2018-02-07 17:22:31+00:00,0.33,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1496,Jasmine 3.0.0 breaks Angular 5.2 tests,"Expected Behavior
Tests work with Jasmine 2.9.1
Current Behavior
With Jasmine 3.0.0, all tests fail with this error:
TypeError: Cannot read property 'run' of null
  at <Jasmine>
  at UserContext.<anonymous> home/bobn/Projects/app/node_modules/zone.js/dist/jasmine-patch.js:106:1)
  at <Jasmine>
  at ZoneDelegate.webpackJsonp.../../../../zone.js/dist/zone.js.ZoneDelegate.invokeTask home/bobn/Projects/app/node_modules/zone.js/dist/zone.js:421:1)
  at Zone.webpackJsonp.../../../../zone.js/dist/zone.js.Zone.runTask home/bobn/Projects/app/node_modules/zone.js/dist/zone.js:188:1)
  at drainMicroTaskQueue home/bobn/Projects/app/node_modules/zone.js/dist/zone.js:595:1)
  at <Jasmine>

Same behavior using Angular 5.2.3 and 5.2.4.
It seems as though jasmine-patch.js is no longer compatible with Jasmine 3.0.0.
Your Environment
Ubuntu 16.04
Chrome 64.0.3282 (Linux)
ng -v

Angular CLI: 1.6.7
Node: 8.8.1
OS: linux x64
Angular: 5.2.4
... animations, common, compiler, compiler-cli, core, forms
... http, language-service, platform-browser
... platform-browser-dynamic, router
@angular/cli: 1.6.7
@angular-devkit/build-optimizer: 0.0.42
@angular-devkit/core: 0.0.29
@angular-devkit/schematics: 0.0.52
@ngtools/json-schema: 1.1.0
@ngtools/webpack: 1.9.7
@schematics/angular: 0.1.17
typescript: 2.7.1
webpack: 3.10.0",rnadler,NONE,2018-02-07 20:05:29+00:00,True,2018-02-08 17:52:52+00:00,0.91,,4,5,2018-02-07 20:19:13+00:00,0.01,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1497,v2.99 catchExceptions deprecation warning is unavoidable,"Are you creating an issue in the correct repository?
yes
Expected Behavior
If I am not expliclty using catchExceptions, I should not see the deprecation warning
Current Behavior
I see the deprecation warning even though I am not using catchExceptions explicitly
Possible Solution
The catchExceptions function is called uncondtionally from here, and if the query parameter is not provided, defaults the value to true.
It seems like the value should default to false, and that the warning in the catchExceptions function should only be displayed if the value is truthy. If the catchExceptions function needs to be enabled by default and that a change to that would be breaking, that's fine, but it seems like odd that the deprecation warning would show up if you didn't opt in to the feature. Because you have to explicitly opt out of something you never opted in to to get rid of the warning.
Context
I am just running jasmine in a browser and would like to get rid of the deprecation warning.
Your Environment


Version used: 2.99
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 64 node 8.9
Operating System and version (desktop or mobile): OS X High Sierra",bdwain,NONE,2018-02-07 21:12:34+00:00,True,2018-02-09 17:32:34+00:00,1.85,,2,2,2018-02-07 22:50:04+00:00,0.07,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1500,Unresolved merge conflict,"jasmine/lib/jasmine-core/jasmine.css
    
    
         Line 36
      in
      1acbd1e
    
    
    
    

        
          
           <<<<<<< HEAD",aptx4869,CONTRIBUTOR,2018-02-08 07:07:19+00:00,True,2018-02-08 18:23:10+00:00,0.47,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1502,Unable to bundle jasmine-core v2.99.1,"Are you creating an issue in the correct repository?
yes?
Expected Behavior
I should be able to run bundle install when Jasmine is in my gemfile.
Current Behavior
I'm seeing the following error that did not happen with v2.99.0:
Installing jasmine-core 2.99.1 (was 2.99.0)
Errno::EEXIST: File exists @ dir_s_mkdir - /Users/cameron/.rbenv/versions/2.5.0/lib/ruby/gems/2.5.0/gems/jasmine-core-2.99.1/lib/jasmine-core/spec
An error occurred while installing jasmine-core (2.99.1), and Bundler cannot continue.
Make sure that `gem install jasmine-core -v '2.99.1'` succeeds before bundling.

Possible Solution
Is jasmine-core or jasmine-gem trying to create a directory that already exists?
Suite that reproduces the behavior (for bugs)
This fails for me:
require 'bundler/inline'

gemfile(true) do
  source 'http://rubygems.org'
  gem 'jasmine', '~> 2.3.0'
end
Your Environment

Ruby 2.5.0
Bundler 1.16.1",camertron,NONE,2018-02-09 01:27:33+00:00,True,2018-02-09 17:36:47+00:00,0.67,,5,5,2018-02-09 11:23:33+00:00,0.41,mykhi,NONE,1,0,0,4,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1503,Error when trying to use the 'toHaveClass' matcher,"Are you creating an issue in the correct repository?
Yes

Expected Behavior
expect(el).toHaveClass('bar'); should return true or false.
Current Behavior
expect(el).toHaveClass('bar'); returns the following error:
TypeError: expect(...).toHaveClass is not a function
	    at <Jasmine>
	    at UserContext.<anonymous> (spec/directives/spec.alerts.js:30:20)
	    at <Jasmine>
Suite that reproduces the behavior (for bugs)
it('should check the element class', function () {
    var el = document.createElement('div');
    el.className = 'foo bar baz';
    expect(el).toHaveClass('bar');
});
Context


I'm trying to run some tests for a directive and wanted to use the new matcher that has become available in Jasmine 3.0.0.  The first attempt at using the matcher, caused the issue above.
I am using Karma (1.7.1) as a test runner.
Your Environment


Version used: 3.0.0
Environment name and version: Chrome 62.0.3202, node.js 8.5.0
Operating System and version (desktop or mobile): Desktop
App: AngularJS 1.5.11",emaduka-debanke,NONE,2018-02-09 12:00:04+00:00,True,2018-02-14 01:10:52+00:00,4.55,,2,2,2018-02-10 19:57:02+00:00,1.33,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1504,Error in the Version for NPM for jasmine-core,"I  believe there's been an error in the versioning for jamine-core. As I was checking for updates in an angular app, I noticed the version jumped from 2.9.1  →  2.99.1 and that looks like a mistake:

Is this an error?",seanwestfall,NONE,2018-02-09 23:44:04+00:00,True,2018-02-09 23:50:39+00:00,0.0,,2,1,2018-02-09 23:50:39+00:00,0.0,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1506,Node.js gives exit code 4 when jasmine encounters an exception in the test file,"Consider this javascript file
var Jasmine = require('jasmine');
var jasmine = new Jasmine();


try {
    jasmine.execute(""./simple_test.js"");
}
catch (e) {
    process.exit(1);
}
And this jasmine test file
throw new Error(""error"");

describe(""simple suite"", function () {

    it(""simple test"", function () {
        var result = """";
        expect(result).toBe(""1"");
    });
    
});
On running the command node main.js and checking the exit code using echo $? I constantly get exit code 4 instead of exit code 1.",karanjitsingh,NONE,2018-02-14 16:26:47+00:00,True,2018-02-15 10:02:12+00:00,0.73,,1,1,2018-02-15 10:02:12+00:00,0.73,karanjitsingh,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1507,"Spies : Calling through doesn't work, but calling fake the same function does. ","I first should mention I use Jasmine ~2.8.0 with Angular 5.1.1 (CLI @ 1.6.1).

Expected Behavior
When I create a spy with this
  component['createMarker'] = jasmine.createSpy().and.callThrough();

I expect the function to have been called, and I expect the function to run as if there was no spy.
Current Behavior
The callThrough won't work, but using this
  component['createMarker'] = jasmine.createSpy().and.callFake(component['createMarker']);

Works. I really can't understand the issue there, therefore I am creating an issue into your repo.
Suite that reproduces the behavior
I'm not sure I can reproduce the behavior, so instead of making a sandbox, I will post my whole code, hoping for an explanation (at least).
The code is at the end of the issue, so that it doesn't bother your reading !
I should also state the error I guess. When I create a marker with the createMarker function, using callThrough returns undefined (and as I stated, fakely calling the same function works well), thus making it impossible to call getLatLng on undefined. Here is the error (look for marker.getLatLng() in the setSelected function)  :
× should remove the marker of the select source post
  Chrome 63.0.3239 (Windows 10 0.0.0)
  TypeError: Cannot read property 'getLatLng' of undefined
    at MapComponent.setSelected C:/Users/MT4E45CN/Documents/Projects/ms-front/src/app/components/logged/map/map.component.ts:122:62)

As I said, I have found a workaround, so it's just for information at this point. Although, I would like to use callThrough, it's easier ...
I stay available if you have questions or need additional information !
Your Environment
I'm on Windows 10, using Chrome 63.0.3239, with Jasmine ~2.8.0.
Code snippets
map.component.ts
  setSelected(sp: CustomObject) {
    this.removeMarker(sp);

    if (this.currentPost) {
      this.removeMarker(this.currentPost);

      if (this.session.isCustomObjectInCustomValue(this.currentPost)) {
        this.createMarker(this.currentPost, this.createCoordinates(this.currentPost));
      }
    }
    if (sp.latitude && sp.longitude) {
      const marker = this.createMarker(sp, this.createCoordinates(sp), this.selectedIcon);
      if (
        !this.isMapSelection &&
        !this.leafletMap.getBounds().contains(marker.getLatLng())
      ) { this.zoomOnMarker(marker, 14); }
    } else {
      this.snacker.open('Coordonnées non renseignées', 'OK', { duration: 2500 });
    }
  }
map.component.spec.ts
describe('MapComponent', () => {
  let component: MapComponent;
  let fixture: ComponentFixture<MapComponent>;

  const spMock: any = { id: 1, latitude: 10, longitude: 10 };

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [MapComponent],
      providers: [sessionServiceMock, sourcePostServiceMock],
      imports: [SharedModule, BrowserAnimationsModule]
    })
      .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(MapComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  describe('setSelected', () => {

    let mapContainsSpy: jasmine.Spy;

    beforeEach(() => {
      component.currentPost = spMock;
      component['removeMarker'] = createFakeCallSpy();
      component['createMarker'] = jasmine.createSpy().and.callThrough();
      component['zoomOnMarker'] = createFakeCallSpy();

      mapContainsSpy = spyOn(component.leafletMap.getBounds(), 'contains');
    });

    it('should remove the marker of the select source post', () => {
      component.setSelected(spMock);
      expect(component['removeMarker']).toHaveBeenCalledWith(spMock);
    });
  });
});",,NONE,2018-02-15 16:13:37+00:00,True,2018-02-27 17:21:30+00:00,12.05,,2,9,2018-02-15 17:43:34+00:00,0.06,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1508,Object equality fails when object contains a function,".toEqual and jasmine.objectContaining fail to recognize equal objects with functions
Expected Behavior
I would expect this text assertion to pass:
it('passes objects that contain functions', () => {
expect({1: 'hello', 2: function() {}}).toEqual({1: 'hello', 2: function() {}});
expect({1: 'hello', 2: function() {}}).toEqual(jasmine.objectContaining({1: 'hello', 2: function() {}}));
});

Current Behavior
Expected Object({ 1: 'hello', 2: Function }) to equal <jasmine.objectContaining(Object({ 1: 'hello', 2: Function }))>.
	    at Object.eval (http://localhost:9876/statictests/

Context
I'm attempting to test a function call that passes callbacks within an object. Here was my initial test idea but it fails.
const params = {
  resolve: {
    someData: () => someData
  }
};
myFunc(params);
expect(myFunc).toHaveBeenCalledWith(params);

Your Environment

Version used: 2.3.4
Environment name and version: Headless Chrome 64.0.3282.167
Operating System and version: macOS High Sierra 10.13.3",antgonzales,NONE,2018-02-15 22:31:06+00:00,True,2018-02-15 23:17:24+00:00,0.03,,4,4,2018-02-15 22:55:07+00:00,0.02,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1509,Provide an example of async reporter hooks,"It is said here that async custom reporter hooks are implemented in Jasmine3. But I failed to implement it. Provide some examples to documentation on this, please.",tymfear,NONE,2018-02-17 21:45:12+00:00,True,2018-02-26 20:20:39+00:00,8.94,,2,1,2018-02-26 20:20:39+00:00,8.94,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1510,[Feature] Snapshot testing like jest,"Hi, there are plans to add support for snapshot testing like jest? There are plugins, but many work incorrectly or outdated",listepo-alterpost,NONE,2018-02-19 10:35:53+00:00,True,2018-02-26 19:55:13+00:00,7.39,,2,1,2018-02-26 19:55:13+00:00,7.39,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1511,Transforming deliver.sm to submit.sm,"Good morning,
I’ve been checking the configuration of JasminSMPP to build it. In one of the URL’s – this one: jookies/jasmin#142 - I’ve found that was not posible to comunicate two SMPPclients by transforming deliver.sm to submit.sm because the standard didn’t allow that.
Then, from Jasmin platform, was wrote a basic scripted example to do this making a PDU and sending it to RabbitMQ, but the webpage  - https://gist.github.com/zoufou/efc604070f34ef699c8b - seems that is not working anymore.
In the latest version of Jasmin, is still not posible to do this? Do I have to prepare some script to make it happen?
Anyway, what I'm trying to do is to connect a SMPP client to a SMPP server to send the SMS to the SMScenter. So, at first, I should be able to receive the petition of the SMPP client via PDU - submit.sm (deliver at my SMPP server) and, by creating a connector, re-send it to SMScenter.
Thanks in advance,
kind regards.",JFnine,NONE,2018-02-19 12:03:37+00:00,True,2018-02-19 17:37:21+00:00,0.23,,2,2,2018-02-19 16:46:32+00:00,0.2,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1517,Provide a way to run all specs marked as pending,"It would be helpful to have a way to force all specs marked as pending to be run, to easily check if they are now passing without having to go to the corresponding code and take off the pending marker.
At a minimum I believe a Pending 'tab' on the html reporter which listed all pending specs in one place would be useful:
Spec List | Failures | Pending
Providing an option on this tab to run the listed specs, and another in Jasmine to run a spec even when it is marked as pending.
Context
Although we try and use the pending argument to say which task numbers in our backlog a spec is blocked by for example pending('Should be fixed by 123'), it is still a manual process to comment out the pending and re-run the spec to check it has been fixed. This means it invariably gets forgotten on occasion.
Other times the cause isn't known at the time, or there's no issue in the backlog yet, so the spec gets set to pending without and argument and forgotten about.
Both of these mean we have an ever increasing number of pending specs for our project which I would like an easier way to tackle.",chris-orchard,NONE,2018-02-23 15:16:55+00:00,False,,,,4,10,2018-03-14 14:33:39+00:00,18.97,henrahmagix,CONTRIBUTOR,1,2,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1518,"How can I run ""done"" multiple times?","I want to run a test if an async function was executed multiple times, how can I implement the test case?
For example: while emitting the ""x"" event, I hope the handler function would be executed twice, and then to execute the done function.
it( 'should be executed twice', done => {
    const handler = () => done();
    em.on( 'x', handler );
   em.emit( 'x' );
} );",LvChengbin,NONE,2018-02-24 00:49:15+00:00,True,2018-02-26 19:31:51+00:00,2.78,,2,1,2018-02-26 19:31:51+00:00,2.78,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1519,Jasmine does not handles exception in static instances,"Hi!
I don't know if the title is correct... but here's my case.
I'm using Typescript by the way...
I have a class with static members of it's own class... Here's the code:
export class StaticClass {
	public static readonly instance: StaticClass = new StaticClass();

	constructor() {
		throw new Error('Static class error');
	}
}

Here's my test
import { StaticClass } from './static-class';

describe('test static instance class', () => {
	it('should works', () => {
		expect(StaticClass.instance).toBeDefined();
	});
});


Here's my jasmine.json
{
	""spec_dir"": ""dist"",
	""spec_files"": [
		""**/*[sS]pec.js""
	],
	""stopSpecOnExpectationFailure"": false
}

It's obvious that the test should fail, the constructor throws an exception. But when I run this test, Jasmine outputs nothing.
MBA:test-jasmine vincent$ ./node_modules/.bin/jasmine --config=jasmine.json
MBA:test-jasmine vincent$ 

AS soon as I remove the Error, it works.
MBA:test-jasmine vincent$ ./node_modules/.bin/jasmine --config=jasmine.json
Randomized with seed 90625
Started
.


1 spec, 0 failures
Finished in 0.013 seconds
Randomized with seed 90625 (jasmine --random=true --seed=90625)

Should'nt Jasmine outputs something in this case, instead of... nothing? It's maybe a lower-level problem, but it took me quite a while to analyse what was doing on.
Thanks
VB",vIceBerg,NONE,2018-02-25 16:34:56+00:00,True,2018-02-27 00:49:01+00:00,1.34,,2,1,2018-02-27 00:32:57+00:00,1.33,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1520,jasmine-core NPM package has 2.99.1 instead of 3.0.0 under latest tag,"Run npm info jasmine-core dist-tags to investigate package metadata. It will say that latest is 2.99.1, but there is version 3.0.0 published! Also jasmine package returns 3.0.0 as latest: npm info jasmine dist-tags.
Because of this NPM will install jasmine-core@2.99.1 when version is omitted and npm outdated won't report that new version is available.
Expected Behavior


$ npm info jasmine-core dist-tags
{ latest: '3.0.0' }

Current Behavior


$ npm info jasmine-core dist-tags
{ latest: '2.99.1' }

Possible Solution


Maintainers change latest tag to point to 3.0.0 😄",devoto13,NONE,2018-02-26 14:59:38+00:00,True,2018-02-26 18:23:27+00:00,0.14,,2,1,2018-02-26 18:23:27+00:00,0.14,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1522,Async custom reporter hook not working,"I'm using the following packages with TypeScript 2.7.2:
""jasmine-core"": ""^3.1.0"",
""jasmine-reporters"": ""^2.3.0"",
""jasmine-spec-reporter"": ""^4.2.0"",
This is a chunk of code for testing:
import CustomReporter = jasmine.CustomReporter;

export const TestReporter: CustomReporter = {
    async specDone(result) {
        console.log('Spec Done started');
        await setTimeout(() => console.log('Time out....'), 5000);
        console.log('Spec Done finished');
    }
};

jasmine.getEnv().addReporter(TestReporter);

describe('Test reporter.', () => {
    it(`Successful Test`, async () => {
        expect(true).toBeTruthy();
    });
});
This won't asynchronously wait for timeout and won't print 'Time out....'.
Also in the issue #1509 (Closed) you advised to return a Promise, but all functions in TS typing for custom reporter are void:
interface CustomReporter {
        jasmineStarted?(suiteInfo: SuiteInfo): void;
        suiteStarted?(result: CustomReporterResult): void;
        specStarted?(result: CustomReporterResult): void;
        specDone?(result: CustomReporterResult): void;
        suiteDone?(result: CustomReporterResult): void;
        jasmineDone?(runDetails: RunDetails): void;
    }
Please advise.",brainroma,NONE,2018-03-06 11:38:18+00:00,False,,,,5,8,2018-03-07 01:09:04+00:00,0.56,slackersoft,MEMBER,1,0,0,3,['Protractor'],False,False,False,True,False,False,False,False,False,False,False,False,False,False,False
1523,Tests breaks after upgrading jasmine-core from 2.99.0 to 3.1.0,"Expected Behavior


I'm running Angular 5 test cases with karma/jasmine. The test should succeed but fails.
Can't really tell which package is responsible for the actual bug. But he bug occurred after upgrading jasmine-core from 2.99.0 -> 3.1.0. If you think this bug is related to Karma or any other package, please tell so and feel free to close it.
Current Behavior


I have an Angular 5 project running karma/jasmine. Unfortunately the tests stopped working after upgrading from 2.99.0 to 3.1.0 with this ambiguous error.
Chrome 64.0.3282 (Windows 10.0.0) ERROR
  {
    ""message"": ""An error was thrown in afterAll\n[object ErrorEvent]"",
    ""str"": ""An error was thrown in afterAll\n[object ErrorEvent]""
  }
Chrome 64.0.3282 (Windows 10.0.0): Executed 1 of 1 ERROR (0 secs / 0 secs)
Chrome 64.0.3282 (Windows 10.0.0) ERROR
  {
    ""message"": ""An error was thrown in afterAll\n[object ErrorEvent]"",
    ""str"": ""An error was thrown in afterAll\n[object ErrorEvent]""
Chrome 64.0.3282 (Windows 10.0.0): Executed 1 of 1 ERROR (0.187 secs / 0 secs)

Possible Solution


None. I'm happy to help debugging the issue. But my knowledge of karma/jasmine is to limited to do without assistance.
Suite that reproduces the behavior (for bugs)

import { async, TestBed } from '@angular/core/testing';
import { StartComponent } from './start.component';
describe('StartComponent', () => {
    beforeEach(async(() => {
        TestBed.configureTestingModule({
            declarations: [
                StartComponent
            ],
        }).compileComponents();
    }));
    it('should create the app', async(() => {
        const fixture = TestBed.createComponent(StartComponent);
        const app = fixture.debugElement.componentInstance;
        expect(app).toBeTruthy();
    }));
});
Your Environment


Version used: 3.1.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 64, Node 8.9.4,
Operating System and version (desktop or mobile): Dekstop

{
""devDependencies"": {
    ""@angular/cli"": ""6.0.0-beta.4"",
    ""@angular/compiler-cli"": ""6.0.0-beta.6"",
    ""@types/jasmine"": ""2.8.6"",
    ""@types/jasminewd2"": ""2.0.3"",
    ""@types/node"": ""8.0.19"",
    ""@types/webpack"": ""3.8.8"",
    ""awesome-typescript-loader"": ""3.5.0"",
    ""css-loader"": ""0.28.10"",
    ""extract-text-webpack-plugin"": ""4.0.0-beta.0"",
    ""html-loader"": ""0.5.5"",
    ""html-webpack-plugin"": ""^3.0.4"",
    ""husky"": ""0.14.3"",
    ""jasmine-core"": ""^2.99.0"",
    ""jasmine-spec-reporter"": ""4.2.1"",
    ""karma"": ""2.0.0"",
    ""karma-chrome-launcher"": ""2.2.0"",
    ""karma-coverage-istanbul-reporter"": ""1.4.1"",
    ""karma-jasmine"": ""1.1.1"",
    ""karma-jasmine-html-reporter"": ""0.2.2"",
    ""less"": ""3.0.1"",
    ""less-loader"": ""4.0.6"",
    ""postcss"": ""6.0.19"",
    ""postcss-cssnext"": ""3.1.0"",
    ""postcss-easy-import"": ""3.0.0"",
    ""postcss-load-plugins"": ""2.3.0"",
    ""postcss-loader"": ""2.1.1"",
    ""protractor"": ""^5.3.0"",
    ""puppeteer"": ""1.1.1"",
    ""serve"": ""6.5.1"",
    ""style-loader"": ""0.20.2"",
    ""to-string-loader"": ""1.1.5"",
    ""ts-node"": ""5.0.1"",
    ""tslint"": ""5.9.1"",
    ""tslint-config-standard"": ""7.0.0"",
    ""tslint-eslint-rules"": ""5.1.0"",
    ""typescript"": ""2.6.2"",
    ""uglifyjs-webpack-plugin"": ""1.2.2"",
    ""webpack"": ""4.1.0"",
    ""webpack-cli"": ""^2.0.10"",
    ""webpack-dev-server"": ""3.1.0"",
    ""write-file-webpack-plugin"": ""4.2.0""
  },
  ""dependencies"": {
    ""@angular/animations"": ""6.0.0-beta.6"",
    ""@angular/common"": ""6.0.0-beta.6"",
    ""@angular/compiler"": ""6.0.0-beta.6"",
    ""@angular/core"": ""6.0.0-beta.6"",
    ""@angular/forms"": ""6.0.0-beta.6"",
    ""@angular/http"": ""6.0.0-beta.6"",
    ""@angular/language-service"": ""6.0.0-beta.6"",
    ""@angular/platform-browser"": ""6.0.0-beta.6"",
    ""@angular/platform-browser-dynamic"": ""6.0.0-beta.6"",
    ""@angular/router"": ""5.2.7"",
    ""angular"": ""1.6.9"",
    ""core-js"": ""2.5.3"",
    ""rxjs"": ""5.5.6"",
    ""zone.js"": ""0.8.20""
  }
}",JonWallsten,NONE,2018-03-06 15:02:34+00:00,True,2018-08-02 00:48:39+00:00,148.41,,15,22,2018-03-10 01:44:43+00:00,3.45,slackersoft,MEMBER,2,0,0,13,['Karma'],False,False,False,False,True,False,False,False,False,False,False,False,False,False,False
1524,beforeAll not working as expected (version 3.1),could be because this option?,andrew-vdb,NONE,2018-03-07 10:19:46+00:00,True,2018-03-10 01:38:48+00:00,2.64,,2,1,2018-03-10 01:38:48+00:00,2.64,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1525,Disable empty tests,"Hello,
Can we have an option (or maybe make it as default behavior) that empty tests which look like
it('should do smth', () => {})

will be failed or at least provide some warnings. This's extremely important if you testing some async actions.",fetis,NONE,2018-03-09 16:10:22+00:00,True,2018-03-10 01:33:54+00:00,0.39,,2,5,2018-03-10 01:33:54+00:00,0.39,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1526,StackTrace component truncating error messages from certain stack traces,"Since Jasmine 3.0.0, the StackTrace component strips all but the first line of certain error messages that come from the raw browser trace. When running in Chrome, this affects AngularJS exceptions that can be multi-line.
I made a plunker to illustrate the issue with an AngularJS exception - see https://embed.plnkr.co/3qtge9FUP0PCIlu2jB9m/. This plunker boots Jasmine with a custom reporter, and runs a simple Angular app. The output in the gray box comes from the strackTrace object passed into specDone reporter method - the gray box is showing the message and stack properties. You can see the full error is only included in the message, but is stripped from the stack.
I was able to confirm the issue began with this commit: 5906a2c. The issue is not present in Jasmine 2.99.x.
Thanks!
Expected Behavior
To be able to view the full multi-line error message, and the stack trace.
Current Behavior
Can only see the first line of the error message, and the stack trace.
Possible Solution
Update the StackTrace logic to handle this error format.
Context
This of course makes it difficult to track debug issues. I'm using karma-jasmine specifically which outputs the stackTrace stack.
Your Environment

Version used: Jasmine 3.0.0 +
Environment name and version: Chrome 64
Operating System and version: desktop",rmunch,NONE,2018-03-09 21:46:46+00:00,True,2018-03-10 20:05:10+00:00,0.93,,4,7,2018-03-10 01:27:33+00:00,0.15,slackersoft,MEMBER,2,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1528,Jamsine,"There is no directive with ""exportAs"" set to ""matButtonToggleGroup""
<mat-button-toggle-group (ngModelChange)=""changeView($event)"" [ngModel]=""currentView"" [ERROR ->]#group=""matButtonToggleGroup"">
<mat-button-toggle matTooltip=""GanttChart"" value=""ganttch""): ng:///DynamicTestModule/ActionsComponent.html@2:94
There is no directive with ""exportAs"" set to ""bs-mdbPopover"" ("" 
    <span style=""width:170px"" placement=""bottom"" [ERROR ->]#pop1=""bs-mdbPopover"" [mdbPopover]=""popTemplate"" mdbRippleRadius class=""changeFilter pull-right selec""): ng:///DynamicTestModule/ActionsComponent.html@50:53

The pipe 'search' could not be found (""pan>

<li (click)=""changeuser(user);pop1.hide()"" *ngFor='let [ERROR ->]user of auth.subordinates | search:{ string: filterText, type: ""user"" }' [class.active]=""currentFilte""): ng:///DynamicTestModule/ActionsComponent.html@117:71
The pipe 'search' could not be found ("" 
<li (click)=""changeplan(invit.plan);pop1.hide()"" *ngFor='let i[ERROR ->]nvit of currentUserPlans  | search: { string: filterText, type: ""filter"" }' [class.active]=""currentPl""): ng:///DynamicTestModule/ActionsComponent.html@143:74",smritiz,NONE,2018-03-12 12:29:29+00:00,True,2018-03-12 14:38:26+00:00,0.09,,2,1,2018-03-12 14:38:26+00:00,0.09,sgravrock,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1529,"Enumerating Specs after loading test file (broken in 3.x, worked in 2.9)","I work on the Node Tools for Visual Studio and after the release of Jasmine 3.0 our ability to enumerate tests has broken. 😞
Before 3.0 we were able to do the following to get a list of specs in a specific file, and communicate that back to VS to show in the test explorer.
var testList = [];
var jasmineInstance = // create instance
jasmineInstance.env.specFilter = (spec) => {
   testList.push({
       test: spec.getSpecName(spec),
       // bunch more properties
       });
       return false; 
    };
jasmineInstance.addSpecFiles([testFile]);
jasmineInstance.loadSpecs();
But in 3.0 the specFilter function no longer seems to be called when loadSpecs is called.
My question is, is there a way to access the enumerated Specs before executing the tests? If there isn't what would be a logical place to make a change to implement this? (I wasn't able to find anything useful, but I only spend a little time spelunking through the code).",paulvanbrenk,CONTRIBUTOR,2018-03-12 23:56:20+00:00,True,2018-03-13 00:22:44+00:00,0.02,,2,2,2018-03-13 00:16:44+00:00,0.01,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1530,ES 7 Array.includes issue,"Expected Behavior
Should not return error when using Array.includes(element)
Current Behavior
Returns following error
TypeError: undefined is not a constructor (evaluating 'exclusions.includes(element) 
Possible Solution
Array.includes() can be replaced with Array.indexOf > -1.
Suite that reproduces the behavior (for bugs)

TS
  exclusionTest() {
    return this.exclusions('Event').includes('id');
  }

  exclusions(eventType: string): string[] {
    let defaultExclusions = ['id', 'pendStatus', 'accountId'];
    return eventType === 'REMOVE' ? defaultExclusions : [...defaultExclusions, 'pendDeleteReason'];
  }
In angular environment
describe ('SomeComponent', () => {
  let fixture: ComponentFixture<SomeComponent>;

  beforeEach(() => {

    TestBed.configureTestingModule({
      providers: [
        SomeComponent,
      ]
    });
  });

  it('should test includes', inject([SomeComponent],
      (component: SomeComponent) => {
        expect(component.exclusionTest()).toBeTruthy();
    }));
  });
});
Context
I am trying to test if an Array has a particular element.
Since there is an option to use indexOf, it does not affect as much. But with this issue, testing is dictating how i write my javascript code.
Your Environment

Version used: jasmine@2.99.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome Version 64.0.3282.186 (Official Build) (64-bit)
Operating System and version (desktop or mobile): Mac OS
Link to your project: internal company project. Cannot link.",vsharma2266,NONE,2018-03-16 15:44:41+00:00,True,2018-03-21 15:57:39+00:00,5.01,,3,3,2018-03-16 16:30:15+00:00,0.03,vsharma2266,NONE,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1531,List filtered specs without executing them,"I am using Jasmine in stand-alone mode in the browser. Every time, I am opening the page, all the tests are executed. I would prefer to have an option to set if tests should be executed or just listed (in gray). More or less an interactive mode (cf Git).
It could take the form of:

URL parameter (my_test.html?execution=false)
A check box option in the Options menu of Jasmine

Advantages:

You don't have to change your code to choose which specs to do

Avoid to disturb the git
You can share the spec param to provide the same filter


You can see and prepare which tests are going to be done (Also because each suites/specs give a link to select automatically the sub tests)
You can open a page with tests without launching them right now (I have mostly integration tests that use the browser API, they impact the UI directly and are resource consuming)

Temporary solution but limited
This code makes all and only all the tests to be listed (in grey) without being executed if spec param is empty or not defined. It is like if no spec names match the filter, then all the tests are listed. Am I right ?
Limitation: I didn't find an alternative to keep the list mode while filtering the specs by name.
var specFilter = new jasmine.HtmlSpecFilter({
  filterString: function() {
    switch(queryString.getParam(""spec"")) {
      case ""all"":
        return """";
      case undefined:
        return ""@@@@@@@"";
      case """":
        return ""@@@@@@@"";
      default:
        return queryString.getParam(""spec"")
    }
  }
});

var env = jasmine.getEnv();

env.specFilter = function(spec) {
  return specFilter.matches(spec.getFullName());
};",Morikko,NONE,2018-03-19 20:47:45+00:00,False,,,,2,2,2018-03-24 00:14:20+00:00,4.14,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1532,"""fit"" and ""fdescribe"" are ignored in jasmine-core >= 3.0.0 when run via Karma","How to reproduce:
package.json:
{
  ""name"": ""jasmine-core-fit-bug"",
  ""version"": ""1.0.0"",
  ""description"": """",
  ""main"": ""index.js"",
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1""
  },
  ""author"": """",
  ""license"": ""ISC"",
  ""devDependencies"": {
    ""jasmine-core"": ""^3.1.0"",
    ""karma"": ""^2.0.0"",
    ""karma-chrome-launcher"": ""^2.2.0"",
    ""karma-jasmine"": ""^1.1.1""
  }
}

karma.conf.js:
// Karma configuration
// Generated on Tue Mar 20 2018 11:36:08 GMT+0100 (CET)

module.exports = function(config) {
  config.set({

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    frameworks: ['jasmine'],


    // list of files / patterns to load in the browser
    files: [
      'spec/*.spec.js'
    ],


    // list of files / patterns to exclude
    exclude: [
    ],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    preprocessors: {
    },


    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    reporters: ['progress'],


    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,


    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['Chrome'],


    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: false,

    // Concurrency level
    // how many browser should be started simultaneous
    concurrency: Infinity
  })
}

spec/allspecs.spec.js:
it('makes sure that true is true', () => {
  expect(true).toBe(true);
});

fit('makes sure that false is false', () => {
  expect(false).toBe(false);
});

Expected output:
Chrome 65.0.3325 (Mac OS X 10.12.6): Executed 1 of 2 (skipped 1) SUCCESS (0.003 secs / 0 secs)

Actual output:
Chrome 65.0.3325 (Mac OS X 10.12.6): Executed 2 of 2 SUCCESS (0.006 secs / 0 secs)

It works, if you use jasmine-core in Version 2.9.1:
""jasmine-core"": ""^2.9.1"",",djungowski,NONE,2018-03-20 11:44:26+00:00,True,2018-05-15 00:19:32+00:00,55.52,,8,15,2018-03-21 12:49:29+00:00,1.05,mramato,NONE,2,0,0,6,['Karma'],False,False,False,False,True,False,False,False,False,False,False,False,False,False,False
1533,Feature request: Stop entire test suite execution on beforeAll failure,"This is somewhat related to issue #577, but different because it deals with beforeAll instead of beforeEach. In many situations, I imagine that a failure in beforeAll means that there's no useful information to be gained from continuing the test. It would be nice to immediately fail without trying to run each of the specs after that.
Expected Behavior
describe('bad setup', function() {
  beforeAll(function() {
    throw new Error('error from beforeAll');
  });

  it('test 1', function() {
    expect(1).toEqual(11);
  });
});
Expected behavior - output:
Suite error: bad setup
Message:
Error: error from beforeAll
Current Behavior
Output tries to run all tests:
Failures:


bad setup test 1
Message:
Expected 1 to equal 11.
Stack:
...


bad setup test 2
Message:
Expected 2 to equal 22.
Stack:
...


Suite error: bad error
Message:
Error: error from beforeAll
Suite that reproduces the behavior (for bugs)
describe('bad setup', function() {
  beforeAll(function() {
    throw new Error('error from beforeAll');
  });

  it('test 1', function() {
    expect(1).toEqual(11);
  });
});
Your Environment
Jasmine 3.1. I believe this behavior is the same in all environments. I have tried both with and without stopSpecOnExpectationFailure",juliemr,NONE,2018-03-22 00:51:38+00:00,False,,,,4,5,2018-03-22 00:58:54+00:00,0.01,slackersoft,MEMBER,1,0,0,3,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1534,"jasmine-html.js put an ""i"" variable in the global scope","Expected Behavior
To not pollute the global scope
Current Behavior
An ""i"" variable is attached to the global scope (window.i)
Possible Solution
Replace:  ""for(i"" with ""for(var i"" on line 214 and 235 of jasmine-html.js",MassimoFoti,NONE,2018-03-25 17:32:17+00:00,True,2018-03-25 21:04:44+00:00,0.15,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1535,"Add some way to handle css, scss, html files in node","The world seems to be leaving Jasmine behind. recently I was forced to swtich one of my test services to use Jest instead of Jasmine, which was rather painless as I think Jest must respect Jasmine syntax. However I cannot stand how Jest ignores fdescribe and fit.  But the problem is this:
I can find no documentation or examples of how to get Jasmine to handle or mock css, scss or html. This is not a front end app, but I need to process some css and html and when I import or require these files Jasmine goes ballistic.
Is this even possible with out aid from karma? Are there any examples of doing this?
I would expect to be able to add some type of transform to a config like:
""transform"": {
  ""^.+.(js|jsx)$"": ""<rootDir>/node_modules/babel-jest"",
  ""^.+.(css|scss|handlebars)$"": ""<rootDir>/config/jest/textTransform.js""
}

}
I don't want to test the results of the css or html, I just want to test the test the code surrounding it. Any thoughts on this?",kevinlbatchelor,NONE,2018-03-26 20:01:58+00:00,True,2018-08-16 01:00:03+00:00,142.21,,3,5,2018-03-28 00:32:02+00:00,1.19,slackersoft,MEMBER,2,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1537,incorrect test execution queue,"// file.spec.js
describe('[test]', () => {
    it('first', () => {
        expect(true).toBeTruthy();
    });
    it('second', () => {
        expect(true).toBeTruthy();
    });
});

in file.spec.js -> ctrl + S (first save):
[test]
   first
   second

in file.spec.js -> ctrl + S (second save):
[test]
   second
   first

Is it normal that the test execution queue is broken
part package.json with version libraries-
{
  ""devDependencies"": {
    ""@types/enzyme"": ""^3.1.9"",
    ""@types/enzyme-adapter-react-16"": ""^1.0.2"",
    ""@types/jasmine"": ""^2.8.6"",
    ""@types/react"": ""^16.1.0"",
    ""@types/react-redux"": ""^5.0.15"",
    ""@types/redux"": ""^3.6.0"",
    ""awesome-typescript-loader"": ""^5.0.0-1"",
    ""cross-env"": ""^5.1.4"",
    ""css-loader"": ""^0.28.11"",
    ""enzyme"": ""^3.3.0"",
    ""enzyme-adapter-react-16"": ""^1.1.1"",
    ""html-webpack-plugin"": ""^3.1.0"",
    ""jasmine"": ""^3.1.0"",
    ""jasmine-spec-reporter"": ""^4.2.1"",
    ""karma"": ""^2.0.0"",
    ""karma-chrome-launcher"": ""^2.2.0"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^1.0.0"",
    ""karma-sourcemap-loader"": ""^0.3.7"",
    ""karma-spec-reporter"": ""0.0.32"",
    ""karma-webpack"": ""^4.0.0-beta.0"",
    ""node-sass"": ""^4.8.3"",
    ""object-assign"": ""^4.1.1"",
    ""sass-loader"": ""^6.0.7"",
    ""style-loader"": ""^0.20.3"",
    ""typescript"": ""^2.8.1"",
    ""webpack"": ""^4.4.1""
  }
}

Is bug?",vasivas,NONE,2018-04-03 08:42:22+00:00,True,2018-04-17 18:55:13+00:00,14.43,,5,6,2018-04-03 19:53:55+00:00,0.47,sgravrock,MEMBER,2,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1538,Cannot test non exported function of file.,"I have a .ts file which has few non-exported functions.
I am unable to test this since the scope of this function is not clear (Closure function).
Eg.
export function b(){
a()
}
function a(){
}

Here I am unable to test this function a(). However, I were able to spy on same with
jasmine.createSpy('a')",hir06,NONE,2018-04-04 07:42:41+00:00,True,2018-04-05 00:18:13+00:00,0.69,,2,1,2018-04-05 00:18:13+00:00,0.69,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1539,Extend the interface of all Expectations by the `optionally` function/keyword. ,"Feature request
Extend the interface of all Expectations by the optionally function/keyword.
=> Apply a certain expectation if and only if property is existing.
==> It does not matter if it does not exist, but if it does, expect it to be of certain shape..
technical Solution
In   function Expectation(options) { I would love to see code like:
    this.isOptional = options.isOptional;

In Expectation.prototype.wrapCompare I would love to see something like:
      function defaultOptionalCompare() {
        if (args[0] != null) {
            return matcher.compare.apply(null, args);
        }
        return { pass: true };
      }
      if (this.isOptional) {
        matcherCompare = defaultOptionalCompare;
      }

In Expectation.Factory add code like:
    options.isOptional = true;
    expect.optionally = new Expectation(options);",wzr1337,NONE,2018-04-05 08:37:53+00:00,True,2018-04-06 00:38:58+00:00,0.67,,2,2,2018-04-06 00:38:58+00:00,0.67,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1540,is it possible to mqtt services,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Expected Behavior


Current Behavior


Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context


Your Environment


Version used:
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:",raghulrajnkl,NONE,2018-04-06 11:18:41+00:00,True,2018-04-06 16:23:23+00:00,0.21,,2,1,2018-04-06 16:23:23+00:00,0.21,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1541,Option to set random order for a single suite?,"With ^3.0.0, is it possible to set the random option for a single suite (describe) as well?
We'd like to use random: true as a default to encourage properly encapsulated tests, but will need to keep the old non-random behaviour for a number of legacy specs until they can be migrated.",colinjoy,NONE,2018-04-10 14:59:36+00:00,True,2018-05-09 20:11:30+00:00,29.22,,2,1,2018-04-17 18:52:13+00:00,7.16,sgravrock,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1542,.toEqual & .toBe is not a function - Build breaks,"Hi All,
I am new to the angular/Jasmine frameworks. Can anyone advise me for the below issue? I saw other 's post but the anwser is not clear,
Package.JSON
{ ""name"": ""dashboard-kendo-ui"", ""version"": ""1.0.0"", ""license"": ""MIT"", ""scripts"": { ""ng"": ""ng"", ""start"": ""ng serve"", ""build"": ""ng build --prod"", ""test"": ""ng test"", ""lint"": ""ng lint"", ""e2e"": ""ng e2e"" }, ""private"": true, ""dependencies"": { ""@angular/animations"": ""^5.2.9"", ""@angular/common"": ""^5.2.0"", ""@angular/compiler"": ""^5.2.0"", ""@angular/core"": ""^5.2.0"", ""@angular/forms"": ""^5.2.0"", ""@angular/http"": ""^5.2.0"", ""@angular/platform-browser"": ""^5.2.0"", ""@angular/platform-browser-dynamic"": ""^5.2.0"", ""@angular/router"": ""^5.2.0"", ""@progress/kendo-angular-buttons"": ""^3.0.4"", ""@progress/kendo-angular-charts"": ""^2.0.3"", ""@progress/kendo-angular-dateinputs"": ""^2.2.0"", ""@progress/kendo-angular-dialog"": ""^3.4.0"", ""@progress/kendo-angular-dropdowns"": ""^2.1.0"", ""@progress/kendo-angular-excel-export"": ""^1.0.7"", ""@progress/kendo-angular-grid"": ""^2.1.2"", ""@progress/kendo-angular-inputs"": ""^2.2.0"", ""@progress/kendo-angular-intl"": ""^1.3.2"", ""@progress/kendo-angular-l10n"": ""^1.1.0"", ""@progress/kendo-angular-layout"": ""^2.2.1"", ""@progress/kendo-angular-popup"": ""^2.1.0"", ""@progress/kendo-angular-upload"": ""^3.0.3"", ""@progress/kendo-data-query"": ""^1.2.2"", ""@progress/kendo-drawing"": ""^1.5.2"", ""@progress/kendo-angular-ripple"" : ""^0.2.5"", ""@progress/kendo-theme-default"": ""^2.49.1"", ""classlist.js"": ""^1.1.20150312"", ""core-js"": ""^2.4.1"", ""hammerjs"": ""^2.0.8"", ""rxjs"": ""^5.5.6"", ""web-animations-js"": ""^2.3.1"", ""zone.js"": ""^0.8.19"" }, ""devDependencies"": { ""@angular/cli"": ""~1.7.3"", ""@angular/compiler-cli"": ""^5.2.0"", ""@angular/language-service"": ""^5.2.0"", ""@types/jasmine"": ""~2.5.38"", ""@types/node"": ""~6.0.60"", ""codelyzer"": ""^4.0.1"", **_""jasmine-core"": ""~2.5.2"",_** ""jasmine-spec-reporter"": ""~3.2.0"", ""karma"": ""~1.4.1"", ""karma-chrome-launcher"": ""~2.0.0"", ""karma-coverage-istanbul-reporter"": ""^0.2.0"", ""karma-jasmine"": ""~1.1.0"", ""karma-jasmine-html-reporter"": ""^0.2.2"", ""protractor"": ""~5.1.0"", ""ts-node"": ""~2.0.0"", ""tslint"": ""~5.9.1"", ""typescript"": ""~2.5.3"" } }",muthucse7,NONE,2018-04-16 02:55:04+00:00,True,2018-08-16 00:39:04+00:00,121.91,,2,2,2018-04-17 00:15:47+00:00,0.89,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1543,Matchers can't compare promises,"So I've got some long standing unit tests that have been running for several months that are all just verifying that the return of functions is wrapped in a promise, and are all basically iterations of:
expect(object.function()).toEqual(Promise.resolve());
These tests run fine on jasmine 2.8, but if I update to 2.99 (or 3.0+), the tests fail with the message:
Error: Expected [object Promise] to equal [object Promise].
I couldn't see any recent checks in the toEqual function, so I'm wondering if I'm missing something?",chrisgodsey,NONE,2018-04-17 18:14:24+00:00,True,2019-02-22 01:36:27+00:00,310.31,,3,7,2018-04-17 18:42:00+00:00,0.02,sgravrock,MEMBER,2,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1544,Information on automatic generation of Jasmine Unit test cases,"Are you creating an issue in the correct repository: Yes
Hello Folks,
We are trying to generate jasmine test cases automatically from developed java script code. Any idea if someone of you have developed some utility or recommendation?
Thanks.
Akhilesh T
+91 8130652060",akhileshtripa,NONE,2018-04-18 07:22:12+00:00,True,2018-04-19 00:40:41+00:00,0.72,,2,1,2018-04-19 00:40:41+00:00,0.72,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1545,Customize PrettyPrinter,"Hello I wanna customize PrettyPrinter. I wanna see result of toHaveBeenCalledWith
like
Object({
  key: value,
  key: value2,
})

instead of
Object({key: value,key: value2});

I searched the internet I wan't able to make error message like above.So I tried to modify PrettyPrinter little bit. I changed code jasmine code. But I don't want to do it. I achieve this by decorating PrettyPrinter not directly modifying it.
But I found that I couldn't access PrettyPrinter in my code because PrettyPrinter is private in pp function.
It there any way to customize it or another way to prettify error message of toHaveBeenCalledWith or
object compare. I don't want to add matcher for toHaveBeenCalledWith because It is very hard work..
ps. Is there any reason it's impossible or hard to prettify toHaveBeenCalledWith reported message? or Is there any option already for it?
Thank you for reading.",UniverseHan,NONE,2018-04-23 06:07:15+00:00,False,,,,3,3,2018-04-24 18:38:13+00:00,1.52,whyboris,NONE,1,0,0,2,['help needed'],False,False,False,False,False,False,False,False,False,False,False,False,False,False,True
1546,Inconsistent behavior in async/await tests,"When the following block is running, the test is always successful. am I doing something wrong?
const promise = new Promise((resolve, reject) => resolve(2))

describe('tests', () => {
  it('somethings', async () => {
      expect(await promise).toEqual(1);
  });
})
Edit:
I checked again and put the assertion block to the tr/catch statements. It's throw an exception with TypeError{} error. I think the  problem is in my configuration.
Expected Behavior
The test should be fail.


Current Behavior
The test always successfull


Your Environment

Version used: 3.1.0
Environment name and version (node: 8.11.1 / ChromeHeadless):
Operating System and version (macOS, 10.13.4):",atayahmet,NONE,2018-04-23 11:11:47+00:00,True,2018-04-23 20:43:57+00:00,0.4,,2,2,2018-04-23 14:23:54+00:00,0.13,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1547,Add new syntax to execute expecations on Promises,"We've heard from a number of folks that working with Promises in Jasmine is harder than it needs to be. To that end, we're looking for pull requests to add an expect.async expectation that will have only asynchronous matchers on it that return promises that can be awaited by the test code.
Desired Behavior
it(""promises"", () => {
  expect.async(promiseFunc()).toBeResolved();
});
Current Behavior
it(""promises"", () => {
  var result = await promiseFunc();
  expect(result).toEqual(1);
});
Key points on the solution

If global.Promise is not available in the current environment, the expect.async() function should throw an Error indicating the issue. Jasmine wants to allow polyfills, but not provide them
The Promise returned to the executing suite should attempt to always resolve successfully
The intermediate Promise returned by a matcher, and handled by the expectation message system, should resolve with the same type of object as a synchronous matcher

with a boolean pass
an optional message, that can be either a string, or a function returning a string


Needs to also support .not so that a user could expect.async(promiseFunc()).not.toBeRejected()
The intermediate Promise returned by a matcher should only be rejected if the something is wrong with the use of the matcher, such as the actual not being a Promise
Minimal async matchers included should be toBeRejected and toBeResolved

additional matchers like toBeResolvedTo(<stuff>) are fine but not required for the initial release
allowing custom async matchers are not required for the initial release



This is probably a large piece of work, but will be useful to many Jasmine users.
Context
See also #1447",slackersoft,MEMBER,2018-04-24 00:59:53+00:00,True,2018-06-05 04:12:01+00:00,42.13,,2,2,2018-11-02 15:24:12+00:00,192.6,rubenlg,NONE,1,0,0,1,"['feature request', 'ready for work']",False,True,False,False,False,False,False,False,False,True,False,False,False,False,False
1548,Jasmine reports skipped tests as executed,"When skipping test using fdescribe in Jasmine 3.1.0 the tests come back as executed and as passing.
Expected Behavior
Skipped tests should be listed as skipped
Current Behavior
Skipped tests are being reported as Successful
Suite that reproduces the behavior (for bugs)
A well outlined suite can be found here
Context
Having to wait for thousands of tests to pretend to run is a hassle.
Your Environment
outline here",Benjarmil,NONE,2018-04-24 23:31:08+00:00,True,2018-04-25 00:07:12+00:00,0.03,,2,2,2018-04-25 00:07:12+00:00,0.03,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1549,Support for logging the expectation failure to the console in Jasmine.,"Expected Behavior
When an expectation fails in a test spec, it would be great to show the line number of the assertion in the console of the browser.
Current Behavior
Currently, when an expectation fails, there is no information to the developer which line it has failed.
Possible Solution
Adding console.error() or console.log() to the expectationFailureFactory maybe? I am not really sure about it. Sorry about the ignorance.
Suite that reproduces the behavior (for bugs)
describe(""sample"", () => {
  it('test', () => {
  expect(true).toBe(false); 
 }
});
Context
In the above spec, the expectation fails on line 3. It would be great to see that in the console of the browser with the expectation failure message.
Your Environment

Version used: Jasmine 2.9.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 65, node 9.4
Operating System and version (desktop or mobile): MacOSX High Sierra.

Note: It already logs the range of line numbers (of the spec) to the browser like here:
at eval (http://localhost:3000/build/exp/chains/test.spec.js?1524674:24:30) which indicates the error is from 24 to 30 but not precisely the expectation line.",applecool,NONE,2018-04-25 22:29:15+00:00,True,2018-04-26 00:04:18+00:00,0.07,,2,4,2018-04-25 22:34:26+00:00,0.0,applecool,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1550,jasmine tests run in random order,"Hi,
We are using wdio-jasmine-framework to run our e2e test, but we found out the test steps run in random order.
Same issue has been reported in wdio-jasmine-framework.
webdriverio-boneyard/wdio-jasmine-framework#124",dudaming,NONE,2018-04-26 15:35:26+00:00,True,2018-04-26 23:59:25+00:00,0.35,,2,3,2018-04-26 23:59:25+00:00,0.35,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1552,Property 'jasmineMatches' is missing in type,"I constantly get this error in jasmine tests and I don't understand what causes this error. Stackoverflow user suggests it's problem with Jasmine typings
Here's the small code for example
    it('should work with empty arrays', () => {
      expect(ReviewComponent.orderByTime([])).toEqual([]);
    });

orderByTime is a simple function which just sort array with built-in sort function. But I get
Type 'undefined[]' is not assignable to type 'ObjectContaining<void>'.
    Property 'jasmineMatches' is missing in type 'undefined[]'.

This code is valid in my understanding, but not for Jasmine.
As a workaround, I can fix the error by adding .toEqual([] as any), but I don't think it's a proper way to this it.
Your Environment


Version used: jasmine-core@2.9.1, typescript@2.6.2
Environment name and version (e.g. Chrome 39, node.js 5.4): HeadlessChrome 65.0.3325, node v8.9.4
Operating System and version (desktop or mobile): Mac OS X 10.13.4",fetis,NONE,2018-04-30 15:10:31+00:00,True,2018-04-30 15:16:21+00:00,0.0,,1,1,2018-04-30 15:16:21+00:00,0.0,fetis,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1553,ability to spyOn multiple funtions,"let func1  = spyOn(component.prototype , func1)
let func2  = spyOn(component.prototype , func2)

right now why jasmine is not allowing to spyOn multiple funtions ?
it is only allowing to spyOn one funtion at a time..
how to unit test  when a scenario come ,where one function is calling other funtion",shivasai09,NONE,2018-05-01 10:10:38+00:00,True,2018-08-16 00:44:45+00:00,106.61,,2,2,2018-05-03 00:59:09+00:00,1.62,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1554,How to know in the test if expectation failed or not?,"Sometimes I find it useful to know inside the test if an expectation failed or not.
Currently, I just repeat the matcher logic in the test. For example
expect(1+1).toBe(3); // log failure in reporter
if (1+1 === 3){ // decide on future test steps
   ... // only relevant if 1+1 === 3
}else{
   ... // relevant if 1+1!==3
}
However it would be nice to be able to reuse a matcher instead. For example something like this:
if (expect(1+1).toBe(3)){ // real failure to be shown in reports
   ... // skip these steps as they are not relevant in this case
} else {
   ... // move on to these steps since 1+1 is not 3. 
}
Or with promises
expect(someAsyncThing()).toBe(3).then(()=>{...}).catch(()=>{...})
I just can't seem to find a way to know if an expectation failed or not. Is there a way to know this?",GuyMograbi,NONE,2018-05-02 00:21:00+00:00,False,,,,5,9,2018-05-02 03:20:55+00:00,0.12,sgravrock,MEMBER,2,1,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1556,Setting Up Jasmine With ASP.Net Core Web Application,"Is there a recommended practice or a walk through for setting up Jasmine with an ASP.Net Core Web Application?  I've posted a question on SO, but haven't gotten any responses yet, so any type of response would be helpful.",daryllabar,NONE,2018-05-09 18:08:14+00:00,True,2018-05-12 00:33:43+00:00,2.27,,2,2,2018-05-12 00:33:43+00:00,2.27,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1557,Mark test suite as ordered/serial,"Is there a way to create a suite that runs specs in order? I don't need to set it globally, just for some special suites. Something like:
describe_ordered(""sample"", function() {
});
Your Environment
Jasmine 3.1.0",the-spyke,NONE,2018-05-14 10:49:42+00:00,True,2018-05-15 00:28:29+00:00,0.57,,2,3,2018-05-15 00:28:29+00:00,0.57,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1558,Async question after utilize code in documentation,"Expected Behavior
Unit test should pass
Current Behavior
unit test fails. https://www.screencast.com/t/XkVOsPIs71j
Suite that reproduces the behavior (for bugs)
Test Suite
var contentURL = ""/MyVector/Assignments/Admin/_ManagePositionsTile"";
var actionURL = '/MyVector/Assignments/Position';

   var response = `<a id=""managePositionsLink"" href=""#""
       onclick = ""showInverseLoader($('#managePositionsPanel')); return false;"" >
           <div id=""managePositionsPanel"" class=""panel panel-blue"" style=""margin: 0"">
               <div class=""panel-heading"">
                   <div class=""row"">
                       <div class=""col-xs-3"">
                           <i class=""fa fa-fighter-jet fa-5x""></i>
                       </div>
                       <div class=""col-xs-9 text-right"">
                           <h4>Positions</h4>
                           <div>56,352 Positions</div>
                       </div>

                   </div>
               </div>
               <div class=""panel-footer"">
                   <span class=""pull-left"">Manage Positions</span>
                   <span class=""pull-right""><i class=""fa fa-arrow-circle-right""></i></span>
                   <div class=""clearfix""></div>
               </div>
           </div>
       </a >`;

       describe(""Using promises"", function() {
        if (!browserHasPromises()) {
          return;
        }
    
        beforeEach(function() {
          return soon().then(function() {
            $('#testHarness').prepend(""<div id='managePositionsTileSection' data-content-url='"" + contentURL + ""' data-action-url='"" + actionURL+""'></div>"");
            $.mockjax({
                url: contentURL,
                responseText: {
                    status: ""success"",
                    responseText: response
                }
            });
          });
        });
    
    
        it(""should support async execution of test preparation and expectations"", function() {
            AssignmentManagerAdminModule.Initialize();
            var link = $(""#managePositionsLink"");
            expect(link.length).toEqual(0);
            return soon().then(function() {
            
            var link = $(""#managePositionsLink"");
            expect(link.length).toEqual(1);
          });
        });
      });
    
      function soon() {
        return new Promise(function(resolve, reject) {
          setTimeout(function() {
            resolve();
          }, 1);
        });
      }
    
      function browserHasPromises() {
        return typeof Promise !== 'undefined';
      }
Test Harness
<!DOCTYPE html>
<html>
<head>
    <meta charset=""utf-8"">
    <title>Jasmine Spec Runner v3.1.0</title>
    <link rel=""shortcut icon"" type=""image/png"" href=""lib/jasmine-3.1.0/jasmine_favicon.png"">
    <link rel=""stylesheet"" href=""../node_modules/jasmine-core/lib/jasmine-core/jasmine.css"">
    
    <script src=""../node_modules/jasmine-core/lib/jasmine-core/jasmine.js""></script>
    <script src=""../node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js""></script>
    <script src=""../node_modules/jasmine-core/lib/jasmine-core/boot.js""></script>
    <script src=""lib/mock-ajax.js""></script>
    <script src=""../Scripts/jquery-3.1.1.js""></script>
    <script src=""../Scripts/global/globals.js""></script>
    <script src=""../node_modules/jquery-mockjax/dist/jquery.mockjax.min.js""></script>
    <script src=""../js/Assignments/Admin/AssignmentManagerAdmin.js""></script>
    <!-- include spec files here... -->
    <script src=""AssignmentManagerAdmin.spec.js""></script>
</head>

<body>
<div id='testHarness'/>
</body>
</html>
System under test
AssignmentManagerAdminModule = (function () {
    var managePositionsTileContentUrl;
    var managePositionsTileActionUrl;
    var configureVmlEligibilityCriteriaUrl;

    function loadManagePostionsTile() {
        $.get({ url: managePositionsTileContentUrl, cache: false }).then(function (result) {
            if (result.responseText) {
                result = result.responseText;
            }
            $(""#managePositionsTileSection"").html(result); //attempting to validate this line
            $(""#managePositionsLink"").on(""click"", function (e) {
                e.preventDefault();
                window.location.href = managePositionsTileActionUrl;
            });
        });
    }

    function setupPage() {
        managePositionsTileContentUrl = $(""#managePositionsTileSection"").data(""content-url"");
        managePositionsTileActionUrl = $(""#managePositionsTileSection"").data(""action-url"");
        configureVmlEligibilityCriteriaUrl = $(""#vmlEligibilityCriteriaModalContainer"").data(""url"");
        loadManagePostionsTile();
    }
    
    /* test-code */
    var _managePositionsTileContentUrl, _managePositionsTileActionUrl,_configureVmlEligibilityCriteriaUrl;
        
    /* end-test-code */

    return {
        Initialize: function () {
            setupPage();
        }
        /* test-code */
        , test: function () {
            if (jasmine) {
                this._managePositionsTileContentUrl = managePositionsTileContentUrl;
                this._managePositionsTileActionUrl = managePositionsTileActionUrl;
                this._configureVmlEligibilityCriteriaUrl = configureVmlEligibilityCriteriaUrl;
            }
        }
        /* end-test-code */
    };
})();
Context


My application is in serious need of unit tests against our javascript code base.  I was able to perform unit tests against sychronous action.  I tried to use jasmine-ajax to perform asych unit tests, but documentation / actual experience in utilizing it was not performing as expected.  I was seeing actual ajax requests instead of fake request I expected to see.
I found jquery-mockjax https://github.com/jakerella/jquery-mockjax, which performed fake requests that Jasmine-ajax was not performing as desired.
https://www.screencast.com/t/twE5KEIKYc
Your Environment


Version used: 3.1.0
Environment name and version: 66.0.3359.170 (Official Build) (64-bit)
Operating System and version (desktop or mobile): Windows 10 1803",minoseah629,NONE,2018-05-15 17:18:52+00:00,True,2018-05-15 17:37:46+00:00,0.01,,1,1,2018-05-15 17:37:46+00:00,0.01,minoseah629,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1559,online,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Expected Behavior


Current Behavior


Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context


Your Environment


Version used:
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:",virtax,NONE,2018-05-17 12:24:10+00:00,True,2018-05-17 13:58:53+00:00,0.07,,2,1,2018-05-17 13:58:53+00:00,0.07,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1560,How to exclude some spec files in jasmine?,"Is there any way to exclude some spec files with in a directory in jasmine?
For example, I want to exclude all spec in the extended folder from Foo folder.
```
├── Foo
│   ├── sub
|   |    |
|   |    |--extended
│   │         ├── a-spec.js
|   |         ├── e-spec.js
│   ├── b-spec.js
│   ├── c-spec.js
│   ├── d-spec.js
└── 
```

I have tried with folowing jasmin.json.But this is not working.
    {
    ""spec_dir"": ""Foo/"",
    ""spec_files"": [
        ""**/*[sS]pec.js"",
        ""!**/extended/*.js""
    ]
}",Chinmoy-globalIds,NONE,2018-05-21 05:51:11+00:00,True,2018-05-21 05:52:03+00:00,0.0,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1562,[Feature Request] [v.3.x.x] Are there any plans to add Flow types for v3.x.x ? ,"I see that there are jasmine flow types in flow-typed project for version 2.4.x.
Could we add for v 3.x.x as well ? Are there any plans on doing that?",puneetar,NONE,2018-05-22 23:35:15+00:00,True,2018-12-06 00:18:14+00:00,197.03,,2,1,2018-05-24 00:21:46+00:00,1.03,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1563,"--fail-fast fails forgetfully (only skips upcoming specs in the current suite, then runs specs in the next suite)","Are you creating an issue in the correct repository?
The jasmine-npm tool has a --fail-fast=true command line option but it seems to be operating correctly (it parses and passes flags); the real issue is apparently inside jasmine-core.

Jasmine npm

Expected Behavior
When running a spec suite with several describe blocks, if you specify --fail-fast=true, it should abort the entire test run, skipping all upcoming specs and describes, and reporting only a single failure.
Current Behavior
When running a spec suite with several describe blocks, if you specify --fail-fast=true, after a failure, it skips upcoming specs in the current block, but continues to run all upcoming describe blocks. Then if a test fails, it skips all upcoming specs in that describe block, but jumps to the next and resets again.
Basically, given the spec below:
describe(""Apple"", function() {
    it(""mercury"", function() {
        fail();
    });
    it(""venus"", function() {
        fail();
    });
    it(""earth"", function() {
        fail();
    });
});

describe(""Banana"", function() {
    it(""mars"", function() {
        fail();
    });
    it(""jupiter"", function() {
        fail();
    });
    it(""saturn"", function() {
        fail();
    });
});

describe(""Cherry"", function() {
    it(""uranus"", function() {
        fail();
    });
    it(""neptune"", function() {
        fail();
    });
    it(""pluto"", function() {
        fail();
    });
});

If you run it with fail-fast=true and --random=false, you should see only a single failure (""Apple mercury"") but instead you see three failures (""Apple mercury"", ""Banana mars"", and ""Cherry uranus"").
Failures:
1) Apple mercury
  Message:
    Failed
  Stack:
    Error: Failed
        at <Jasmine>
    Error: Failed
        at <Jasmine>
        at UserContext.<anonymous> (/Users/alex/code/fail-fast-forgets.spec.js:3:9)
        at <Jasmine>

2) Banana mars
  Message:
    Failed
  Stack:
    Error: Failed
        at <Jasmine>
        at UserContext.<anonymous> (/Users/alex/code/fail-fast-forgets.spec.js:15:9)
        at <Jasmine>

3) Cherry uranus
  Message:
    Failed
  Stack:
    Error: Failed
        at <Jasmine>
        at UserContext.<anonymous> (/Users/alex/code/fail-fast-forgets.spec.js:27:9)
        at <Jasmine>



Possible Solution
I have implemented a solution but it's a hack...
nodeComplete() sets a variable hasFailures which would seem to do the trick. I'd like to check it inside Spec.execute and if fail-fast is set and hasFailures is true, skip lightly on, like xit does.
But sadly, I couldn't figure out how to get access to hasFailures from inside Spec.execute (jasmine.js:620 or so).
So I wrote a global accessor and got it that way, checking it at the same place pending and excluded specs are checked:
if (this.markedPending || excluded === true || $HACK_HAS_FAILURES()) {

and this provided the correct behavior (only report the first failure).
If someone can point me in the right direction I'll take another stab at it.
Suite that reproduces the behavior (for bugs)
The above suite reproduces the behavior but I haven't written a meta-spec that would assert that if you pass in the proper command line options and suite, that only one failure is reported.
Context
I am teaching a class using test-guided exercises from exercism.io and testfirst.org. In that class it is important that the students work on one feature (spec) at a time, then move on to the next. Seeing a dozen test failures is confusing, especially when they're in random order.
(As a side issue, IMHO specifying fail-fast should also change the default value of random to false, otherwise you would potentially see a different test failing on each run, which negates the use case of fail-fast to focus on a single failure at a time. I may submit this as a feature request or PR later.)
Your Environment



Version used: 3.1.0 (jasmine-npm and jasmine-core)


Environment name and version (e.g. Chrome 39, node.js 5.4):
kombucha-mac:code [ruby 2.3.3p222] alex$ npm -v
3.10.9
kombucha-mac:code [ruby 2.3.3p222] alex$ node -v
v7.2.0


Operating System and version (desktop or mobile):
MacOS High Sierra


Link to your project:
https://github.com/alexch/exercism-javascript",alexch,NONE,2018-05-25 16:27:22+00:00,True,2018-05-31 00:34:35+00:00,5.34,,1,1,2018-05-25 17:13:53+00:00,0.03,alexch,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1564,Question: How to use a custom matcher when using toHaveBeenCalledWith,"The following test-case verifies if the service (which uses Angular HttpClient to do a post request) does indeed use certain headers.
I want to write some custom matching code to check if the headers contains a certain key and value, like:
headers.get('Session') === 'abc'
My question is what to write at the ??? in below example?
spyOn(http, 'post').and.returnValue(new Observable<Response>());

const result = service.Post<string>(data);

assert.isNotNull(result);

expect(http.post).toHaveBeenCalledWith(`http://localhost/odata/Employees`, jasmine.any(String),
    {
        headers: // ???,
        observe: 'response'
    });

Is this possible?",StefH,NONE,2018-06-04 06:07:21+00:00,True,2018-06-13 00:10:02+00:00,8.75,,2,2,2018-06-05 00:06:14+00:00,0.75,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1565,Env() properties are sorely lacking JavaDoc,"https://jasmine.github.io/api/3.0/Env.html
""Documentation generated by JSDoc 3.5.5 on ...""
Only one method of the created Env instance has JavaDoc comments on it (addReporter), and that's the only one documented in the generated Env page.
I noticed this because Jasmine 3.0 randomizes the order of tests by default, per release notes.  For my testing, that's bad because I often place simpler tests earlier than more complex ones.  If I call jasmine.getEnv().randomizeTests(false), I think that will solve the problem for me.  But I am not sure because the documentation doesn't say anything about this new method.",ajvincent,NONE,2018-06-04 08:49:48+00:00,True,2018-06-06 00:14:01+00:00,1.64,,2,3,2018-06-05 00:18:17+00:00,0.64,slackersoft,MEMBER,1,0,0,1,"['help needed', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,False,False,False,True
1568,Feature request: Matcher that verifies that none of the spies in a SpyObj were called,"Desired Behavior
A matcher that verifies that none of the spies of the specified object have been called - i.e. there have been zero interactions with an entire mock service.
httpClient = jasmine.createSpyObj('HttpClient',
  ['get', 'post', 'put', 'delete', 'head', 'options', 'patch']);

// Checks that there have been no calls to httpClient.get, httpClient.post, etc.
expect(httpClient).not.toHaveBeenCalled();

Current Behavior
Error: <toHaveBeenCalled> : Expected a spy, but got
  Object({ get: spy on HttpClient.get, post: spy on HttpClient.post, ... })

Thus requiring:
expect(httpClient.get).not.toHaveBeenCalled();
expect(httpClient.post).not.toHaveBeenCalled();
expect(httpClient.put).not.toHaveBeenCalled();
expect(httpClient.delete).not.toHaveBeenCalled();
expect(httpClient.options).not.toHaveBeenCalled();
expect(httpClient.head).not.toHaveBeenCalled();
expect(httpClient.patch).not.toHaveBeenCalled();

Context
If I want to test there have been no HTTP calls for a specific condition, I don't want to have to check every possible method - someone might add a PUT in there but the test doesn't checking for that so still passes.
Other frameworks such as Java's Mockito have this capability - Mockito.verifyZeroInteractions(mock) - to allow us to verify that a particular service was not interacted with at all.",pcroc,NONE,2018-06-18 09:47:30+00:00,False,,,,3,4,2018-06-19 00:48:44+00:00,0.63,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1570,Karma + Jasmine infinite freezing,"326 / 600 tests executed, then hangs.
19 06 2018 15:54:19.133:WARN [Firefox 52.0.0 (Windows 8.1 0.0.0)]: Disconnected (1 times)
Firefox 52.0.0 (Windows 8.1 0.0.0) ERROR
  Disconnected

Tried with Chrome - same thing.
19 06 2018 16:11:34.594:WARN [Chrome 67.0.3396 (Windows 8.1 0.0.0)]: Disconnected (1 times)
Chrome 67.0.3396 (Windows 8.1 0.0.0) ERROR
  Disconnected

Current config:
    browsers: ['Firefox'],
    singleRun: true,
    autoWatch: false,
    /**
     * How long will Karma wait for a message from a browser before disconnecting from it (in ms).
     */
    browserNoActivityTimeout: 100000,
    /**
     * maximum number of tries a browser will attempt to reconnect in the case of a disconnection
     */
    browserDisconnectTolerance: 2,
    browserDisconnectTimeout: 210000,
    captureTimeout: 60000,
    retryLimit: 5,
    concurrency: Infinity,

    frameworks: ['browserify', 'jasmine'],

    client: {
      mocha: {
        /*
        @see https://github.com/karma-runner/karma-phantomjs-launcher/issues/126
        */
        timeout: 20000
      }
    },

    reporters: ['mocha', 'junit', 'html', 'coverage'],

    plugins: [
      'karma-junit-reporter',
      'karma-jasmine',
      'karma-chrome-launcher',
      'karma-firefox-launcher',
      'karma-html-reporter',
      'karma-browserify',
      'karma-coverage',
      'karma-babel-preprocessor',
      'karma-mocha-reporter',
    ],
hardware:

CPU: Intel Xeon E5-1620 v3 @ 3.5GHz
RAM: 128 GB
GPU: Nvidia Quadro K2200 4GB RAM

environment:

OS:  win 8.1 x64
node: v10.0.0
npm: 5.6.0

modules:
    ""jasmine-core"": ""2.99.1"",
    ""karma"": ""2.0.3"",
    ""socket.io"": ""1.4.5""
    ""jasmine-ajax"": ""3.4.0"",
    ""karma-babel-preprocessor"": ""6.0.1"",
    ""karma-browserify"": ""5.3.0"",
    ""karma-chrome-launcher"": ""2.0.0"",
    ""karma-coverage"": ""1.1.1"",
    ""karma-firefox-launcher"": ""1.1.0"",
    ""karma-html-reporter"": ""0.2.7"",
    ""karma-jasmine"": ""1.1.2"",
    ""karma-junit-reporter"": ""1.2.0"",
    ""karma-mocha-reporter"": ""2.2.0"",
    ""babel-polyfill"": ""6.23.0"",
    ""babel-preset-es2015"": ""6.16.0"",
    ""babel-preset-es2016"": ""6.22.0"",
    ""babelify"": ""7.3.0"",
    ""browserify"": ""14.4.0"",
    ""browserify-istanbul"": ""2.0.0"",
    ""eslint"": ""3.19.0"",
    ""eslint-config-airbnb-base"": ""11.1.3"",
    ""eslint-plugin-import"": ""2.2.0"",
    ""gulp"": ""3.9.1"",
    ""gulp-babel"": ""6.1.2"",
    ""gulp-clean"": ""0.3.2"",
    ""gulp-connect"": ""5.0.0"",
    ""gulp-notify"": ""2.2.0"",
    ""gulp-param"": ""1.0.3"",
    ""gulp-replace"": ""0.5.4"",
    ""gulp-sonar"": ""3.0.1"",
    ""gulp-sourcemaps"": ""1.6.0"",
    ""gulp-util"": ""3.0.7"",
    ""isparta"": ""4.0.0"",
    ""istanbul"": ""0.4.5"",
    ""node-notifier"": ""4.6.1"",
    ""proxyquireify"": ""3.2.1"",
    ""shelljs"": ""0.7.8"",
    ""vinyl-buffer"": ""1.0.0"",
    ""vinyl-source-stream"": ""1.1.0"",
    ""watchify"": ""3.9.0"",
Notable observations:

Browsers tab saturates 1 CPU core usage (~100%)
Memory usage keeps growing,

from about 100mb to 750 in 1 minute on FF
from about 60 to 180 on Chrome


tab is unresponsive entirely until gets killed by karma or crashes with crash report (only on FF).
karma guys say it's not their fault
jasmine guys say it's not their fault
karma-jasmine guys say it's not their fault

related issues:
#1327
karma-runner/karma#1788
karma-runner/karma#762
karma-runner/karma-phantomjs-launcher#126
karma-runner/karma-phantomjs-launcher#55
karma-runner/karma-phantomjs-launcher#126
May this help those who come after us fare better 😉",Usnul,NONE,2018-06-19 14:18:37+00:00,True,2018-06-21 00:27:24+00:00,1.42,,2,3,2018-06-20 00:20:39+00:00,0.42,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1571,"CIA: Community, Interfacing and Attitude","Jasmine is an amazing project, one that I love and have personally been using for nearly a decade.
I have been tracking participation of core contributors of jasmine over the past few days here and in related projects. Here's what I have noticed and have an issue with:

Presumption of Incompetence. Assumption is made that the reporter has made a mistake and no issue exists unless proven otherwise.
Dismissal. I have often read ""Thanks for using jasmine!"" in a comment where the comment uses polite words to say ""it is not important to us"".
Defensiveness. A lot of critique of the project is viewed as an attack on the project and its contributors, this makes any further discussion a lot less productive.
Shifting the blame. Jasmine is used by many other projects and is typically a component of a larger infrastructure in real-world usage, which means that it is rarely used in isolation. I have read a lot of comments along the lines of ""You use Jasmine with X, please address your problems to X instead of Jasmine"" or ""We noticed that you use Jasmine with tests, please address your problems with your tests!""

I believe the above points are making jasmine an unwelcoming community and is a net negative for the project as a whole and would like to invite a discussion on how to address these.
Example
here is a thread that may serve as anecdotal evidence: #1570
the overview goes like so:

A new person (A) presents a problem
Senior member (S) comments quoting a quote of A back and claiming ""can't reproduce""
A corrects S on the reasonable assumption that reproduction was not attempted
S responds with I would also urge you to be careful and considerate when telling others what they have and haven't done. We've invested a significant amount of time [...]
S closes the issue
S locks the issue as ""too heated""",Usnul,NONE,2018-06-21 08:23:43+00:00,True,2018-07-21 00:56:26+00:00,29.69,,2,2,2018-07-21 00:56:26+00:00,29.69,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1572,jasmine.DEFAULT_TIMEOUT_INTERVAL not being respected with async await,"I have code that goes something like the following:
it('will always timeout', () => {
  jasmine.DEFAULT_TIMEOUT_INTERVAL = 999999
  const x = await someThingNotThatSlow()
  expect(x).toBe(true);
}

And I get
Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.

I'm quite confident that the async function I'm calling isn't over the timeout. If there is trouble reproducing, I can try and work together an example. My real word scenario has some incidental complexity .I would need to wring out.",CADBOT,NONE,2018-06-26 07:39:28+00:00,True,2019-02-22 01:43:27+00:00,240.75,,2,5,2018-06-26 07:45:40+00:00,0.0,CADBOT,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1573,"jitSpy = spyOn(window, 'Function').and.callThrough(); breaks Jasmine","Imagine you would like to spy on new Function() calls. This may be accomplished in your tests by something like so:
const mySpy = spyOn(window, 'Function').and.callThrough();

This works great as expected except if one would like to test with clock. In that case it fails with NullPointerException. The crux of the problem is code which contains `Function.prototype.apply.apply:


  
    
      jasmine/src/core/Clock.js
    
    
        Lines 90 to 96
      in
      74287c5
    
    
    
    

        
          
           self.setTimeout = function(fn, delay, params) { 
        

        
          
             return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]); 
        

        
          
           }; 
        

        
          
            
        

        
          
           self.setInterval = function(fn, delay, params) { 
        

        
          
             return Function.prototype.apply.apply(timer.setInterval, [global, arguments]); 
        

        
          
           }; 
        
    
  



  
    
      jasmine/src/core/QueueRunner.js
    
    
        Lines 54 to 60
      in
      8bb0e2d
    
    
    
    

        
          
           QueueRunner.prototype.clearTimeout = function(timeoutId) { 
        

        
          
             Function.prototype.apply.apply(this.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]); 
        

        
          
           }; 
        

        
          
            
        

        
          
           QueueRunner.prototype.setTimeout = function(fn, timeout) { 
        

        
          
             return Function.prototype.apply.apply(this.timeout.setTimeout, [j$.getGlobal(), [fn, timeout]]); 
        

        
          
           }; 
        
    
  



  
    
      jasmine/src/core/ClearStack.js
    
    
        Lines 44 to 46
      in
      9ee7b4e
    
    
    
    

        
          
           var setTimeoutImpl = function clearStack(fn) { 
        

        
          
               Function.prototype.apply.apply(realSetTimeout, [global, [fn, 0]]); 
        

        
          
           }; 
        
    
  



With spy enabled on Function Function.prototype.apply.apply raises NPE because Function.prototype.apply is not defined.
The issue is that spyOn replaces native Function with an instance of Function which no longer has the prototype.
Suggested Fix.
In all cases where Function.prototype.apply.apply is invoked, replace it with.
// Place the next line at top of the file in the outer most context so that `Function.prototype`
// can be captured early.
const Function_prototype = Function.prototype;


function someFunction() {
  // Now even if `Function` gets replace in `spyOn` the code works fine 
  // Since we are working with the original Function.prototype
  Function_prototype.apply.apply(...);
}

Simple workaround in tests
For users of jasmine which may run into this problem the following line fixes the issues in your test.
const mySpy = spyOn(ɵglobal, 'Function').and.callThrough();
// Patch prototype due to spying on the Function
Function.prototype.apply = Function.constructor.prototype.apply;",mhevery,NONE,2018-07-02 16:51:07+00:00,False,,,,3,3,2018-08-10 00:23:55+00:00,38.31,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1574,[v3.1.x] Potential regression with custom matcher usage,"When using a custom matcher (like toBeUseless below)  inside a then method of a Promise, Jasmine will throw:
(node:41179) UnhandledPromiseRejectionWarning: TypeError: expect(...).toBeUseless is not a function
    at Promise.resolve.then (/Users/cedric/Code/tests/jasmine-v3-custom-matchers/spec/custom-matcher-in-promise.spec.js:19:32)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)

Expected Behavior
Let's consider a dumb custom matcher:
const customMatcher = {
  toBeUseless: (util, customEqualityTesters) => ({
    compare: (actual, expected) => ({
      pass: true, message: 'useless'
    })
  })
}
Used a in unit test:
describe('Custom matcher', () => {

  beforeEach(() => jasmine.addMatchers(customMatcher));
  
  it('should succeed', () => {
    expect(true).toBeUseless(true);
  });

  it('should succeed in promise', () => {
    Promise.resolve()
      .then(() => expect(true).toBeUseless(true));
  });

});
This will succeed if using Jasmine v2.99
You can check out a simple reproduction repository here: https://github.com/cexbrayat/jasmine-v3-custom-matchers/blob/master/spec/custom-matcher-in-promise.spec.js
Current Behavior
The same unit tests using Jasmine v3.1 with the following error:
(node:41179) UnhandledPromiseRejectionWarning: TypeError: expect(...).toBeUseless is not a function
    at Promise.resolve.then (/Users/cedric/Code/tests/jasmine-v3-custom-matchers/spec/custom-matcher-in-promise.spec.js:19:32)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)

Note that the error for the unknown custom matcher only arises in the then case.
See the same reproduction repo, with this PR cexbrayat/jasmine-v3-custom-matchers#1
A simple npm install, npm test will reproduce the issue.
Possible Solution
Weirdly, registering the custom matcher again in the then makes the test pass:
describe('Custom matcher', () => {

  beforeEach(() => jasmine.addMatchers(customMatcher));
  
  it('should succeed', () => {
    expect(true).toBeUseless(true);
  });

  it('should succeed in promise', () => {
    Promise.resolve()
      .then(() => {
        // register again the matcher
        jasmine.addMatchers(customMatcher);
        expect(true).toBeUseless(true);
      });
  });

});
Suite that reproduces the behavior (for bugs)
See above or https://github.com/cexbrayat/jasmine-v3-custom-matchers
Context
This bugs hits us when bumping an Angular project from Jasmine v2.99 to v3.1, in which we use custom matchers.
Your Environment


Version used: v3.1.0
Environment name and version (e.g. Chrome 39, node.js 5.4): node v8.11.2
Operating System and version (desktop or mobile): MacOS 10.13.5
Link to your project:

Original issue: Ninja-Squad/globe42#203
Dumbed down repro: https://github.com/cexbrayat/jasmine-v3-custom-matchers",cexbrayat,NONE,2018-07-02 19:54:54+00:00,True,2018-07-06 10:47:30+00:00,3.62,,2,2,2018-07-06 10:46:06+00:00,3.62,cexbrayat,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1575,ERROR: TypeError: s.substring is not a function,"Expected Behavior
jasmin nicely print error
Current Behavior
fails with murky message
Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
  it('d', async(()=>{
//TypeError, like  (stack is from when it's wropped in try /catch)
TypeError: Cannot read property '$injector' of undefined
    at http://localhost:9876/_karma_webpack_/webpack:/src/tests/newPayment.spec.ts:214:41
    at ZoneDelegate.push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone.js:388:1)
    at AsyncTestZoneSpec.push../node_modules/zone.js/dist/zone-testing.js.AsyncTestZoneSpec.onInvoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone-testing.js:713:1)
    at ProxyZoneSpec.push../node_modules/zone.js/dist/zone-testing.js.ProxyZoneSpec.onInvoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone-testing.js:285:1)
    at ZoneDelegate.push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone.js:387:1)
    at Zone.push../node_modules/zone.js/dist/zone.js.Zone.run (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone.js:138:1)
    at http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone.js:872:1
    at ZoneDelegate.push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone.js:421:1)
    at AsyncTestZoneSpec.push../node_modules/zone.js/dist/zone-testing.js.AsyncTestZoneSpec.onInvokeTask (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone-testing.js:697:1)
    at ProxyZoneSpec.push../node_modules/zone.js/dist/zone-testing.js.ProxyZoneSpec.onInvokeTask (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/dist/zone-testing.js:316:1)

}));
});

fails with 
TypeError: s.substring is not a function
    at truncate (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4652:11)
    at PrettyPrinter.append (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4637:18)
    at PrettyPrinter.emitScalar (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4478:10)
    at PrettyPrinter.format (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4434:14)
    at PrettyPrinter.emitArray (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4496:12)
    at PrettyPrinter.format (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4440:16)
    at PrettyPrinter.formatProperty (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4632:14)
    at http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4594:12
    at PrettyPrinter.iterateObject (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4471:7)
    at PrettyPrinter.emitObject (http://localhost:9876/absolute/home/mememe/dvl/proj/proj/node_modules/jasmine-core/lib/jasmine-core/jasmine.js?daba65c98fa088349a3e9d7df843a63405ccfc15:4587:26)
Context


Your Environment


Version used:3.1.0
Environment name and version (e.g. Chrome 39, node.js 5.4):  Chrome 66.0.3359.139 , node v8.11.3
Operating System and version (desktop or mobile):  4.15.0-23-generic #25-Ubuntu SMP
Link to your project:",bushuyev,NONE,2018-07-06 14:10:01+00:00,True,2019-05-21 00:18:39+00:00,318.42,,5,8,2018-07-20 00:50:42+00:00,13.44,slackersoft,MEMBER,1,0,0,3,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1576,"""Stop execution on spec failure"" does not work","Expected Behavior


""Stop execution on spec failure"" does not work
Current Behavior


The specs keep executing even if a previous spec has failed.
Your Environment


Jasmine core : v3.1.0
Chrome 67
Operating System and version (desktop or mobile): OSX 10.13.5",maximedupre,NONE,2018-07-07 20:52:04+00:00,True,2019-01-23 01:48:24+00:00,199.21,,3,8,2018-07-20 00:54:24+00:00,12.17,slackersoft,MEMBER,1,1,0,1,['Karma'],False,False,False,False,True,False,False,False,False,False,False,False,False,False,False
1577,callFake on express route,"I am using Jasmine for test and meet some problems with callFake.
I fake fetchPanelRowData function in my test, but it still steps into original fetchPanelRowData.
express dashboardRouter:
exports.fetchPanelRowData = (req, res) => {
    ...
}

spec:
const request = require('supertest');
const app = require('../../app');
const dshRouter = require('../../routes/dashboardRouter');

describe('test dashboard router: ', () => {

    it('test fetchPanelRowData', async () => {
        spyOn(dshRouter, 'fetchPanelRowData').and.callFake((req, res) => {
            res.status(500).end();
        });

        let response = await request(app).post('/api/fetchPanelRowData');
        expect(response.statusCode).toBe(500);
        expect(dshRouter.fetchPanelRowData).toHaveBeenCalled();
    })
})

Any ideas?",tzjoke,NONE,2018-07-10 00:58:40+00:00,True,2018-10-22 18:37:07+00:00,104.74,,2,2,2018-07-21 00:31:49+00:00,10.98,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1578,beforeAll called non non-focused specs,"From my understanding, for the following tests, the beforeAll on the ""disabled suite"" should no be called, but it is.
describe.only(""enabled suite"", () => {
  it(""enabled test"", () => {
  });
});

describe(""disabled suite"", () => {
  beforeAll(() => {
    console.log(""should not run"");
  });

  it(""disabled"");
});

This is on 23.4.0.
Your Environment


Version used: This is on 23.4.0.",rlotufo,NONE,2018-07-11 18:58:10+00:00,True,2018-07-19 01:41:58+00:00,7.28,,2,2,2018-07-19 00:50:14+00:00,7.24,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1579,pending() in beforeEach does not stop execution,"Expected Behavior
Calling pending() in beforeEach should allow the user to prevent further execution of a spec.
Current Behavior
Calling pending() in the spec itself stops spec execution while calling it in beforeEach only marks the test as pending but does not stop execution.
Suite that reproduces the behavior (for bugs)
./node_modules/.bin/jasmine --random=false dummy.spec.js of
describe(""pending in body"", () => {
  it(""should not explode"", () => {
    pending(""Stop execution or things will explode"");
    console.log(""body: boom!"");
  });
});

describe(""pending in beforeEach"", () => {
  beforeEach(() => pending(""Stop execution or things will explode""));

  it(""should not explode"", () => {
    console.log(""beforeEach: boom!"");
  });
});
prints
Started
*beforeEach: boom!
*

Pending:

1) pending in body should not explode
  Stop execution or things will explode


2) pending in beforeEach should not explode
  Stop execution or things will explode

2 specs, 0 failures, 2 pending specs
Finished in 0.009 seconds

Context
In our environment we want to selectively stop test execution for client-server tests when server is not there. Marking the spec as pending is not sufficient since a complex initialization is started that leads to some very hard to debug exceptions in afterAll.
Your Environment

node v8.10.0
jasmine 3.1.0",webmaster128,NONE,2018-07-17 07:31:14+00:00,False,,,,3,5,2018-07-25 00:43:31+00:00,7.72,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1580,"possibility to mark describe/it's to run mandatory, also when there are focused tests","We run our login in a spec as a test (because in Protractors ""onPrepare"" no expect-statements may run).
When now working on another spec/describe/it of the application under test I'd like to mark this describe and/or it as focused, so when I run, only login and the part I'm working on gets executed.
Because of the number of tests and people working on the code, it's quite time consuming and error prone to focus/unfocus manually all ""mandatory"" describe/it blocks to ensure, that the application under tests reaches the one ""describe/it"" we're currently working on.
Expected Behavior
Possibility to mark describe/it as ""mdescribe""/""mit"" (mandatory describe/it). These parts shall not be ignored by a focused test execution, but shall not define a focused execution on its own.
Current Behavior
No possibility to define/mark describe/it-blocks that need to be executed also in focused execution.
Suite that reproduces the behavior (for bugs)

/*abstract structure of my idea 
in our case all those describes are in different files and get called via a caller-function*/
mdescribe(""login"", function() {
});
mdescribe(""create customer"", function(){
});
describe(""add tax data"", function(){
});
describe(""add address data"", function(){
});
fdescribe(""add category tags"", function(){
});",zwingliernst,NONE,2018-07-18 13:38:09+00:00,True,2018-08-10 00:59:42+00:00,22.47,,2,3,2018-08-02 00:54:16+00:00,14.47,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1582,[Question] Testing WebSockets with Jasmine,"Could some one please provide a working code example, on how to test WebSockets using Jasmine syntax and spies? (Do I need any additional libraries like Rxjs or what not?)",Jakems777,NONE,2018-07-19 11:52:06+00:00,True,2018-07-25 00:30:10+00:00,5.53,,2,1,2018-07-25 00:30:10+00:00,5.53,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1583,Uncaught TypeError: Cannot read property 'classList' of undefined thrown,"Hi,
Jasmine: 2.0.4
This error is logged to console sometime afterEach completes and sometime beforeEach starts.
Uncaught TypeError: Cannot read property 'classList' of undefined thrown
Any ideas how to diagnose?
Cheers
Jeremy",greengumby,NONE,2018-07-23 09:25:33+00:00,True,2018-10-22 18:38:05+00:00,91.38,,2,2,2018-07-24 00:32:28+00:00,0.63,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1584,Error acessing availableMatchers on IE8,"I'm running Jasmine with Karma on IE8 and there's a error occurring when Jasmine-core try to run through the array of availableMatchers.
The error is caused because IE8 treats arrays declarations syntax different of modern browsers, not allowing the last item to be postfixed with a comma without adding an extra undefined item to array like in the image bellow

Expected Behavior
Jasmine core should iterate through availableMatchers array without issue on any compatible browser, like IE8.
Current Behavior
Jasmine-core are throwing an exception when try to access the last item of availableMatchers (the undefined item that IE8 adds to array)
Possible Solution
Remove comma after the last item on declaration of availableMatchers
Your Environment


Version used: Internet Explorer 8.0.7601.17514
Environment name and version (e.g. Chrome 39, node.js 5.4): IE8
Operating System and version (desktop or mobile): Windows 7",Tanato,NONE,2018-07-23 18:44:07+00:00,True,2018-07-24 00:38:38+00:00,0.25,,2,1,2018-07-24 00:38:38+00:00,0.25,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1586,spy on an objects object,"This is a netsuite based unit test. So we generally use apis. I am new to jasmine. I have an api which is in a window. So this returns an object. I have to spy on that object.
function userEventBeforeLoad_addCusRecWf(type){
nlapiGetField(""custentity_cybersource_error_code"").setDisplayType(""hidden"");
}
so here I have to spy on setDisplayType(""hidden"");
I need to check if it is actually hidden or not. Is there a way to do that.
nlapiGetField is in window.
i.e
window.nlapiGetField = function(){
return{
setDisplayType: function()
}
}",sirishasriramineni207,NONE,2018-07-24 20:55:44+00:00,True,2019-02-22 01:36:57+00:00,212.2,,2,2,2018-07-27 00:44:36+00:00,2.16,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1587,Zone is needed for the async() test helper but could not be found.,"Are you creating an issue in the correct repository?
I'm writing a project in Angular 6.x. This is a new project so tests are just getting started.
I'm running tests and getting the following error when using async():
Zone is needed for the async() test helper but could not be found.
Please make sure that your environment includes zone.js/dist/zone.js

Is this a configuration issue? I'm not sure where to include Zone because I've tried everywhere and nothing seems to fix this.

Expected Behavior
I expect requiring or importing Zone to fix the issue but see no progress. I've tried it in all places I can think of.
Current Behavior
This error throws on all tests that use async()
Possible Solution
Suite that reproduces the behavior (for bugs)

describe('AppComponent', () => {

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent,
      ],
      imports: [AtlasLibModule],
    }).compileComponents();
  }));

}
Context
Simply trying to run tests on a new project.
Your Environment
Intellij IDEA Ultimate 2018.1
Windows 10
Jasmine 3.0
Wallaby.js
Angular 6.x",dudewad,NONE,2018-07-28 22:23:16+00:00,True,2018-07-31 22:15:32+00:00,2.99,,1,1,2018-07-31 22:15:32+00:00,2.99,dudewad,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1589,How to reuse code of 'it' block / Is there a way we can call 'it' block in other spec files?,"Hi,
I have multiple spec files in which I want to reuse the code of 'it' block from some other spec file just to avoid code redundancy.
Is there a way to achieve this purpose?",bharukaRupesh,NONE,2018-08-08 05:04:47+00:00,True,2018-08-09 02:33:29+00:00,0.89,,3,2,2018-08-09 02:33:29+00:00,0.89,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1590,Jasmine 3.2.0 breaks spyOn().and.returnValue(Promise.reject()),"Expected Behavior
When trying to create a spy using spyOn(things, 'function).and.returnValue(Promise.reject()), I expect the function to have a spy.
Current Behavior
When trying to create a spy using spyOn(things, 'function).and.returnValue(Promise.reject()), the function does not change to a spy. It is the original function still. Doing so with a Promise.resolve() correctly makes a spy.
Logging out fetch.fetch within main shows the actual fetch function instead of the spy.
This behavior worked as intended until jasmine updated to 3.2.0;

import * as fetch from './fetch';
import Promise from 'bluebird';
export async function main(event, context, callback) {
    try {
        await Promise.map(things, (thing) => {
            return fetch.fetch(thing);
        });

        return callback();
    } catch (error) {
        console.error(error);
    }
}
import { main } from './thing';
import * as fetch from './fetch';
describe(""main"", function() {
    it('errors correctly', (done) => {
        const fetchSpy = spyOn(fetch, 'fetch').and.returnValue(Promise.reject({ message: 'failure' }));

        main({}, {}, () => {
            expect(fetchSpy).toHaveBeenCalled();
            done();
       });
    });
});
Context
Jasmine updating to 3.2.0 (via Package.json of ^3.0.0) broke our build machine of previously passing tests.
Your Environment

Version used: 3.0.0, 3.1.0, 3.2.0 Jasmine
Environment name and version (e.g. Chrome 39, node.js 5.4): Node 8.1.0
Operating System and version (desktop or mobile): Mac Sierra & Alpine Linux build machine",veeto620,NONE,2018-08-10 15:11:42+00:00,False,,,,5,6,2018-08-11 00:38:01+00:00,0.39,slackersoft,MEMBER,1,1,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1591,"Do not manage to import a module ""User.findById is not a function""","Hello there,
Expected Behavior
I have 3 files:
// user.js

const findById = async id => {
  //...
}

module.exports = {
  findById
}
// auth.js
const User = require('../models/user')

const validateToken = async token => {
  // ...
  const user = await User.findById(id)
  return user
}

module.exports = { validateToken }
// auth.spec.js
// ...
const auth = require('../../src/services/auth')
describe('validateToken', () => {
    const userData = {
      firstName: 'Nico',
      lastName: 'Andre',
      email: 'nicolas@any.com',
      password: 'myPassword'
    }
    let user
    beforeEach(async () => {
      user = await User.create(userData)
    })
    it('Should return a user', async () => {
      const token = auth.make(user)
      const { email, _id } = await auth.validateToken(token)
      expect(email).toBe(user.email)
      expect(_id).toBe(user._id)
    })
  })
So if not wrong, auth.spec imports auth that imports user yes but
Current Behavior
I receive an error form the console:
Failures:
1) JWT Service validate Should return a user
  Message:
    TypeError: User.findById is not a function
  Stack:
        at <Jasmine>
        at Object.validate ([...]auth.js:38:27)
        at process._tickCallback (internal/process/next_tick.js:68:7)

Ran 1 of 30 specs
1 spec, 1 failure
Finished in 0.163 seconds

I already tried to exports a full defined object like: (didn't work)
const core = { findById: findById }
module.exports = core
when I debug User > it's just an empty literal object ({})
Did anyone experienced this type of bug? Or have any idea where to start investigating?
Context

Express app designed as an API
not using Babel
Model is managed by mongoose
Node 10.8

Thanks a lot for your help",nclsndr,NONE,2018-08-13 14:47:12+00:00,True,2019-02-22 01:38:59+00:00,192.45,,3,3,2018-08-15 00:46:38+00:00,1.42,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1592,In npm is last 3.2.0 not 3.21,From npm is not possible install last version 3.2.1,rebajz,NONE,2018-08-16 07:09:49+00:00,True,2018-10-30 07:42:35+00:00,75.02,,2,2,2018-08-17 00:13:49+00:00,0.71,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1594,Improve exception formatter,"Expected Behavior
If an expectation fails because of an ErrorEvent it should print at least the message of that ErrorEvent object.
Current Behavior
The printed message is simply [object ErrorEvent] thrown
This is because the ErrorEvent object does not have a name property, so it drops into the else case in the ExceptionFormatter here https://github.com/jasmine/jasmine/blob/master/src/core/ExceptionFormatter.js#L8
Possible Solution
The exception formatter could be changed, so that it can handle the ErrorEvent object which is described here https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent
Suite that reproduces the behavior (for bugs)
https://stackblitz.com/edit/jasmine-error-event",giniedp,NONE,2018-08-23 08:23:30+00:00,True,2018-09-26 00:29:11+00:00,33.67,,4,3,2018-08-24 00:18:35+00:00,0.66,slackersoft,MEMBER,1,1,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1595,implement toBeRejectedWith(exception) method,"jasmine now has toBeRejected() method to check if promise rejects, however it doesn't check for specific exception being thrown, which limits its use.
It would be very helpful  to have toBeRejectedWith(exception) method which would be used like this:
await expectAsync(aPromise).toBeRejectedWith(expectedError);

or to be even more flexible:
await expectAsync(aPromise).toBeRejectedWith({message: 'expected error message'});
await expectAsync(aPromise).toBeRejectedWith({code: 21});",dkrantsberg,NONE,2018-08-23 19:20:57+00:00,True,2018-10-22 18:20:18+00:00,59.96,,2,1,2018-08-24 00:21:00+00:00,0.21,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1596,Add optional status marks to standalone,"Expected Behavior
Following up on issue #463, I suggest adding an option to display status marks next to each spec in the Spec List in the standalone version.
Current Behavior
The shades of green, yellow, and red used for passing, failing, and pending specs are impossible to distinguish for people with Monochromacy/Achromatopsia, and the shades of green and red are almost impossible to distinguish for people with Red-Blind/Protanopia. Here's a sample Spec List using the original colors:

Here's how it looks to someone with Monochromacy/Achromatopsia:

And here's how it looks to someone with Red-Blind/Protanopia:

(I used color-blindness.com to generate these two images.)
Possible Solution
Add optional status marks next to each spec in the Spec List. Here's a suggestion of what that could look like:

It there's interest in adding this feature, I'd be happy to make the PR.
Context
See here and here for information about these two types of color-blindness. An estimated 1.01% of men and .02% of women have Red-Blind/Protanopia.",m1010j,CONTRIBUTOR,2018-09-01 02:56:49+00:00,True,2018-10-01 19:25:44+00:00,30.69,,2,1,2018-09-26 00:34:03+00:00,24.9,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1598,Jasmine html web page reports wrong line numbers,"Our project has a tests.html webpage which loads jasmine.js, jasmine-html.js, boot.js and our test suite. When a test fails, I get a stack trace with columns, line numbers and filenames. This is fine except that the line numbers are shifted: there is a difference between the line number as reported by Jasmine and the correct line number in the file.
My project uses webpack and cheap-eval-source-map.
Expected Behavior
Jasmine should report:
TypeError: Cannot read property 'getPeriodType' of undefined
    at <Jasmine>
    at SomeModel._someMethod (webpack-internal:///./js/SomeModel.js:106:18)

Current Behavior
Jasmine instead reports:
TypeError: Cannot read property 'getPeriodType' of undefined
    at <Jasmine>
    at SomeModel._someMethod (webpack-internal:///./js/SomeModel.js:112:18)

Note that line number (112) is not the same as expected one (106).
Your Environment

Version used: 3.2.0
Environment name and version: Chromium 68
Operating System and version: Linux desktop
Link to your project: private
Technology stack:

webpack: 4.3.0",DamienCassou,CONTRIBUTOR,2018-09-06 11:37:45+00:00,False,,,,2,4,2018-09-06 11:41:02+00:00,0.0,DamienCassou,CONTRIBUTOR,1,1,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1602,Angular 6.1.0 TypeError on is not a function,"Expected Behavior

TypeError on is not a function
Suite that reproduces the behavior (for bugs)

##Component
ngOnInit() {
    const that = this;
    if ( this._var === undefined ) {
      // Saved div with id for later click events
      this._var = document.getElementById('element');
    }
    this._var.on('plotly_click', function( event ) {
      that.customFunction( event );
    });
  }
##Test
  let component: CustomComponent;
  let fixture: ComponentFixture<CustomComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ CustomComponent]
    })
    .compileComponents();
  });

  beforeEach(() => {
     fixture = TestBed.createComponent(CustomComponent);
     component = fixture.componentInstance;
     fixture.detectChanges();
  });

  it('should create', () => {
     expect(component).toBeTruthy();
  });
Your Environment


Version used:
""jasmine-core"": ""~2.99.1"",
Environment name and version (e.g. Chrome 39, node.js 5.4):
Chrome: 68.0.3440.106
Operating System and version (desktop or mobile):
Desktop",theS3ns,NONE,2018-09-13 09:43:51+00:00,True,2018-09-26 00:39:34+00:00,12.62,,2,1,2018-09-26 00:39:34+00:00,12.62,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1603,Spy a method having multiple arguments and a callback,"When ever a method is having more than 1 argument I cant stub a method.
Expected Behavior


Current Behavior


Possible Solution


Suite that reproduces the behavior (for bugs)

Component
service.myMethod(reqBody,true, false, false, (success) => {

    },(failure)=>{

    });
test
const service = TestBed.get(Service);
spyOn(service, 'myMethod').and.callFake(function (reqBody, success,error) {
        return success({});
    });
It throws error ""success is not a function.""
spyOn(service, 'myMethod').and.callFake(function (reqBody,true,false,false, success,error) {
        return success({});
    });
It throws compilation error.
Context


Your Environment
""jasmine"": ""^2.99.0""",swayangjit,NONE,2018-09-13 17:38:16+00:00,True,2018-09-16 08:56:53+00:00,2.64,,2,2,2018-09-16 03:52:59+00:00,2.43,nitobuendia,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1604,"Disconnected, because no message in 10000 ms  :: using Jasmine.Clock and JQuery","I have a fairly complicated setup where my Angular 5 service uses JQuery to get a element from my document (this element is not part of the Angular app).  My service also uses a setTimeout in one of it's functions that's being unit tested.  In order to test it I need an element in the document that matches the selector in the function I'm testing
Expected Behavior
The browser should disconnect without error
Current Behavior
The test itself is reported as successful, it's just that I get the following after all tests run :

HeadlessChrome 69.0.3497 (Windows 10.0.0) ERROR
Disconnected, because no message in 10000 ms.

Possible Solution
I'm not sure but I think that the use of Jasmine.clock is causing the problem, it's not releasing the process.
Suite that reproduces the behavior (for bugs)
describe('AnalyticsService', () => {
  beforeAll(() => {
    document.body.innerHTML = '<div class=""metricspp""></div>';
    jasmine.clock().install();
  });

beforeEach(() => {
  TestBed.configureTestingModule({
    providers: [
      { provide: Router, useClass: MockRouter },
      { provide: ActivatedRoute, useClass: MockActivatedRoute },
      { provide: WindowRef, useValue: windowRefMock },
      { provide: LoggerService, useValue: MockLogger },
      AnalyticsService
    ]
  });
});

afterAll(() => {
  jasmine.clock().uninstall();
});

it('should be created', inject([AnalyticsService, LoggerService], (service: AnalyticsService, logger: LoggerService) => {
  jasmine.clock().tick(1);
  expect(service).toBeTruthy();
  expect(logger.log).toHaveBeenCalledWith('some stuff');
}));

});
Your Environment
Windows 10
Node: 9.5.0
Karma: 2.0.0
Jasmine: 2.99.0
Karma-Jquery plugin: 0.2.3
JQuery: 3.3.1
Using ChromeHeadless as the browser to run the tests in and I have version 69 of Chrome installed.
One  note is I run the tests in Chrome it runs fine but then again it's not really disconnecting and the test have always run successfully.",buddyackerman,NONE,2018-09-14 21:18:57+00:00,True,2018-09-18 20:45:35+00:00,3.98,,1,1,2018-09-18 20:45:35+00:00,3.98,buddyackerman,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1607,specStarted called even when a spec will not run and no way of knowing it will not run?,"I'm running test cases with Jasmine/Protractor. My issue is that I want some code to be executed before each spec in every spec-file. If I use beforeEach it means that I would have to have this setup-code called explicitly in every spec file. Instead I thought that I could add a reporter and use the specStarted and there add this generic setup/restore-code.
However, when I focus the test I'm currently working on with 'fit' the specStarted is still called for those test that are not focused (and that will not be run). The result metadata that's given to specStarted doesn't seem to include any information that could help my code identify that this spec will not be run (is not focused) so the setup-code can be skipped. If I explicitly exclude a spec (xit) I can check result.pendingReason and exit the function, but it doesn't help in the opposite case I have here...
Can't the result passed to specStarted include information whether a spec will be excluded or included in the current test run?",jensakejohansson,NONE,2018-09-19 09:15:19+00:00,True,2019-04-19 22:26:57+00:00,212.55,,2,4,2018-09-26 00:52:10+00:00,6.65,slackersoft,MEMBER,1,0,0,1,['Protractor'],False,False,False,True,False,False,False,False,False,False,False,False,False,False,False
1608,By init standalone have only one  string in trace,"jasmine/lib/jasmine-core/jasmine.js
    
    
         Line 517
      in
      6b9ae2d
    
    
    
    

        
          
           return trace.frames[2].file; 
        
    
  


Why trace.frames[2]?
If open default SpecRunner.html got here only trace.frames.length = 1",DK-2013,NONE,2018-09-21 15:15:50+00:00,True,2019-02-22 01:40:39+00:00,153.43,,2,2,2018-10-08 20:05:00+00:00,17.2,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1609,trigger afterAll on error,"I'm trying to write end-2-end tests using the Jasmine framework with selenium-webdriver,
my problem is that the browser doesn't close when an element not found.
PS: the code that closes the brower is in the afterAll function,
PS: I don't want to add .catch call at the end of it because I'm goint to have many its and I don't want to repeat it multiple times
this is my spec code:
const webdriver = require('selenium-webdriver');
const until = webdriver.until;

const capabilities = {
    ""browserName"": ""chrome"",
    ""platform"": ""any""
};
describe('my spec', function () {
    jasmine.DEFAULT_TIMEOUT_INTERVAL = 60000;
    waitTimeout = 20000;

    beforeAll(function (done) {
        this.driver = new webdriver
            .Builder()
            .usingServer(""http://127.0.0.1:4444/wd/hub"")
            .withCapabilities(capabilities)
            .build();
        this.driver.then(done);
    });

// --------- this function is not triggered if an element is not found
    afterAll(function (done) {
        this.driver.quit().then(done);
    });


    it('test name 1 should succeed', function (done) {

        this.driver.get(""http://127.0.0.1:8800"")

        // wait for element to be present
//--------- the element #packageAddressSearchHome is not present, so it should fail
            .then(_ => this.driver.wait(until.elementLocated(webdriver.By.css(""#packageAddressSearchHome"")), waitTimeout, ""the element #packageAddressSearchHome is not present""))
            .then(_ => this.driver.findElement(webdriver.By.css(""#packageAddressSearchHome"")))
            .then(element => {
                // wait for element to be displayed
                this.driver.wait(_ => element.isDisplayed(), waitTimeout, ""the element #packageAddressSearchHome is not visible"");
                // element is enabled
                this.driver.wait(_ => element.isEnabled(), waitTimeout, ""the element #packageAddressSearchHome is not enabled"");
                return element.sendKeys(""Paris"");
            })

            .then(done)
    });

});


PS: I'm new to jasmine-selenium-webdriver, so maybe the code I wrote is wrong
any idea how to fix it ? and thanks",tahayk,NONE,2018-09-26 11:31:25+00:00,True,2018-10-04 14:28:22+00:00,8.12,,2,2,2018-10-01 19:41:42+00:00,5.34,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1611,[Proposal] Request to add support for CI/CD pipelines for Test reporting,"Issue:
Currently Azure DevOps and Circle CI/CD systems provide rich test experience.
In order to get this experience/track test reporting, users has to explicitly generate test reports (currently supported format JUnit) by 3rd party plugins (Jasmine-Reporter) and publish test results.
Most of the popular open source projects aren't using 3rd party reporting plugins.
To keep local development experience and CI/CD build experience similar, scripts to build/test are written to print test results to console (std_out).
To get richer test experience in CI/CD pipeline, customers has to modify their scripts and often need to add 3rd party plugins.
This is a steep learning and test reporting is one of the important data that should be easily available for open source github projects.
Proposal for solution(s):
Generate test results file based on environment variables:
In this approach, test runners will generate test results file along with regular console output if an environment variable is set.
CI/CD pipelines can set this variable to desired test output location where they can automatically publish test results by consuming test results file generated by test runners (Mocha, Jasmine, Jest, Pytest).
This simple flag will make sure test runners are not going through any change in behavior in terms of execution or context they are running and users don't require go through any modification to their source/scripts.
Happy to listen to community feedback. Feel free to share other ideas if proposed solution is not feasible one.",nigurr,NONE,2018-10-15 06:03:44+00:00,True,2018-10-22 04:26:09+00:00,6.93,,2,2,2018-10-17 22:28:57+00:00,2.68,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1612,angularJS expectAsync does not function.,"Are you creating an issue in the correct repository?
I believe so 🐔
Expected Behavior
When using libraries that implement their own Promise API, Jasmine should be able to handle these Promises given they have the same methods as the global Promise.
Current Behavior
When attempting to use the expectAsync feature of jasmine ex.
await expectAsync($q.resolve('RESULT')).toBeResolvedTo('RESULT');
You will always receive the error ""Expected expectAsync to be called with a promise.""
This is because Jasmine pipes the passed promise to this isPromise method which checks that the promise has the global / window Promise constructor.
j$.isPromise = function(obj) {
  return typeof jasmineGlobal.Promise !== 'undefined' && obj && obj.constructor === jasmineGlobal.Promise;
};
This will return false because the angularJS implementation of Promise has a different constructor than the jasmineGlobal.Promise
Possible Solution
Some kind of isPromiseLike method should be implemented that checks to see that the object in question contains a resolve method.
Suite that reproduces the behavior (for bugs)

In angularJS the spec
describe(""resolving a $q promise"", function() {
  it('should be able to match the resolved value)', function() {
    return expectAsync($q.resolve('Hello')).toBeResolvedTo('Hello');
  });
});

Will fail because the angularJS deferred API does not have the same constructor as the global / browser Promise API.
});
Context
I am trying to write specs that can test the resolve of some promises. I noticed it wasn't quite working as expected and did a little debugging to figure out what was wrong.
I'm going to make a PR that will fix the issue, but I understand it's a hefty change and you might want me to make some changes. Just let me know 🎃.
Your Environment


Version used: 3.2.1
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome: 69
Operating System and version (desktop or mobile): OSX
Link to your project: Private Sorry",codymikol,CONTRIBUTOR,2018-10-18 19:42:30+00:00,True,2018-10-19 23:24:46+00:00,1.15,,2,1,2018-10-18 22:33:56+00:00,0.12,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1614,"Error: Expected [ 'Array', 'Contents' ] to be [ 'Array', 'Contents' ].","When comparing two arrays in my test framework expect(['Array', 'Contents']).toBe(['Array', 'Contents']); Jasmine reports an error in that Expected [ 'Array', 'Contents' ] to be [ 'Array', 'Contents' ].  Jasmine is truly mad about the fact that the address pointers for both of these arrays is not the same regardless of their contents. The first [ 'Array', 'Contents' ] is not the second [ 'Array', 'Contents' ]. While it isn't a huge deal, I would maybe expect some sort of error message explaining that.
Expected Behavior
I would expect some error message or some way of implying that the base address of my arrays is not the same and therefore they are not the same object.


Current Behavior
Right now jasmine reports Expected [ 'Array', 'Contents' ] to be [ 'Array', 'Contents' ]. 


Possible Solution
A new error message that tells me the base addresses of my arrays is not the same and they are not the same object because of that. Ideally, I think there could be something that suggests that I should use toEqual to compare the contents of my arrays instead, maybe if it notices their contents are similar.


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() { 
    expect(['Array', 'Contents']).toBe(['Array', 'Contents']);
});
Context


Again, this isn't a huge deal. Maybe I shouldn't assume the worst of people, but I feel like had I not been more informed and actually known what the issue was, this could have been a very frustrating error to come across. In every way, it looks like the first array should be the second array as reported by Jasmine, and I think it would be a frustrating experience to see something that looks like it should be working, but is still upset and wrong.",TheeRFG,NONE,2018-10-19 21:16:48+00:00,True,2018-10-22 17:59:16+00:00,2.86,,2,1,2018-10-19 23:15:49+00:00,0.08,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1617,Deprecated jasmineEnv configuration breaks plugins,"Expected Behavior
Since jasmine-core@3.3, configuration object is introduced to Env. Plugins like karma-jasmine, still uses the old style configuration.
Current Behavior
It prevents runners to run jasmine.
Possible Solution
Instead of deprecating it right away, a warning should suffice for the time being, to let plugin maintainers to migrate to the new configuration.
Environment
We're using karma, jasmine, and karma-jasmine to run tests.",nasvillanueva,NONE,2018-10-26 05:23:27+00:00,True,2018-10-26 17:12:29+00:00,0.49,,4,7,2018-10-26 05:31:56+00:00,0.01,nasvillanueva,NONE,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1618,bug: PrettyPrinter fails in IE11,"IE10 - IE11
do not support outerHTML or innerHTML property for SVG elements.
error
Unable to get property 'indexOf' of undefined or null reference
Code:

  
    
      jasmine/src/core/PrettyPrinter.js
    
    
        Lines 230 to 240
      in
      110c092
    
    
    
    

        
          
           PrettyPrinter.prototype.emitDomElement = function(el) { 
        

        
          
             var closingTag = '</' + el.tagName.toLowerCase() + '>'; 
        

        
          
            
        

        
          
             if (el.innerHTML === '') { 
        

        
          
               this.append(el.outerHTML.replace(closingTag, '')); 
        

        
          
             } else { 
        

        
          
               var tagEnd = el.outerHTML.indexOf('>'); 
        

        
          
               this.append(el.outerHTML.substring(0, tagEnd + 1)); 
        

        
          
               this.append('...' + closingTag); 
        

        
          
             } 
        

        
          
           }; 
        
    
  


Work around could be that we create 'div' element and clone that node there and read divs innerHTML.",Havunen,CONTRIBUTOR,2018-10-29 08:10:52+00:00,True,2018-12-04 01:45:54+00:00,35.73,,3,2,2018-10-31 17:52:47+00:00,2.4,mdomi,NONE,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1619,afterAll not working with fit,"if  test contains afterAll() and fit(), then afterAll is ignored.
Probably same problem will have afterEach()",rebajz,NONE,2018-10-29 20:48:29+00:00,True,2019-02-22 01:44:28+00:00,115.21,,2,2,2018-11-02 18:46:52+00:00,3.92,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1620,Jasmine cancels callback execution when unsubscribe is called,"I've created this stackblitz to representate the bug:
https://stackblitz.com/edit/jasmine-testing-r6bpfh
To execute the code in normal mode you must change the TEST variable to false in main.ts and reload the live preview window. You can click on button and then in 'yes' or 'no'. You can see how the 'dialogIsOpen' variable is being changed from false, to true and then again to false, because the callback function is fully being executed.
In test mode (set TEST variable to true and reload the preview window) the test fails because the callback function execution is being cancelled on unsubscribe call.
Expected Behavior
Continue the execution of the current callback in test.
Current Behavior
The callback execution is being cancelled after calling unsubscribe.
Possible Solution
Suite that reproduces the behavior (for bugs)
https://stackblitz.com/edit/jasmine-testing-r6bpfh
Context
I can't test callbacks with unsubscribe methods.
Your Environment

Version used: 3.1.0
Environment: Chrome  70.0.3538.67 32 bits
Operating System and version (desktop or mobile): Windows 10",kno,NONE,2018-10-30 09:18:33+00:00,True,2019-02-22 01:49:03+00:00,114.69,,2,4,2018-11-02 18:42:22+00:00,3.39,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1622,Stuck in infinite loop after test run,"Current Behavior
Updated jasmine from 3.2.0 to 3.3.0 and the tests are stuck in an infinite loop after they pass successfully. The hang appears to be coming from the function processImmediate() in <node_internals>/timers.js.
Context
The tests just hang.
Your Environment

Version used: 3.3.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Electron 3.0.4
Operating System and version (desktop or mobile): Windows 10",kht2018,NONE,2018-11-07 23:09:25+00:00,True,2018-12-04 01:40:10+00:00,26.1,,1,1,2018-11-08 00:34:26+00:00,0.06,kht2018,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1623,$j.isError_ incorrectly assumes function with WebSocket event,"Expected Behavior
Should conclude that incoming value is not an Error.
Current Behavior
Tries to invoke a string as a function, which fails with ""Function expected"".
Possible Solution
This if-statement in j$.isError
    if (value && value.constructor && value.constructor.constructor &&
      (value instanceof (value.constructor.constructor('return this')()).Error)) {
      return true;
    }
assumes that value.constructor.constructor('return this') evaluates to a function (and calls it). This is not always the case. I have a combination of Jasmine, Karma, Typesript, RxJs and WebSocket (puh!) where the incoming value parameter is a WebSocket open event.
In IE the expression value.constructor.constructor evaluates to Object where in Chrome it evaluates to Function. Calling that with the argument 'return this' creates a string object in IE but a function that returns a string in Chrome.
We are using this override now, that has a more defensive approach:
jasmine.isError_ = function (value) {
    if (value instanceof Error) {
        return true;
    }
    if (value && value.constructor && value.constructor.constructor) {
        var vccTarget = value.constructor.constructor('return this');
        if (typeof vccTarget === 'function') {
            vccTarget = vccTarget();
        }
        if (vccTarget.Error && (value instanceof vccTarget.Error)) {
            return true;
        }
    }
    return false;
};
Your Environment

Version used: 3.1.0
Environment name and version: IE11
Operating System and version: Windows 7 x64
Link to your project: Commercial",peter-backlund-sg,NONE,2018-11-08 11:44:57+00:00,True,2019-04-02 01:53:09+00:00,144.59,,3,2,2018-12-04 01:52:28+00:00,25.59,slackersoft,MEMBER,1,0,0,1,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1624,TypeError when use jasmine^3.0 ,"I get error messages when use jasmine^3.0 to run sample code(src/Player.js and src/Song.js),
but jasmine works well when I use jasmine 2.99.

The browser information (the browser version is older since I use Qt4.8 webkit to implement) :


Expected Behavior",ShengYenPeng,NONE,2018-11-14 02:03:12+00:00,True,2018-12-18 01:54:35+00:00,33.99,,2,3,2018-12-06 00:14:58+00:00,21.92,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1625,Add a `toBeRejectedWithError` async matcher,"Expected Behavior
I want to test to use the toThrowError utility matcher on an asynchronous operation which rejects with a given error.
Current Behavior
API is not available - but eq and objectContaining works as interim solutions.
await expectAsync(boom()).toBeRejectedWith(new TypeError(""BOOM""))
await expectAsync(boom()).toBeRejectedWith(jasmine.objectContaining({ message: ""BOOM"" }))

Possible Solution
Jasmine already has toThrowError besides toThrow to make it easier matching against errors with various overloads.
expect(foo).toThrowError(""foo bar baz"");
expect(foo).toThrowError(/bar/);
expect(foo).toThrowError(TypeError);
expect(foo).toThrowError(TypeError, ""foo bar baz"");

Having toBeRejectedWithError besides toBeRejectedWith with the same overloads would be quite intuitive.
It seems that would require extracting some code from toThrowError first.
I wonder whether that extracted code could live in a jasmine.error asymmetric matcher instead though (meaning that ultimately toThrowError could be deprecated).",sirlantis,NONE,2018-11-19 13:00:40+00:00,True,2019-05-03 23:36:55+00:00,165.44,,3,3,2018-11-19 13:38:31+00:00,0.03,sirlantis,NONE,1,0,0,2,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1626,Test fails when NGRX action contains observable,"Expected Behavior
Test based on NGRX should pass when an Action contains observable.
Current Behavior
When testing effects and the expected observable contains action That contains another observable jasmine throws:
Expected $[2].notification.value.payload.commands[0].active._subscribe = Function to equal Function.
Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
it('should not crash', () => {
  
      const expectedStream$ = cold('--b', {b: new successAction(Observable.of(true))});

        // Act
        actions$ = hot('--a', {a: new MyAction()});

        // Assert
        expect(effects.MyEffect$).toBeObservable(expectedStream$);
});
});
Context
I have an ngrx effect that throws Action containing an observable.
When I'm testing the effect I get: 'Expected $[2].notification.value.payload.commands[0].active._subscribe = Function to equal Function.`
Your Environment

Node: 9
Chrome: 70
Jasmine: 3.3.0",TKul6,NONE,2018-11-29 10:21:39+00:00,False,,,,3,3,2018-12-06 01:25:22+00:00,6.63,slackersoft,MEMBER,1,0,0,2,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1627,"SpyObj typings, only functions should be treated as spies","Expected Behavior


interface Service {
  test();
  count: number;
}

let serviceSpy: jasmine.SpyObj<Service>;
serviceSpy.count = 1; // should work
Current Behavior


let serviceSpy: jasmine.SpyObj<Service>;
serviceSpy.count = 1; // Type '1' is not assignable to type 'number & Spy' 
Possible Solution


It is possible to use conditional types and only add & Spy if property type is a function. It requires typescript 2.8 though.
At the same time maybe all properties should also be marked as writable using -readonly switch for easier and safer tests?
I am interested in making a PR as well
Suite that reproduces the behavior (for bugs)
https://stackblitz.com/edit/jasmine-xkyr6n?file=src/identity.spec.ts",FDIM,NONE,2018-11-29 14:05:06+00:00,True,2018-12-01 13:40:18+00:00,1.98,,1,1,2018-12-01 13:40:18+00:00,1.98,FDIM,NONE,0,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1628,Unclear deprecation messages,"The deprecation messages issued when using the default configuration generated by jasmine init does not explain any remediation.
Expected Behavior
When installing Jasmine and generating a config using jasmine init it should use up to date configuration syntax. The error message thrown when deprecated keys could be updated to explain what the newer keys or syntax is. The current message seems to imply one should use a configuration object and tuck these new key/values inside. However I've tried various combinations in my jasmine.json file to control test randomization, for eg. and nothing seems to work. Here's one example:
{
  ""spec_dir"": ""spec"",
  ""spec_files"": [
    ""**/*[sS]pec.js""
  ],
  ""helpers"": [
    ""helpers/**/*.js""
  ],
  ""oneFailurePerSpec"": true,
  ""config"": {
    ""random"": false
  }
}

When running with this I still see messages like Randomized with seed 70099 which, I believe, indication randomization is still happening. When I set ""random"": false directly the Randomized with seed message goes away but I get a deprecation warning. I've checked online docs and briefly looked through the commit which adds the new feature but I can't figure out the recommended syntaxt for configuring these values. Do they now belong under a configure subkey? Is there a separate file?",cliff76,NONE,2018-12-05 20:51:11+00:00,True,2019-05-08 00:10:17+00:00,153.14,,3,4,2018-12-06 00:44:17+00:00,0.16,slackersoft,MEMBER,1,0,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1629,"""fit"" and ""fdescribe"" still show output of not running tests (not related to karma)","Are you creating an issue in the correct repository?
Yes

Expected Behavior
When I run a test with fit or a suite of tests with fdescribe I expect the test output to only show the results of the run tests.
Current Behavior
I see all my other tests as if they have passed which obscures the results that I have narrowed in on with fdescribe/fit
Suite that reproduces the behavior (for bugs)

This is my run.js which is launched when I execute npm test
import Jasmine from 'jasmine'
import reporters from 'jasmine-reporters'

const jasmine = new Jasmine()
jasmine.loadConfigFile('spec/support/jasmine.json')

const junitReporter = new reporters.JUnitXmlReporter({
  savePath: 'shippable/testresults',
  consolidateAll: true
})

jasmine.addReporter(junitReporter)

const terminalReporter = new reporters.TerminalReporter({
  verbosity: 3,
  color: true,
})

jasmine.addReporter(terminalReporter)

const files = process.argv
  .slice(2)
  .map(item => {
    if (!item.endsWith('.js')) {
      return `${item}.js`
    }

    return item
  })

jasmine.execute(files)

Context


Your Environment
node v10.10
jasmine: ^3.2.0,
jasmine-reporters"": ^2.3.2,",jjm340,NONE,2018-12-06 08:05:18+00:00,False,,,,2,1,2018-12-07 01:47:51+00:00,0.74,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1630,"spyOn(myService, ""gettest1"").and.callThrough(); promise is not resolving get status like 0","Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Trying to get API data from controller. It works fine in controller. Once i used callThrough(). testcase pases but  Api was not resolving. It shows status 0
Expected Behavior


Expecting to get data from ApI as response. Below is tried code.
spyOn(myService, ""gettest1"").and.callThrough();
it('getDateRangeData return Data obj', function() {
var tee = myService.gettest1();
var tee1 = myService.gettest1().then(function(response) {
  console.log('Success', response);
}, function() {
  console.log(""error on chart list"");

})
}
can any one help me resolve promise?
Also tried  ""scope.$apply();"" it gives an error Unexpected request: GET https://jsonplaceholder.typicode.com/todos/1
No more request expected
Current Behavior


Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context


Your Environment


Version used:
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:",Ajaykumarkonda,NONE,2018-12-06 12:27:20+00:00,True,2018-12-07 01:40:58+00:00,0.55,,2,1,2018-12-07 01:40:58+00:00,0.55,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1631,Add warning and resolution for OOM by result tracking,"Let's look at the following spec:
const spec = it('should not run out of memory',
  () => new Promise( (resolve,reject) => {
    let i=0
  
    setInterval( () => { // <- keep test from freezing up
      const t0 = performance.now()
      do {
        if( 0 === i%1e6 )
          console.log( i.toString().padStart(12) )
        expect(i).toBeGreaterThan(-1)
        ++i
      }
      while( (performance.now() - t0) < 500 )
    }, 0)
  }
))
The spec is asynchronous merely to prevent the browser from freezing up using karma-jasmine. The stopping condition was removed to simplify the example. Note that You are going to have to increase the timeout durations to reproduce the results.
You - as developers and/or seasoned users of Jasmine - may already know what happens when this spec is executed: Chrome runs out of memory at around 2gb at i = 31*106, the browser tab crashes and the test fails silently, i.e. no warnings or errors are logged to the console.
The cause for the memory ""leak"" is likely that Jasmine creates a result object for every single expectation that passed. This hypothesis is based on the fact that monkey-patching Spec::addExpectationResult fixes the memory ""leak"":
spec.addExpectationResult = (pass, ...args) => {
  if( ! pass )
    Object.getPrototypeOf(spec).addExpectationResult.call(spec, pass, ...args)
}
For someone like me, who's new to Jasmine however, this memory ""leak"" is terribly confusing. I realize that this is not an actual leak since keeping track of passed results is intended. The out-of-memory error without feedback however is likely not intentional.
Which brings me to the following suggestions:

Could a warning be emitted when Spec::result.passedExpectations exceeds a threshold, say 106?
Ideally said warning would point to a setting that allows one to drop passed expectations from the spec. In my experiments, specs ran just fine with the monkey patch above.

Environment
Involved:

node@v10.14.1
karma-jasmine@2.0.1
jasmine-core@3.3.0

Likely not involved:

karma-webpack@3.0.5
karma-spec-reporter@0.0.32
karma-chrome-launcher@2.2.0

OS: Ubuntu 18.04 64x
Browser: Chrome 71.0.3578",DirkToewe,NONE,2018-12-09 19:47:32+00:00,False,,,,2,3,2019-02-27 20:52:51+00:00,80.05,slackersoft,MEMBER,1,0,0,1,"['help needed', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,False,False,False,True
1633,Feature Request: Detect duplicate test names,"Expected Behaviour
It would be nice if Jasmine could be configured to detect and warn/fail when duplicate fully qualified test names are found.  This is similar to Issue #747, but asking for a config option to enable the behaviour.
Alternatively, the list of fully qualified test names could be returned to the Reporter in JasmineStartedInfo and the Reporter could choose to detect duplicates itself.
Current Behaviour
Duplicate test aren't detected.
Possible Solution
See expected behaviour.",paulmedynski,NONE,2018-12-11 13:44:49+00:00,False,,,,4,9,2018-12-12 01:28:20+00:00,0.49,slackersoft,MEMBER,1,1,0,2,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1634,Feature request: Include (custom) expectation message in both passed and failed expectations,"I appreciate this is something of a duplicate of #1127, but the response there of ""Jasmine doesn't expect you to really print messages for expectations that were met"" doesn't really help.
I'm guessing that many users like me will have tests that produce multiple expectations. Some might argue this is not good practice - and they may have a point - but the fact is, that's what many people will do. Furthermore, sometimes these varied expectations can include somewhat ""dynamically"" generated actual / expected values - it would be massively beneficial to be able to see the actual values used in the successfully executed expectation.
Beyond this, it would be useful to have a custom message for reporting purposes. A stream of ""Passed. Passed. Passed. Passed."" is meaningless to interested parties. Something that says ""Passed - found 3 doughnuts left after having 4 before that, because we ate one"" would be far more useful / meaningful.
Clearly a number of users have looked into what would be required to support this sort of thing. Can we revisit this as an idea? If someone submitted a PR that offered it, would the PR immediately be rejected?",GCHQDeveloper911,NONE,2018-12-12 08:52:58+00:00,False,,,,2,7,2018-12-14 01:55:22+00:00,1.71,slackersoft,MEMBER,1,0,0,1,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1635,"Feature request: Report all failed expectations, not just first.","If I have a test:
describe('my suite', () => {
it ('tests something', () => {
expect(1).toEqual(2);
expect(2).toEqual(3);
console.log('oh dear');
})
})
Then obviously this fails - but only the ""1=2"" expectation is reported. It would be good to see all failed expectations. The test IS running through, because I see my log output.",GCHQDeveloper911,NONE,2018-12-12 10:01:27+00:00,True,2018-12-13 09:45:16+00:00,0.99,,2,2,2018-12-13 09:45:16+00:00,0.99,GCHQDeveloper911,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1636,Help finding a sponsor for learning materials,"Hello! I know, I know, this is not an issue or a bug! It is just a question and I hope you can point me in the right direction here.
TL;DR: I created an awesome course (with the help of @ReyPena) on Jasmine that has paid students from 50+ countries and I want to make it available for free but I need a sponsor.
Hi! I am Juan Lizarazo 👋 , author of ""The unit testing your Javascript with Jasmine"" course at Udemy.

I wanted to create the best resource online where people could learn jasmine quick and get solid foundations but I never it expect it to become the highest rated course in Jasmine in the platform with students from 50+ countries. Nothing like spreading the jasmine love ❤️ !
So, I want to make the course free, available for everyone, forever so more people from developing countries can have access to it and can learn how to use the framework, but in order to do, I just need to recoup my production costs.
I need some guidance on whom I can contact to get a sponsor, I'd like to make the course free sooner rather than later as I could just wait 6 months to one year and then do so.
Is this something pivotal labs or the jasmine project would be interested in doing?",juanlizarazo,NONE,2018-12-14 04:35:15+00:00,True,2019-04-19 22:43:25+00:00,126.76,,2,1,2019-02-12 00:13:40+00:00,59.82,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1637,How to test router.events with jasime test framework,"I want to write a unit test for following typescript class which has two private methods
`export class BreadcrumbsComponent extends BaseComponent {
breadcrumbs: MenuItem[];
homeBreadcrumb: MenuItem;
navigationDepth: number;
router: Router;
activatedRoute: ActivatedRoute;
constructor(router: Router, activatedRoute: ActivatedRoute) {
super();
this.router = router;
this.activatedRoute = activatedRoute;
this.initBreadcrumbs();
this.router.events.pipe(
    filter(event => event instanceof NavigationEnd)
  ).subscribe(event => {  
  this.initBreadcrumbs();
  const root: ActivatedRoute = this.activatedRoute.root;
  this.getBreadcrumbs(root);
  }
);
this.homeBreadcrumb = {
  icon: 'icon home',
  title: 'OWEO dashboard',
  label: 'OWEO dashboard',
  routerLink: 'dashboard'
};

}
private initBreadcrumbs() {
// first private method
}
private getBreadcrumbs(route: ActivatedRoute, url = '') {
// second private method
}
}`
I want to write unit test using jasmine for the two private methods of this class.",krishna1990fis,NONE,2018-12-17 06:22:18+00:00,True,2019-01-10 01:23:36+00:00,23.79,,2,1,2019-01-10 01:23:36+00:00,23.79,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1639,Assert local variable of a function,"Jasmine: 3.3.0
Current Project: Develop electron application (with angular 7).
How do I use Jasmine to assert the value of arg, which is a local variable of onSubmit function? or is it even possible in the first place?
onSubmit() {
    .... (omit for brevity)
    let startId = this.formData.startId 
    let numOfID = this.formData.numOfId
    let idType = this.formData.idType
   
     **let arg = {idType: idType, startId:parseInt(startId),  numOfID:parseInt(numOfID)}**
    this._electronService.ipcRenderer.send(""generateID"",arg)
}",hanct,NONE,2018-12-19 00:55:51+00:00,True,2019-04-19 22:39:28+00:00,121.91,,2,2,2018-12-21 01:26:39+00:00,2.02,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1640,Support  for custom systemic features ('plugins'),"Our users love the jasmine testing  API, so they adapt jasmine to cases it may not have been designed for.  They call non-API jasmine functions and these break when we update them. Maybe more of these cases could be fixed with 'plugin' support?
Some of the use cases:

Require it() functions to be async (to avoid errors when promises are used in tests).
Require it() functions to be synchronous (because the system ensures synchrony).
Add an afterEach to every suite to ensure environment cleanup (avoid errors from mismatched before/after operations)
Add an afterEach to every suite to record the state of the test env (browser screenshots).

The general flavor of these hacks is to operate on the suite or spec list after user code creates the list but before it is passed into the jasmine queue.  Unlike beforeEach/afterEach, these changes are systemic and not context dependent.  Typically they are implemented by wrapping the globals describe or afterEach and calling the wrapped functions.",johnjbarton,CONTRIBUTOR,2018-12-21 17:16:56+00:00,False,,,,2,3,2019-01-10 01:22:49+00:00,19.34,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1641,"Jasmine ""Expect spy ... to have called"" errors not readable","This message all on one-line is unreadable:
Expected spy next to have been called with [ Object({ subject: [ 'serviceu', 'more-serviceu' ], type: [ 'shyan-the-cat', 'lovely', 'beautfiul', 'hero' ], profile: [ 'human', 'annoying', 'notsogood' ] }) ] but actual calls were [ Object({ subject: [ 'serviceu', 'more-serviceu' ], profile: [ 'human', 'annoying', 'notsogood' ], type: [ 'shyan-the-cat', 'lovely', 'beautiful', 'hero' ] }) ]

The error here is a small typo in a single string but it takes ages to track down. For the same scenario mocha shows a lovely object diff which makes the issue immediately clear.",ohjames,NONE,2018-12-31 15:06:05+00:00,False,,,,2,1,2019-01-10 01:44:01+00:00,9.44,slackersoft,MEMBER,1,0,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1642,Inexisting error,"I cannot understand where is the issue, because other action (without any parameters) does not throw an error

Expected spy dispatch to have been called with [ LoginAction({ payload: ApiCredentialsModel({ username: 'denis', password: 'mockpassword' }), type: '[Auth] Login' }) ] but actual calls were [ LoginAction({ payload: ApiCredentialsModel({ username: 'denis', password: 'mockpassword' }), type: '[Auth] Login' }) ].

Expected Behavior
There should be no error
Current Behavior
Fail instead of Success
Your Environment
Angular 7",DenisSemionov,NONE,2019-01-02 08:33:48+00:00,True,2019-04-19 22:40:30+00:00,107.59,,2,2,2019-01-10 01:29:42+00:00,7.71,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1643,Test suite execution and reporting order,"Hi, I have two jasmine test suites in separate files that I'm running on node in conjunction with karma and reporting using karma-mocha-reporter.
I have  random: false. Each suite (A & B) runs five async tests in sequence and then completes.
When I run the suites separately the tests run sequentially and complete as expected. With both suites enabled I get one of two outcomes on each test run:
Outcome #1 (good)
START:
IDBCache Timeout Tests
√ A1. Create entries
√ A2. Read data back
√ A3. Sleep...
√ A4. Confirm entries have timed out
√ A5. Flush table
IDBCache Tests
√ B1. Create cache instance
√ B2. Read data back
√ B3. Count Keys
√ B4. Delete cache entry
√ B5. Clear cache
** Outcome #2 (puzzling)**
START:
IDBCache Timeout Tests
√ A3. Sleep...
√ A4. Confirm entries have timed out
√ A5. Flush table
IDBCache Tests
√ B1. Create cache instance
√ B2. Read data back
√ B3. Count Keys
√ B4. Delete cache entry
√ B5. Clear cache
√ A1. Create entries
√ A2. Read data back
In outcome #2 the reports for tests A1 & A2 are appended to the end of the report for suite B.
The A3 test is a simple delay between tests A2 and A4:
  it(""A3. Sleep..."", async (done) => {
    await sleep(2100);
    done();
  }, 3000);

I'm no sure how to investigate/resolve this.  Is it a problem with karma, jasmine or karma-mocha-reporter? Any suggestions would be very welcome.
Cheers.",stevej2608,NONE,2019-01-03 13:41:27+00:00,False,,,,2,1,2019-01-31 01:44:37+00:00,27.5,slackersoft,MEMBER,1,0,0,0,['Karma'],False,False,False,False,True,False,False,False,False,False,False,False,False,False,False
1646,Report duration of each spec,"In larger test suites or systems, test time becomes an issue. Understanding whether the issue is say lots of time in one test or too many tests, a record of the duration of each test would be very helpful.
Expected Behavior
The test report includes testDuration for each spec.
Current Behavior
No duration report.
Possible Solution
Just before execution it(), store performance.now().
Just after, compute the delta between the performance.now() and the stored value.
Add the result to the specDone reporter callback result as testDuration",johnjbarton,CONTRIBUTOR,2019-01-11 22:52:45+00:00,True,2019-03-15 02:12:50+00:00,62.14,,3,4,2019-01-31 01:33:51+00:00,19.11,slackersoft,MEMBER,1,1,0,1,"['help needed', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,False,False,False,True
1647,Getting the current test name in jasmine,"as of jasmine 2.0 jasmine.getEnv().currentSpec no longer works, is there any way of getting the test name without doing
var spec = it('test', function()  {
    //
});",karanjitsingh,NONE,2019-01-26 20:39:35+00:00,True,2019-01-30 05:52:46+00:00,3.38,,2,2,2019-01-30 01:47:46+00:00,3.21,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1648,spyOn() breaks Jasmine with when returning rejected Promise,"When using this pattern in a spec
spyOn(foo, 'bar').and.returnValue(Promise.reject('NO!'));
the entire test run fails even if the spied function never gets called.
This is similar to #1590, but different enough that I thought it warranted a separate item (in my case my spy creates correctly). Feel free to close this if you think it is too similar.
Expected Behavior
The test run should pass because both the spec and tested code do not actually throw any exceptions or await on rejected Promises.
Current Behavior
The spec succeeds but the test run fails (the Node.js process exits with code 1). When I use jasmine-console-reporter module it reports An error was thrown in an afterAll.
Suite that reproduces the behavior
Here is the complete test file. Notice that the spied function is in a branch that cannot get called:

const foo = {
    bar: async () => 0
}

const baz = {
    quux: async () => {
        if (false) {
            await foo.bar();
        }
    }
};

describe('some suite', () => {
    it('some spec', async () => {
        const spy = spyOn(foo, 'bar').and.returnValue(Promise.reject('NO!'));
        await baz.quux();
        expect(spy).not.toHaveBeenCalled();
    });
});
Context
We have a test where we need to verify that one code path isn't taken given some conditions. To make the test fail in a controlled manner, we added a spy with this rejected Promise pattern if the tests hits this undesired code path.
Your Environment


jasmine: v3.3.1
jasmine-core: v3.3.0
Environment: Node.js v8.15.0
OS: macOS Mojave, Version 10.14.3 18D42",pe8ter,NONE,2019-02-07 19:27:05+00:00,True,2019-02-14 05:12:02+00:00,6.41,,2,3,2019-02-11 19:15:34+00:00,3.99,sgravrock,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1649,"Failing with unexpected reason: ""Error: "" and ""Failed: ""","Expected Behavior
Tests must pass with the latest version of jasmine.
Current Behavior
When I run tests using jamine v3.3.1, they fail with a weird message while they are passing with jasmine v2.9.0.
  Message:
    Error: I don't like fat bodies
  Stack:
    Error: I don't like fat bodies
        at EventEmitter.muneem.setFatBodyHandler (/home/amit/git/muneem/tests/fatBody_test.js:32:11)
        at EventEmitter.emit (events.js:182:13)
        at Object.router.on [as handler] (/home/amit/git/muneem/src/routesManager.js:104:31)
        at Anumargak.lookup (/home/amit/git/muneem/node_modules/anumargak/src/letsRoute.js:404:20)
        at Server.httpHandler (/home/amit/git/muneem/src/server.js:87:32)
        at Server.emit (events.js:182:13)
        at parserOnIncoming (_http_server.js:652:12)
        at HTTPParser.parserOnHeadersComplete (_http_common.js:109:17)
  Message:
    Failed: I don't like fat bodies
  Stack:
    Error: I don't like fat bodies
        at EventEmitter.muneem.setFatBodyHandler (/home/amit/git/muneem/tests/fatBody_test.js:32:11)
        at EventEmitter.emit (events.js:182:13)
        at Object.router.on [as handler] (/home/amit/git/muneem/src/routesManager.js:104:31)
        at Anumargak.lookup (/home/amit/git/muneem/node_modules/anumargak/src/letsRoute.js:404:20)
        at Server.httpHandler (/home/amit/git/muneem/src/server.js:87:32)
        at Server.emit (events.js:182:13)
        at parserOnIncoming (_http_server.js:652:12)
        at HTTPParser.parserOnHeadersComplete (_http_common.js:109:17)
What I'm testing
I'm running the server and throwing an error. I'm handling that error on server and responding with 500 status in this case.
it('should 500 on big body.', (done) => {
        chai.request(""http://localhost:3006"")
            .post('/small')
            .send(""This is really big body than expected"")
            .then(res => {
                expect(res.status).toBe(500);
                expect(res.text).toBe("""");
                done();
            }).catch( err => {
                done.fail(""not expected "" + err);
            });
    });
I can check that done is being called properly and the test must be passing. But instead, it fails with the error that I'm throwing in my code.
Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context
I'm updating dependencies and re-running tests to verify if everything is working fine.
Your Environment


Version used: 3.3.1
Environment name and version (e.g. Chrome 39, node.js 5.4): node.js 10.10.0
Operating System and version (desktop or mobile): Ubuntu 17.10
Link to your project: https://github.com/node-muneem/muneem/",amitguptagwl,NONE,2019-02-10 04:39:24+00:00,True,2019-02-15 01:50:39+00:00,4.88,,2,2,2019-02-14 19:25:56+00:00,4.62,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1650,"[Feature] Use ""skip"" / ""todo""","Jest 24 introduced the possibility to mark tests as ""todo"" / ""to be skipped"" (see facebook/jest#1605). This is very helpful in situations where

a test is to be fixed later on
when laying out all test cases before actually implementing them

I'd love to see such a functionality in Jasmine as well!",dominique-mueller,NONE,2019-02-11 12:43:08+00:00,False,,,,2,1,2019-02-11 17:37:30+00:00,0.2,slackersoft,MEMBER,1,0,0,0,['waiting'],True,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1651,Support nodejs experimental-modules,"Are you creating an issue in the correct repository?
The ""bug"" (unwanted feature) is at jasmine.js#89.5
Expected Behavior
We should be able to use the ""ecmascript"" experimental modules of nodejs (https://nodejs.org/dist/latest-v11.x/docs/api/esm.html),
Current Behavior
we receive an error:

Error [ERR_REQUIRE_ESM]: Must use import to load ES Module: /mnt/c/Users/jhn/src/kiosk/tests/server/basic-test.mjs
at Object.Module._extensions..mjs (internal/modules/cjs/loader.js:724:11)
at Module.load (internal/modules/cjs/loader.js:599:32)
at tryModuleLoad (internal/modules/cjs/loader.js:538:12)
at Function.Module._load (internal/modules/cjs/loader.js:530:3)
at Module.require (internal/modules/cjs/loader.js:637:17)
at require (internal/modules/cjs/helpers.js:22:18)
at /mnt/c/Users/jhn/src/kiosk/node_modules/jasmine/lib/jasmine.js:89:5
at Array.forEach ()
at Jasmine.loadSpecs (/mnt/c/Users/jhn/src/kiosk/node_modules/jasmine/lib/jasmine.js:88:18)
at Jasmine.execute (/mnt/c/Users/jhn/src/kiosk/node_modules/jasmine/lib/jasmine.js:257:8)

Possible Solution
Jasmine should use ""import"" instead of ""require"" when loading esm modules. But that is not that easy, since ""import"" is asynchronous, while require is synchronous.
Suite that reproduces the behavior (for bugs)

Create a .jsm file (can be any test, even a simple one)
launch nearly as usual:

node --experimental-modules node_modules/.bin/jasmine

Context
This is blocking to use jasmine in this new (experimental) context.
Your Environment


Version used: 3.3.1
Environment name and version (e.g. Chrome 39, node.js 5.4): nodejs v10.15.1
Operating System and version (desktop or mobile): ubuntu
Link to your project:",jehon,NONE,2019-02-12 11:13:36+00:00,False,,,,2,2,2019-02-12 11:45:19+00:00,0.02,jehon,NONE,0,0,0,1,['has pr'],False,False,True,False,False,False,False,False,False,False,False,False,False,False,False
1652,After updating jasmine from jasmine 2.4.0 to jasmine 3.3.0 I am getting some error,"After updating jasmine from jasmine 2.4.0 to jasmine 3.3.0 I am getting some error. The bellow error comes after when my all specs run completely. Also, because of the upgradation I am getting more jasmine failures.
2019-02-15 11:36:19 +0530: Rack app error handling request { POST / }
#<RuntimeError: can't add a new key into hash during iteration>
/home/aniketshivamtiwari/.rvm/rubies/ruby-2.5.3/lib/ruby/2.5.0/set.rb:189:in replace' /home/aniketshivamtiwari/.rvm/rubies/ruby-2.5.3/lib/ruby/2.5.0/set.rb:189:in replace'
/home/aniketshivamtiwari/.rvm/rubies/ruby-2.5.3/lib/ruby/2.5.0/set.rb:405:in collect!' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/sprockets-3.7.2/lib/sprockets/loader.rb:85:in asset_from_cache'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/sprockets-3.7.2/lib/sprockets/loader.rb:35:in load' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/sprockets-3.7.2/lib/sprockets/cached_environment.rb:20:in block in initialize'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/sprockets-3.7.2/lib/sprockets/cached_environment.rb:47:in load' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/sprockets-3.7.2/lib/sprockets/legacy.rb:195:in block in to_a'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/sprockets-3.7.2/lib/sprockets/legacy.rb:195:in map' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/sprockets-3.7.2/lib/sprockets/legacy.rb:195:in to_a'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/asset_expander.rb:39:in get_javascript_assets' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/asset_expander.rb:25:in assets'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/asset_expander.rb:6:in expand' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/asset_pipeline_mapper.rb:11:in call'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/asset_pipeline_mapper.rb:11:in block in map_src_paths' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/asset_pipeline_mapper.rb:10:in map'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/asset_pipeline_mapper.rb:10:in map_src_paths' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/configuration.rb:108:in block in map'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/configuration.rb:106:in each' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/configuration.rb:106:in inject'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/configuration.rb:106:in map' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/configuration.rb:59:in js_files'
(erb):11:in block in render' /home/aniketshivamtiwari/.rvm/rubies/ruby-2.5.3/lib/ruby/2.5.0/erb.rb:876:in eval'
/home/aniketshivamtiwari/.rvm/rubies/ruby-2.5.3/lib/ruby/2.5.0/erb.rb:876:in result' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/jasmine/page.rb:8:in render'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/rack/jasmine/runner.rb:15:in call' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/cascade.rb:33:in block in call'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/cascade.rb:24:in each' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/cascade.rb:24:in call'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/urlmap.rb:68:in block in call' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/urlmap.rb:53:in each'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/urlmap.rb:53:in call' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/jasmine-3.3.0/lib/rack/jasmine/cache_control.rb:10:in call'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/head.rb:12:in call' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/rack-2.0.6/lib/rack/builder.rb:153:in call'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/puma-3.12.0/lib/puma/configuration.rb:225:in call' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/puma-3.12.0/lib/puma/server.rb:658:in handle_request'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/puma-3.12.0/lib/puma/server.rb:472:in process_client' /home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/puma-3.12.0/lib/puma/server.rb:332:in block in run'
/home/aniketshivamtiwari/.rvm/gems/ruby-2.5.3@rails5-portal/gems/puma-3.12.0/lib/puma/thread_pool.rb:133:in `block in spawn_thread'
My configuration
Rails- 5.2.2
ruby - 2.5.3
jasmine (3.3.0)
jasmine-core (~> 3.3.0)
phantomjs
rack (>= 1.2.1)
rake
jasmine-core (3.3.0)
jasmine-jquery-rails (2.0.3)",aniketstiwari,NONE,2019-02-15 06:23:35+00:00,True,2019-02-15 18:43:32+00:00,0.51,,2,1,2019-02-15 18:43:32+00:00,0.51,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1653,Content Security Policy eval restriction incompatibility in j$.isError_,"I attempted to update my project from using Jasmine v2.5.2 to v3.3.0, and found that test execution would stop with this error in the console:
EvalError: Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive: ""default-src 'self' 'unsafe-inline'"".
Investigating, commit 46cc48c introduced j$.isError_ which does
if (value && value.constructor && value.constructor.constructor &&
  (value instanceof (value.constructor.constructor('return this')()).Error)) {
  ...

which is a form of string eval in disguise.
Based on issue #1325's resolution, I assume that Jasmine is intended to be able to run under an unsafe-eval-restricting Content Security Policy, and so I request that this code be modified to not use eval, or to fall back to returning false if the eval fails.",kpreid,NONE,2019-02-17 01:26:31+00:00,False,,,,3,5,2019-02-21 01:58:26+00:00,4.02,slackersoft,MEMBER,1,1,0,0,['ready for work'],False,False,False,False,False,False,False,False,False,True,False,False,False,False,False
1655,Spec.status does not match with Suite.status,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Expected Behavior


suites[0].status should be in failed.
Current Behavior



Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""index"", () => {
  it(""index"", () => {
    expect(1).toBe(0);
  });
});
Context


Your Environment


Version used: 3.3.0
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:",wood1986,NONE,2019-02-21 07:36:19+00:00,True,2019-02-22 05:08:31+00:00,0.9,,2,1,2019-02-22 01:12:35+00:00,0.73,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1656,Unable to write conditional test ,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Expected Behavior


Current Behavior


Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context


Your Environment


Version used:
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:",PreetalC,NONE,2019-02-22 08:20:17+00:00,True,2019-04-19 22:45:52+00:00,56.6,,3,4,2019-02-22 08:31:02+00:00,0.01,PreetalC,NONE,1,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1659,Jasmine clock + Promise unintuitive,"It took me a while to figure out how to test a function that used a Promise and a timeout with Jasmine.clock(), so I figured I'd log this issue with my solution and a request to change something. I'm basically reposting issue #710 and #1282 and asking for a better solution than ""this is more of a how-to-unit-test question rather than a jasmine issue"".
An example simplified function to unit test:
import { NEVER, from, Observable } from 'rxjs';
import { flatMap, timeout } from 'rxjs/operators';
const myFuntion = (): Observable<void> => {
    return from(Promise.resolve()).pipe(
        flatMap(() => Promise.resolve()),
        flatMap(() => NEVER.pipe(timeout(30000))));
};
And the unit test (nonworking):
describe(""Jasmine clock + Promise"", function() {
    it('should timeout with Promise+clock', (done: DoneFn): void => {
        jasmine.clock().install();
        myFuntion().subscribe(
            () => {
                done.fail('was supposed to timeout error');
            },
            (error) => {
                expect(error.name).toEqual('TimeoutError');
                done();
            }
        );
        jasmine.clock().tick(30000);
    });
});
Expected Behavior
tick() or some other function should trigger the timeout.
Current Behavior
jasmine.clock().install() disables timing out until tick is called. Tick must be called after the timeout is set, which may be set in an async context and inaccessible from the unit test.
Possible Solution
Replace the tick() line with this:
Promise.resolve().then(() => Promise.resolve()).then(() => jasmine.clock().tick(30000));
Or, mark the function provided to it() as async and replace the subscribe( line with:
await await myFuntion().subscribe(
Alternately, as mentioned by the other issues and StackOverflow post, override Promise to be synchronous, or save off the original setTimeout() function before installing jasmine clock. Perhaps Jasmine could:

offer an option to make Promises synchronous
mention that Promises are asynchronous in the jasmine.clock() documentation
perhaps when jasmine.clock() is installed, that could be a reference time, so if it was ticked forward, it would then trigger any timeouts that should've been triggered, even if those timeouts were set after the jasmine.clock().tick() call.
perhaps a new method like jasmine.clock().tick(300).withAsyncLevels(3) that would result in the code

        Promise.resolve().then(() => {
            Promise.resolve().then(() => {
                Promise.resolve().then(() => {
                    jasmine.clock().tick(30000);
                });
            });
        });
Context
I spent multiple days trying to figure out why my code appeared to be ceasing execution in the chain of promises and observables I was attempting to test, eventually narrowing it down to an issue between interactions of Promise + Jasmine + Observable timeout operator. Then learning that jasmine.clock().tick() won't trigger timeouts that haven't been set yet, Promises are defined to be always async, and Observables may be async or sync depending on how they're used.
Your Environment


Version used: 2.99.1
Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 72
Operating System and version (desktop or mobile): macOS",chrisjdev,NONE,2019-02-28 15:50:13+00:00,True,2019-05-31 00:30:12+00:00,91.36,,2,9,2019-03-14 00:29:44+00:00,13.36,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1661,suiteStarted and suiteDone not called when filtering,"Expected Behavior
When filtering, any tests that will be run should have specStarted() and specDone() called if those tests live within any number of describe() suites.
In my case, I'm doing this:
const Jasmine = require('jasmine');
const jasmine = new Jasmine();
jasmine.loadConfig(...);
jasmine.addReporter(new MyReporter());
jasmine.execute(undefined, 'my filter');
MyReporter defines suiteStarted() and suiteDone(), and those functions are called as expected when no filter is provided.  However, when I supply a filter ('my filter' in the case above), none of the suites in which filtered tests run have suiteStarted() or suiteDone() called for them.
Current Behavior
suiteStarted() and suiteDone() are not called on my custom reporter when I call execute() and provide a filter (the second arg to execute).  I would expect that the suite the filtered tests belong to would have suiteStarted() and suiteDone() called for them, but that's not happening.
Possible Solution
Whenever a test within a suite (or nested suites) actually executes, call suiteStarted() and suiteDone() for each level of suite that test resides within.
Context
When running filtered tests, errors in a suite beforeEach() or afterEach() are not reported, but the overall execution state ends up failed.  I have to run without filtering to see the suite errors.
Your Environment

Version used:  3.3.1
Environment name and version (e.g. Chrome 39, node.js 5.4): node 11
Operating System and version (desktop or mobile): Linux",paulmedynski,NONE,2019-03-07 16:05:40+00:00,True,2019-03-18 11:17:31+00:00,10.8,,2,2,2019-03-12 01:32:45+00:00,4.39,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1663,"""received"" spelled wrong as ""receieved""","Expected Behavior

Error: Spy 'test' received a call with arguments [ 1 ] but all configured strategies specify other arguments.

Current Behavior

Error: Spy 'test' receieved a call with arguments [ 1 ] but all configured strategies specify other arguments.

Suite that reproduces the behavior (for bugs)

describe('Jasmine Test', function() {
  it('Spelling is wrong', function() {
  	var fixture = { test(value) { }, };
    spyOn(fixture, ""test"").withArgs(function() { }).and.returnValue(1);
    fixture.test(1);
  });
});",ErikPhilips,NONE,2019-03-08 22:07:20+00:00,True,2019-03-12 00:33:34+00:00,3.1,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1668,Implement a way to add a timeout for a specific describe block,"Expected Behavior
// Default timeout for all specs becomes 20000. 
const TIMEOUT = 20000;

describe('...', () => { ... }, TIMEOUT);

Current Behavior
describe('...', () => {
    // Timeout needs to be added for all the individidual tests
    const TIMEOUT = 20000;

    it('should do A', () => { ... }, TIMEOUT)
    it('should do B', () => { ... }, TIMEOUT) 
    it('should do C', () => { ... }, TIMEOUT) 
});

Context
To avoid duplication",maximedupre,NONE,2019-03-11 01:06:18+00:00,True,2019-03-12 01:24:46+00:00,1.01,,2,1,2019-03-12 01:07:40+00:00,1.0,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1670,Question: is it possible to not have fdescribe/fit cause jasmine to exit with a non zero exit code?,"As of now, I will have to use
./node_modules/.bin/jasmine --config=./jasmine.json test/*spec.js || exit 0

which is a working work around, however, I'd rather would like to use a configuration that states that focused tests are fine and must not cause the build to fail, e.g.
{
  ""failOnFocusedTests"": false
}

with focused suites this is different, as this will cause all the other suites from being skipped/not run, but within a single suite, aka ""describe"", these focused tests should not cause the build to fail.",silkentrance,NONE,2019-03-18 18:16:36+00:00,True,2019-03-24 15:15:09+00:00,5.87,,2,7,2019-03-19 00:56:52+00:00,0.28,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1671,Running Child Process in Jasmine Produces Inconsistent Results Based on the Shell Command,"Summary
When I execute a child process using exec(), some shell commands produce standard out and others do not.  pwd works for me but ps doesn't.
Expected Behavior
I should see the same standard out and error as I would if I were to run the commands in teh shell.
Current Behavior
I have the following code to execute a shell command in Jasmine.  If I change ""ps"" to something like ""pwd"", it works.  I see the standard out and the exit code, but I see neither one if I use certain commands like ""ps"".
Possible Solution
Suite that reproduces the behavior (for bugs)

    const uuid = require('uuid');
    const child_process = require('child_process');

    describe('TESTS', () => {
      console.log('TEST***');
      it('mp4', () => {
        console.log('1TEST***');
        const cmd = 'ps';
        child_process
          .exec(cmd, (err, stdout, stderr) => {
            console.log(`stdout is:${stdout}`);
            console.log(`stderr is:${stderr}`);
            console.log(`error is:${err}`);
          })
          .on('exit', code => console.log('final exit code is', code));
      }, 20000);
    });
});
Context
I'm trying to build an integration test suite taht runs some AWS SAM commands.  When I found that the tests weren't working I reverted to trying some basic shell commands.
Your Environment
Jasmine 3.3.0
Node 10.15
Linux Mint 19",jcald1,NONE,2019-03-23 02:13:52+00:00,True,2019-03-26 01:07:03+00:00,2.95,,2,1,2019-03-26 01:07:03+00:00,2.95,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1673,Jasmine 'expect(…).withContext is not a function' error,"I was looking for a way to make failure messaging more descriptive in Jasmine and found this new functionality https://jasmine.github.io/api/edge/matchers.html#withContext
So I try it in my Protractor framework like this
expect(true).withContext(""something else"").toBe(false);
Run the test and get error - Failed: expect(...).withContext is not a function
This feature was implemented since Jasmine 3.3.0, so I checked my package.json and see ""jasmine"": ""^3.3.1"", and package-lock.json has
""jasmine-core"": {
      ""version"": ""3.3.0"",

Any ideas what is wrong?",spleshakov,NONE,2019-04-03 18:57:10+00:00,True,2019-04-04 17:14:06+00:00,0.93,,3,2,2019-04-03 21:37:52+00:00,0.11,tymfear,NONE,0,0,0,2,['Protractor'],False,False,False,True,False,False,False,False,False,False,False,False,False,False,False
1674,toBePositiveInfinity/toBeNegativeInfinity fail messages describe opposite of actual expectation,"toBePositiveInfinity/toBeNegativeInfinity fail messages describe opposite of actual expectation
Expected Behavior
When an matching toBePositiveInfinity or toBeNegativeInfinity fails, the fail message shows the correct expectation e.g. ""Expected 123 to be Infinity."".
Current Behavior
When an matching toBePositiveInfinity or toBeNegativeInfinity fails, the fail message shows the inverted expectation e.g.""Expected 123 not to be Infinity."".
Possible Solution
Either fix the strings in the given matchers for these messages, or using util.buildFailureMessage to make sure all matcher messages are in the same structure.
If this is confirmed as a bug, I would love to fix this myself.
Suite that reproduces the behavior (for bugs)

describe(""Demo Suite"", () => {
    it(""Demo Test"", () => {
        // Fail messages as expected
        expect(1).toBe(2); // Expected 1 to be 2.
        expect(1).not.toBe(1); // Expected 1 not to be 1.

        // Inverted fail messages
        expect(1).toBePositiveInfinity(); // Expected 1 not to be Infinity.
        expect(Infinity).not.toBePositiveInfinity(); // Expected 1 to be Infinity.
        expect(1).toBeNegativeInfinity(); // Expected 1 not to be -Infinity.
        expect(-Infinity).not.toBeNegativeInfinity(); // Expected actual to be -Infinity.
    });
});
Context
-
Your Environment


Version used: 3.4.0 (Reproduceable in 2.99)
Environment name and version (e.g. Chrome 39, node.js 5.4): node.js 11.13.0
Operating System and version (desktop or mobile): Debian Buster
Link to your project: -",FelixRilling,CONTRIBUTOR,2019-04-06 17:28:10+00:00,True,2019-04-17 00:40:10+00:00,10.3,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1675,SpyObj and returnValue TypeError on version 3.4.0,"Are you creating an issue in the correct repository?

jasmine.SpyObj -> and.returnValue(val: void) which invokes TypeError. The expected behavior is returnValue(val: any) so that it can return value for mockup method or object.
Jasmine Version: 3.4.0
Expected Behavior
jasmine.SpyObj -> and.returnValue(val: any);
Current Behavior
jasmine.SpyObj -> and.returnValue(val: void);
Suite that reproduces the behavior (for bugs)

 it(""Should DataEditorService works correctly with method init and update"", () => {
    // mock dataService method
    let testData = { name: ""hello"" };
    dataServiceSpy.init.and.returnValue(testData);
});

Your Environment

Version used: 3.4.0 (previous version 3.3.0 works fine)
Environment name and version (e.g. Chrome 39, node.js 5.4): Windows 10
Operating System and version (desktop or mobile): Desktop",Vibrat,NONE,2019-04-07 02:36:06+00:00,False,,,,2,1,2019-04-17 00:33:11+00:00,9.91,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1676,"Spec duration is mentioned in docs, but null or 0","As I see on docs duration is available and there is a pull request (#1646) to support duration property. But it is null or 0. How to make it works?
Console reporter and Third-party console reporter use their own timers. It is possible to use jasmine.jasmine.Timer in custom reporter?",apla,NONE,2019-04-09 13:58:29+00:00,False,,,,2,1,2019-04-16 00:32:08+00:00,6.44,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1677,spyOnAllFunctions is not spying on any function.,"I'm using ngxs in angular and I'd like to create a spy of the whole store.
For that, I try:
spyOnAllFunctions(storeSpy)
But it doesn't seem to be working.
This is the class I'm trying to spy on:
https://github.com/ngxs/store/blob/master/packages/store/src/store.ts
By debugging into the 'spyOnAllFunctions', I get into this method:
this.spyOnAllFunctions = function(obj) {
...
 for (var prop in obj) {
   if (Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] instanceof Function) {
     var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
     if ((descriptor.writable || descriptor.set) && descriptor.configurable) {
       this.spyOn(obj, prop);
     }
   }
 }
...
};

and I verify that the first part of the first if is returning false for each of the Store methods (dispatch, reset, select, ...)
Expected Behavior
I would expect the spyOnAllFunctions to be equivalent to calling:
jasmine.createSpyObj<Store>(['dispatch', 'select', ...]); 
by passing every method.
Is there something I'm missing here?
Current Behavior
spyOnAllFunctions returns the same passed object and using 'and' on any of the methods, results in undefined:
storeSpy.reset.and.callThrough();",mdarefull,NONE,2019-04-10 22:51:44+00:00,True,2019-05-15 01:01:35+00:00,34.09,,3,4,2019-04-19 00:21:52+00:00,8.06,slackersoft,MEMBER,1,1,0,0,"['help needed', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,False,False,False,True
1681,await expect - expectationFailOutput,"it('test async fail to console log', async() => {
let components = element.all(by.xpath('//button'));
    await browser.get('http://localhost:3333/testpageforbutton');
    await expect(components.count()).toBe(19, 'some info for fail ' + components.count());
});

count in expect is correctly counted, but in expectationFailOutput did not show correctly text to console log
this working:
it('test async fail to console log', async() => {
let components = element.all(by.xpath('//button'));
    await browser.get('http://localhost:3333/testpageforbutton');
    expect(await components.count()).toBe(19, 'some info for fail ' + await components.count());
});",rebajz,NONE,2019-04-15 10:38:53+00:00,False,,,,2,1,2019-04-16 00:59:32+00:00,0.6,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1682,toEqual() not show expectationFailOutput in console log,"fit('some text', async() => {
let components = element.all(by.xpath('//button'));
    await browser.get('http://localhost:3339/buttonpage');
    expect(await components.count()).toEqual((19), 'some text for fail ' + await components.count());
});

in console is visible only:

Expected 20 to equal 19.

for example toBe() show correctly fail message",rebajz,NONE,2019-04-15 10:44:37+00:00,True,2019-04-17 00:16:06+00:00,1.56,,3,2,2019-04-15 10:48:22+00:00,0.0,tymfear,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1683,Getting mismatch execute of test,"devDependencies: {
  ""jasmine-core"": ""3.4.0"",
    ""jest"": ""22.4.2"",
    ""jsdom"": ""14.0.0"",
    ""karma"": ""3.1.4"",
    ""karma-chrome-launcher"": ""2.2.0"",
    ""karma-coverage"": ""1.1.1"",
    ""karma-jasmine"": ""2.0.1"",
    ""karma-jsdom-launcher"": ""6.1.2"",
    ""karma-junit-reporter"": ""1.2.0"",
    ""karma-webpack"": ""^4.0.0-rc.6"",
}

karma.config {
     browserDisconnectTolerance: 2,
    // long load time while webpack blocks on serving the request.
    browserNoActivityTimeout: 60000, // 60 seconds
    browsers: ['jsdom'],
}

node version: v8.9.1
The Unit test should be 223 instead of 515.
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 515 of 223 SUCCESS (0 secs / 2 mins 5.294 secs)
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 516 of 223 SUCCESS (0 secs / 2 mins 7.293 secs)
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 517 of 223 SUCCESS (0 secs / 2 mins 11.44 secs)
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 518 of 223 SUCCESS (0 secs / 2 mins 13.478 secs)
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 519 of 223 SUCCESS (0 secs / 2 mins 13.58 secs)
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 520 of 223 SUCCESS (0 secs / 2 mins 13.608 secs)
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 521 of 223 SUCCESS (0 secs / 2 mins 15.648 secs)
Mozilla/5.0 (win32) AppleWebKit/537.36 (KHTML, like Gecko) jsdom/14.0.0: Executed 521 of 223 SUCCESS (0 secs / 2 mins 15.648 secs)",brendonco,NONE,2019-04-16 02:25:37+00:00,False,,,,2,1,2019-04-17 00:50:22+00:00,0.93,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1684,npm install jasmine in eclipse after that it showing error in ci.js file,"Are you creating an issue in the correct repository?

When in doubt, create an issue here.
If you have an issue with the Jasmine docs, file an issue in the docs repo
here: https://github.com/jasmine/jasmine.github.io
This repository is for the core Jasmine framework
If you are using a test runner that wraps Jasmine, consider filing an issue with that library if appropriate:

Jasmine npm
Jasmine gem
Jasmine py
Gulp Jasmine Browser
Karma
Grunt Contrib Jasmine




Expected Behavior


Current Behavior


Possible Solution


Suite that reproduces the behavior (for bugs)

describe(""sample"", function() {
});
Context


Your Environment


Version used:
Environment name and version (e.g. Chrome 39, node.js 5.4):
Operating System and version (desktop or mobile):
Link to your project:",kesavamuthuM,NONE,2019-04-22 00:47:52+00:00,False,,,,2,4,2019-04-22 00:50:35+00:00,0.0,kesavamuthuM,NONE,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1687,Arraybuffer does not work correctly with toEqual,"Expected Behavior
Two arraybuffers are compared with their content in jasmine
Current Behavior
Two different ArrayBuffers with different values but same length compare equal in jasmine.
Example passes even though it should not:
describe('Arraybuffer', () => {
  it('equal different Arraybber', () => {
    const buffer1 = new ArrayBuffer(4);
    const buffer2 = new ArrayBuffer(4);
    const array = new Uint8Array(buffer1);
    array[0] = 1;
    expect(buffer1).toEqual(buffer2);
  });
});",dankurka,NONE,2019-04-29 21:51:22+00:00,False,,,,2,4,2019-04-30 00:45:03+00:00,0.12,slackersoft,MEMBER,1,0,0,1,"['help needed', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,False,False,False,True
1692,Suggestion: a way to default spies to _not_ expect calls,"Summary
I would like some way to default spies to behave as if they should not be called -- similar to what you get today if you use .withArgs() but then call the spy without defined arguments:
Error: Spy 'spy' received a call with arguments [ 'hello' ] but all configured strategies specify other arguments.

Expected Behavior
I'd like to do this:
spyOn(myModule, 'myMethod');
myModule.myMethod();  // => throws 'Unexpected call to myMethod()'

I'd especially like to do this:
const request = require('request-promise');
spyOnAllFunctions(request);
request.post();    // => throws 'Unexpected call to post()'

Current Behavior
Today, the default behavior is that a spy is ""not configured"" - but that's not really true, it's configured to return undefined.  The following are all equivalent, with varying levels of expressiveness:
spyOn(foo, 'bar');
spyOn(foo, 'bar').and.stub();
spyOn(foo, 'bar').and.returnValue(undefined);

Possible Solution
I'm fishing here.  Obviously, there are one billion jasmine tests out there that assume an un-configured spy returns undefined, so you can't break that.
I think there's a few things I'd like that add up to a workable solution:

A new spy strategy (or maybe it's a method on spy itself?) that explicitly says ""expect this not to be called"".  spy.and.unexpected() or something.  You can already do this!  But it's unintuitive:

// One approach that's already built in...
spy.withArgs('aosdfihasidfhsido').and.returnValue();
spy();  // => throws error

// Obviously, you can also do this...
spy.and.callFake(myCustomUnexpectedCallHandler);
spy();  // => throws some custom error


Some way (perhaps temporarily?) to ""default"" what method is used when assigning spies.  Especially for mass-assignment... This might be good enough:

// This could mean ""apply the unexpected spy strategy to every spy?""
spyOnAllFunctions(request).and.unexpected();

// Or without a new spy strategy
spyOnAllFunctions(request).and.throwError(UnexpectedError);

Context
This is something that I end up implementing on many projects, and so it'd be great if there was a built-in ""jasmine"" way to accomplish it.
(The use case here is when you are unit testing modules and completely mocking external dependencies.  It's very useful to grab the 3 components this component uses, and mass-assign every function on all of them an error that says ""hey, this got called unexpectedly!"".  You then allow-list only the expected function calls by assigning .stub() or .callThrough() as appropriate.)
This could be related to #1641, in that, I'm kind of advocating for a message like this (with no withArgs):

Unexpected call to 'spy' with arguments [blah]

Whereas the linked issue wants to fix the toBeCalledWith matcher, you could make that argument about the withArgs output, and desire:

Unexpected call to 'spy' with arguments [blah]. You might have meant:


#1: diff builder comparison of withArgs(0) & blah
#2: diff builder comparison of withArgs(1) & blah
etc.

So, the behavior I'm looking for is consistent, just the message is more detailed if you've used withArgs().
Your Environment

node v6, v8, v10 (varies)",elliot-nelson,CONTRIBUTOR,2019-05-05 23:15:49+00:00,False,,,,2,8,2019-05-06 15:14:22+00:00,0.67,elliot-nelson,CONTRIBUTOR,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1693,Suggestion: default async spies to be async,"Expected Behavior
Today, everyone expects an un-configured spy to return undefined.  If we know that the function is async, though, we can do better and return a promise for undefined.
const Foo = {
    bar: async () => 7
};
spyOn(Foo, 'bar');
Foo.bar().then(console.log);  // => prints undefined

Current Behavior
const Foo = {
    bar: async () => 7
};
spyOn(Foo, 'bar');
Foo.bar().then(console.log);  // => error: then is not defined on undefined

Possible Solution
In recent versions of node, anyway, you can use:
    fn.constructor.name === 'AsyncFunction'

Context
Throwing this out here.  I think the behavior ""un-configured spies return undefined"" is consistent, and there's a lot of history there we don't want to break, but it's also not very useful in my opinion.
Almost all useful nodejs javascript involves promises, and most of that work can now be written using async functions.  Unlike promise-based functions, we can actually tell (generally) when a function is async, which means we know it's totally useless to return a value that's not a promise.",elliot-nelson,CONTRIBUTOR,2019-05-05 23:28:15+00:00,True,2019-05-08 00:28:51+00:00,2.04,,2,3,2019-05-07 00:33:17+00:00,1.05,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1694,Suggestion: matcher 'toHaveBeenCalledExactly',"Context
On many projects on my team, we encourage people to avoid toHaveBeenCalled() and toHaveBeenCalledWith(), in favor of this stricter check:
    expect(spy.calls.allArgs()).toEqual([
        [""first"", ""expected"", ""call""],
        [""second"", ""expected"", ""call""]
    ]);

This is the last word in spy expects: you'll get notified if you called too many times or too few times, and if any of the calls weren't exactly as expected or were in a different order than expected, you get nice diff-builder output describing the differences.
Expected Behavior
I'd like to be able to do that check, with a built-in matcher instead:
// Just like the .calls.allArgs() approach:
expect(spy).toHaveBeenCalledExactly([
    [""first"", ""args""],
    [""second"", ""args""]
]);

// Or maybe the matcher could just use ...args instead of an array:
expect(spy).toHaveBeenCalledExactly(
    [""first"", ""args""],
    [""second"", ""args""]
);

// This is equivalent to .not.toHaveBeenCalled()
expect(spy).toHaveBeenCalledExactly();

Current Behavior
Today, you can use a .toEqual on .calls.allArgs().  Totally serviceable, just lacks a little syntax sugar.
Possible Solution
I'd be happy to put up a PR for this one, if it sounds like something that could belong in core.
Possible names?

toHaveBeenCalledExactly([], [], [])
toHaveBeenCalledWithExactArgs([], [], [])
toHaveBeenCalledWithOnly([], [], [])

I think the functionality is pretty simple, it mostly just needs an understandable name and need to decide which calling syntax is least surprising (an array of arrays, or an ...arguments list of arrays, to represent the args for each call).",elliot-nelson,CONTRIBUTOR,2019-05-07 13:32:35+00:00,False,,,,2,4,2019-05-09 00:18:46+00:00,1.45,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1695,toBeCloseTo fails in edge case (+ fix),"the toBeCloseTo matcher started to fail recently on Chrome 74, i.e. the following cases are failing:
describe(""sample"", function() {
    it(""tobecloseto fails"", function() {
        expect(4.030904708957288).toBeCloseTo(4.0309, 5);
        expect(4.82665525779431).toBeCloseTo(4.82666, 5);
        expect(-2.82665525779431).toBeCloseTo(-2.82666, 5);
    });
});
A possible fix is the following:
tobecloseto.js#29 change to:
pass: Math.round(delta * pow) <= maxDelta * pow

Version used: 3.4.0 & 2.99
Environment name and version: Chrome 74 & NodeJs 12.2.0
Operating System and version (desktop or mobile): WIndows 10",paulvanbrenk,CONTRIBUTOR,2019-05-08 17:10:00+00:00,True,2019-05-21 00:11:06+00:00,12.29,,2,2,2019-05-09 00:21:17+00:00,0.3,slackersoft,MEMBER,1,1,0,0,"['help needed', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,False,False,False,True
1696,Suggestion: detect expect() without matcher in core,"Summary
If you've used jshint / eslint / tslint, you're probably encountered some variety of a rule that helps you detect this chestnut:
expect(x > 3);     // missing .toBe(true)!

// (ofc should use toBeGreaterThan, but at least toBe would assert something)

If you're not using a linter, though, to someone unfamiliar with javascript testing frameworks this looks totally valid and might sit in a large project for months/years without being detected.  Probably until the code breaks and the test doesn't and someone investigates.
Possible solution
Add a simple boolean to Expectation that declares whether a matcher has been attached.  Whenever a matcher has been called, set this flag to true (can add to Expectation's comparison wrappers).  Then all Runnables (Spec/Suite) can be extended to add the result of every expectation factory call to a local list of expectations, and the QueueRunner can ask every runnable after it is finished ""do you have any expectations with no matchers?"", adding a new error to the spec/suite as appropriate.
Context
On larger teams, if you don't have some very strong linting enabled, you can fall into this trap a lot.  I think maybe, it makes sense for Jasmine itself to consider an expectation with no matcher an error, since it is essentially a broken test.
The issue arises a lot when mixing different environments, for example, I've seen this before in jasmine + React tests:
const pane = mount(<MyPane />);
expect(pane.matchesElement(
    // 20 lines of JSX here
));   // Oops!
// ""pane.matchesElement"" kind of looks like a matcher, but this test doesn't assert anything",elliot-nelson,CONTRIBUTOR,2019-05-09 10:56:32+00:00,True,2019-05-15 15:13:42+00:00,6.18,,2,4,2019-05-14 00:48:33+00:00,4.58,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1702,CONTRIBUTING Guide is obsolete?,"The CONTRIBUTING guide still refers to ruby gem installs, running rake jasmine, etc.  I think this is obsolete (not sure about the VirtualBox stuff though).
Expected Behavior
Contributing guide describes how to set up nodejs environment, how to get the various WebDriver launchers (Chrome, Firefox, Safari, PhantomJS, etc.), and how to run unit tests in each browser and nodejs.
Also, at least a vague list of what is tested in the CI build (travis) might be helpful -- like, what browser and version targets should be hit for a change to jasmine to be considered successful?  Also, the USE_SAUCE stuff is a little confusing -- often in branch builds none of that stuff runs at all.  Is this on purpose or a mistake?
Current Behavior
No mention of webdriver/launcher installs or configuration.",elliot-nelson,CONTRIBUTOR,2019-05-15 16:42:37+00:00,True,2019-05-16 00:35:35+00:00,0.33,,2,1,2019-05-16 00:38:14+00:00,0.33,slackersoft,MEMBER,1,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1703,Ability to add custom AsyncMatchers,"While testing using the great new expectAsync matchers, I ran into a deficiency where toBeResolvedTo does not print what it was rejected with on rejections.
await expectAsync(
    promiseReturningThing()
).toBeResolvedTo(jasmine.any(Buffer));
becomes
Expected a promise to be resolved to <jasmine.any(Buffer)> but it was rejected.

I tried to overcome that with a custom async matcher that is a direct copy of toBeResolvedTo but that prints out the rejection cause for easier debugging.
import {toBeDescriptivelyResolvedTo} from ""../../matchers/async/toBeDescriptivelyResolvedTo"";
jasmine.addMatchers({
    toBeDescriptivelyResolvedTo: toBeDescriptivelyResolvedTo
})
However, I found that custom matchers do not count as async matchers.
Expected Behavior
I expect to be able to define a custom async matcher.
await expectAsync(
    promiseReturningThing()
).toBeDescriptivelyResolvedTo(jasmine.any(Buffer));
and have it print out the rejected value.
Expected a promise to be resolved to <jasmine.any(Buffer)> but it was rejected with ""fake rejection"".

Current Behavior
I get
TypeError: expectAsync(...).toBeDescriptivelyResolvedTo is not a function
I can test it with a normal expect and it works, as far as being called, but then I get a failure from expect itself not working with the promise.
await (expect(Promise.resolve('b')) as any).toBeDescriptivelyResolvedTo(2);
Expected [object Promise] to be descriptively resolved to 2.

I can verify it is being called by adding console.log statements and seeing them output in addition to the failure.
Possible Solution
A possible workaround might exist by manipulating some of the internal globals, but it might be tricky as they are not all exposed. The correct code is probably going to look like something around src/core/Expectation.js, specifically addAsyncCoreMatchers. The current code is able to add the core async matchers.
j$.Expectation or j$.asyncMatchers seem useful if one could get a reference.
Also note this todo about j$.pp, because toBeResolvedTo uses it.
If my problem is a typing issue that would be great and I can open an issue elsewhere.
Suite that reproduces the behavior (for bugs)

export const toBeDescriptivelyResolvedTo  =
    /**
     * Expect a promise to be resolved to a value equal to the expected, using deep equality comparison.
     * @function
     * @async
     * @name async-matchers#toBeResolvedTo
     * @param {Object} expected - Value that the promise is expected to resolve to
     * @example
     * await expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
     * @example
     * return expectAsync(aPromise).toBeResolvedTo({prop: 'value'});
     */
    function toBeResolvedTo(util: any, customEqualityTesters: any) {
        console.log(""eggo"");
        return {
            compare: function(actualPromise: any, expectedValue: any) {
                console.log(""waffle"");
                function prefix(passed: any) {
                    return 'Expected a promise ' +
                        (passed ? 'not ' : '') +
                        'to be resolved to ' + JSON.stringify(expectedValue);
                }

                return actualPromise.then(
                    function(actualValue: any) {
                        if (util.equals(actualValue, expectedValue, customEqualityTesters)) {
                            return {
                                pass: true,
                                message: prefix(true) + '.'
                            };
                        } else {
                            return {
                                pass: false,
                                message: prefix(false) + ' but it was resolved to ' + JSON.stringify(actualValue) + '.'
                            };
                        }
                    },
                    function(err: any) {
                        return {
                            pass: false,
                            message: prefix(false) + ' but it was rejected with ' + JSON.stringify(err) + '.'
                        };
                    }
                );
            }
        };
    };

---

      await (expectAsync(Promise.reject('b')) as any).toBeDescriptivelyResolvedTo('a');

Context
Not printing the value makes debugging failed tests harder.
Not being able to extend custom async matchers reduces Jasmine's power.
Your Environment

Version used: 3.4.0
Environment name and version (e.g. Chrome 39, node.js 5.4): Node 10
Operating System and version (desktop or mobile): Alpine Linux Docker container
Link to your project: N/A",r4j4h,NONE,2019-05-15 19:53:06+00:00,False,,,,3,5,2019-05-17 00:11:40+00:00,1.18,slackersoft,MEMBER,1,1,0,1,"['help needed', 'ready for work']",False,False,False,False,False,False,False,False,False,True,False,False,False,False,True
1704,Spec 'x' has no expectations.,"Spec 'x' has no expectations.
Expected Behavior
it should be a warning
Current Behavior
it is an error (in the console)
Possible Solution
Suite that reproduces the behavior (for bugs)

describe(""regular use"", function() {
		it(""basic use should work"", function() {
			var x = new X();
			x.run();
		});
	});
Context
I run some simple statement and not throwing an error is enough for the test to make sense
Your Environment
jasmine-core"": ""3.4.0
(browser)",GrosSacASac,NONE,2019-05-16 16:48:22+00:00,True,2019-06-12 20:32:19+00:00,27.16,,2,5,2019-05-17 00:27:26+00:00,0.32,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1707,Can we get a mention in the docs somewhere for @testdeck/jasmine?,"Question
We have created a wrapper for existing test frameworks, including also jasmine.
Please see https://github.com/testdeck/testdeck and also https://github.com/testdeck/testdeck-jasmine-seed for a working minimal setup.
Perhaps you can give us a little boost by mentioning the project in your official documentation?
TIA!",silkentrance,NONE,2019-05-17 19:45:22+00:00,True,2019-06-02 16:54:27+00:00,15.88,,2,2,2019-05-29 00:34:34+00:00,11.2,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1709,"Implement ""skip()"" in Jasmine","Summary
Jasmine should support a skip() interface.  This issue is being filed so before any work is done, we can agree on what that interface should look like.
Proposed Syntax
VARIANT 1: Straight up call, no message
it(""isn't finished yet"", function() {
    skip();
    callAMethodThatDoesntExist();
});

VARIANT 2: Straight up call, with explanatory message
// it
it(""isn't finished yet"", function() {
    skip(""need to implement this"");
    callAMethodThatDoesntExist();
});

// Or before
beforeEach(function() {
    skip(""these tests don't work yet"");
});

// Or after
afterEach(function() {
    skip(""this cleanup phase is broken"");
});

VARIANT 3: Skip partial test, no message
it(""isn't finished yet"", function() {
    skip(function() {
        callAMethodThatDoesntExist();
    });
});

VARIANT 4: Skip partial test, with explanatory message
it(""isn't finished yet"", function() {
    skip(""need to implement this"", function() {
        callAMethodThatDoesntExist();
    });
});

VARIANT 5: Skip full test (wrapper approach)
it(""isn't finished yet"", skip(function() {
    callAMethodThatDoesntExist();
}));

VARIANT 6: Skip full test (wrapper approach w/message)
it(""isn't finished yet"", skip(""need to implement this"", function() {
    callAMethodThatDoesntExist();
}));

VARIANT 7: Skip block of tests (suite level)
describe(""My Module"", function() {
    it(""works"", function() { });

    skip(""need to implement these"", function() {
        it(""fails"", function() { });
        it(""fails again"", function() { });
    });
});

I am including Variants 5-7 so we can intentionally include or exclude them.  Variants 1-4 all happen ""inside"" a running spec context; Variants 5-7 would be outside a running spec but in a suite context, so we'd need to detect that and behave differently if we cared to support it.
Proposed Behavior
My understanding of how skip() should work is that it should immediately exit the current function, and any follow-up functions at that level.  It should still execute any functions at any level above this level.
Level        Function Containing skip()
-----        --------------------------
0            beforeAll
1              beforeEach
2                beforeEach
3                  it
2                afterEach
1              afterEach
0            afterAll

Expressed as requirements:

If skip() is encountered inside it, skip the rest of this it.  All afterEach's defined must be called in order as usual.
If skip() is encountered inside a beforeEach, skip the rest of that beforeEach, skip the it we were about to execute, and skip the same-level corresponding afterEach.  All afterEach defined above this level must still execute -- for example, a skip encountered in Level 2 will skip Level 2's afterEach but not Level 1's.
If skip() is encountered inside a afterEach, skip the rest of that function, but nothing else.
If skip() is encountered inside a beforeAll, I'm not sure what should happen.  Either literally no tests at all should run (i.e. report NOTHING), or, we should run everything but every single beforeEach, it, and afterEach is skipped.  The afterAll is also skipped in this case.

Relationship with pending()
There are similarities between pending() and skip().  I think the skip interface should make it intentional that Jasmine will never for any reason attempt to run the skipped content, and that it is well-suited for:

Broken code (potentially unrunnable)
Unsafe code (code with side effects that could break other tests)
Slow tests (i.e. a large suite with tests that are all timing out due to an error)
Intermittent tests (sometimes pass, sometimes fail)

The intention for pending(), I believe, is tests that are fundamentally sound but are just not passing yet, which is not the same category as the situations above.
Changes to Reporting API + Packaged Reporters
TODO: Decide whether we need to and can report ""skipped"" and ""pending"" tests separately to reporters, update the reporting API, and update packaged reporters to display this information.  Determine whether we can make this a non-breaking change (ideally, outdated custom reports simply take a new field -- skipped -- that they don't display until they are updated).
Changes to shortcut (xit/xdescribe) functions
TODO: Is it appropriate to change xit/xdescribe to ""skip"" instead of ""pending""?
Comparisons to other popular projects: Mocha just copies Jasmine, so xit translates to pending.  RSpec interprets xit/xdescribe as skipped, NOT pending, so we could align with them in Jasmine if desired.
New helper shortcuts
Speaking of RSpec, note that they provide the it ""replacements"" skip and pending (so skip(""blah"", function() { instead of it()) to easily mark tests as skipped or pending.  ""skip()"" is identical to ""xit()"" for RSpec.  These might be alternative, better approaches than supporting Variants 5-7 up above.  However, this would increase the additions to global scope.
Approach
Sorry for the essay.  I'd like to see this functionality, and want to make sure it's laid out for anyone who might want to tackle it.  I'll plan on updating these requirements based on comments below.",elliot-nelson,CONTRIBUTOR,2019-05-19 16:43:12+00:00,False,,,,3,3,2019-05-21 00:53:13+00:00,1.34,slackersoft,MEMBER,1,0,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1714,Suggestion: officially treat spies on `x#get` and `x#set` as properties,"I'd like to extend spyOn slightly so that these two are equivalent:
spyOn(object, 'thing#get').and.returnValue(42);
spyOnProperty(object, 'thing', 'get').and.returnValue(42);
If we make the string prop#[get|set] the official way to refer to property spies, we get a couple of benefits:


The existing createSpyObj function gets property spies for free, since 'prop#get' can jus be included in the string array passed to createSpyObj.  This would close PR #1569.


The upcoming getSpy functionality I'd like to add would no longer need a corresponding separate getSpyOnProperty method -- you could just do getSpy(object, 'field#get').and.callThrough() in order to change the behavior of an existing property spy.


The current spyOnProperty method already exists so we'd keep supporting it.  Maybe we could mark it deprecated for a far-future release to remove in favor of this new syntax.


Context
The goal here is to make spying on properties both as simple and as similar (to function spies) as possible.  I think this would get us really close and looks, imo, reasonable.",elliot-nelson,CONTRIBUTOR,2019-05-22 18:31:45+00:00,True,2019-06-07 11:15:36+00:00,15.7,,2,6,2019-05-24 00:37:53+00:00,1.25,slackersoft,MEMBER,1,1,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1715,Suggestion: change strategy 'resolveWith' to 'resolveTo',"For the recently added .and.resolveWith() and .and.rejectWith() strategies, there are slight mismatches with existing naming.
Existing expectAsync().toBeResolvedTo() would suggest that maybe the resolving strategy should be named .and.resolveTo().  This would mean Jasmine's official way of referring to promises is that they ""resolve to"" something or ""reject with"" something.
For rejecting, we have a current pattern already:


.and.throwError always throws an Error


expect().toThrow confirms it threw the specific object


expect().toThrowError checks the type/message of the error


.and.rejectWith always throws an Error


expect().toBeRejectedWith confirms it rejected with the specific object


expect().toBeRejectedWithError checks the type/message of the error


This makes me wonder if the rejection strategy should be called .and.rejectWithError.  There is no .and.rejectWith, because we don't support a way to reject a thing that is not an Error.  (If, for some legacy reason, you really need your code to do this, you'd need to callFake and reject it yourself.)
I thought I'd put this up here for consideration before the new strategies go out in an official release.  The devil's advocate to all of the above is ""maybe the existing naming is wrong, and it's easier to just talk about resolveWith and rejectWith"".",elliot-nelson,CONTRIBUTOR,2019-05-23 15:36:25+00:00,True,2019-05-24 00:31:03+00:00,0.37,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1717,Feature suggestion: Add toHaveBeenCalledOnceWith matcher,"It would be extremely useful to have a toHaveBeenCalledOnceWith() matcher combining both toHaveBeenCalledTimes(1) and toHaveBeenCalledWith() matchers.
About 70% of my unit test expectations about functions look like this:
expect(backendService.get).toHaveBeenCalledTimes(1);
expect(backendService.get).toHaveBeenCalledWith('SomeArgument', someSecondArgument);
It would be really much, much more readable if we could have a single matcher that combines both matchers:
expect(backendService.get).toHaveBeenCalledOnceWith('SomeArgument', someSecondArgument);",Maximaximum,NONE,2019-06-06 11:01:03+00:00,False,,,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1723,Error when expecting a specific enum value,"I'm using Jasmine with an Angular 7 app and I have a test where:-
someValueContainingAnEnum = MyEnum.EnumValue
...
expect(someValueContainingAnEnum).toEqual(MyEnum.EnumValue);
and I'm getting a compiler error:-
ERROR in src/my.component.spec.ts: error TS2345: Argument of type 'MyEnum.EnumValue' is not assignable to parameter of type 'Expected<MyEnum.EnumValue>'.
and MyEnum is defined as:-
export enum MyEnum {
     EnumValue,
     ...
}
Expected Behavior
No compile errors.
Current Behavior
Compile errors.
Possible Solution
If I don't assign someValueContainingAnEnum a value, the test compiles. I suspect the compiler has made a type inference that is incompatible with Jasmine.
Context
The code is not compilable.
Your Environment

Jasmine-core: 3.4.0
Angular: 7.2.15
Typescript: 3.2.4
@types/jasmine: 3.3.13
@types/jasminewd2: 2.0.6
Google Chrome Version 75.0.3770.100 (Official Build) (64-bit)
Node: 12.3.1
MacOS: 11.13.6",chrisvelevitch,NONE,2019-06-22 11:36:58+00:00,False,,,,3,4,2019-06-26 12:19:59+00:00,4.03,elliot-nelson,CONTRIBUTOR,0,1,0,1,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1724,Suggestion: Apply a spy strategy to a group of spies,"PROPOSAL
I'd like to be able to apply a spy strategy to a group of spies.
There are 2 situations in Jasmine today that involve creating multiple spies (createSpyObj and spyOnAllFunctions).  Unfortunately both of them return an object, and we can't break that API, so my suggestion is:
spyOnAllFunctions(widget, and => and.throwError('Do not call me'));

createSpyObj('widget', ['a', 'b'], and => and.returnValue('Hello!'));

Both functions would add a final optional parameter, a ""spy strateger setter"".  If specified, it will be called for each spy created, allowing introspection e.g.:
spyOnAllFunctions(widget, and => and.returnValue(`You called ${and.identity}.`));

For the createSpyObj case, the spy strategy would take precedent over the default values provided in object form:
var obj = createSpyObj({ f: 3, g: 4 }, and => and.returnValue(7));
expect(obj.f()).toEqual(7);

But, they would still be initially set as a base:
var obj = createSpyObj({ f: 3, g: 4 }, and => {
    // Advanced usage
    and.getSpy().withArgs(jasmine.any(Number)).and.callFake(x => x * 2);
});

expect(obj.f(10)).toEqual(20);
expect(obj.f()).toEqual(3);

This ""spy strategy setter"" implementation would mimic the syntax in #1716, so it would be consistent.
POTENTIAL DOWNSIDES
This might further fragment the ways in which to use createSpyObj... e.g., including properties:
var foo = createSpyObj('foo', ['f', 'g'], ['x', 'y'], and => and.throwError('No Good'));

foo.x           // => throws error
foo.x = 3;    // => throws error

ALTERNATIVES
There's been discussion before (#1692) about a way to retrieve spies with some kind of jasmine.getSpies call, e.g.:
spyOnAllFunctions(widget);
jasmine.getSpies(widget).and.throwError('You called me');

This might be a better way forward, because the getSpies function would be a brand new interface that could potentially have some options (you could specify whether to include methods, properties, etc., something like):
var widget = jasmine.createSpyObj('widget', ['a', 'b', 'c'], ['x', 'y']);

// Update the spy strategy for the functions & prop getters, but not prop setters
jasmine.getSpies(widget, { fn: true, get: true, set: false }).and.throwError('You called me');",elliot-nelson,CONTRIBUTOR,2019-06-26 11:50:27+00:00,False,,,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1725,Proposal: await jasmine.clock().asyncTick(),"Several previous issues have discussed the way mock clock doesn't work very well with Promises #1659 #1282 #710 . Here I have a proposal for a new method on the mock clock that will inter-operate with Promises nicely.
It's quite common to write code like this:
async function() {
  await new Promise(resolve => setTimeout(resolve, 1000));
  console.log('A');
  await new Promise(resolve => setTimeout(resolve, 1000));
  console.log('B');
}

You might expect jasmine.clock().tick(2000) to log both A and B, but it will log neither A nor B! The issue is that .tick() runs any scheduled timeouts one after the other, synchronously, and doesn't allow microtasks to run.
Instead, we need to run a timeout, wait for microtasks to run, and then run the remaining timeouts, repeat. This is pretty close to the way the JS engine actually works.
I propose adding an .asyncTick() method that does what I've just described. The test would call it like this:
await jasmine.clock().asyncTick(2000);

One difficulty is knowing how to wait for microtasks to run. In previous issues, people pointed out that various Promise implementations work in different ways. My solution to this (in other settings) has been to schedule a (real) setTimeout. This does slow the test down, but it's a lot better than using a real clock.
Another alternative could be to call jasmine's clearStack(). If a user has a Promise implementation that is slower than whatever clearStack() does, we could just not care. (They can always get a better Promise implementation!) This would be my preferred approach.
If this seems like a reasonable proposal, I will try to code it up and send a PR. Seems like I need to add a runScheduledFunctionsAsync method to DelayedFunctionScheduler.",stephenfarrar,NONE,2019-06-27 04:25:00+00:00,False,,,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1726,"toBe should pass on identical objects, even if they have a bad toString","Test that demonstrates the bug
diff --git a/spec/core/matchers/toBeSpec.js b/spec/core/matchers/toBeSpec.js
index e065af57..84dc83db 100644
--- a/spec/core/matchers/toBeSpec.js
+++ b/spec/core/matchers/toBeSpec.js
@@ -27,6 +27,16 @@ describe(""toBe"", function() {
     expect(result.message).toBe(""Expected Object({ foo: 'bar' }) not to be Object({ foo: 'bar' }). Tip: To check for deep equality, use .toEqual() instead of .toBe()."")
   });
 
+  it(""passes with a custom message when expected is an object with an invalid toString"", function() {
+    var matcher = jasmineUnderTest.matchers.toBe(jasmineUnderTest.matchersUtil),
+      result,
+      obj = {foo: ""bar"", toString: function() {throw new Error('I am a bad toString');}};
+
+    result = matcher.compare(obj, obj);
+    expect(result.pass).toBe(true);
+    expect(result.message).toBe(undefined);
+  });
+
   it(""fails with no message when actual !== expected"", function() {
     var matcher = jasmineUnderTest.matchers.toBe(jasmineUnderTest.matchersUtil),
       result;
See #1718",johnjbarton,CONTRIBUTOR,2019-06-27 16:07:47+00:00,False,,,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1727,custom reporter for disabled tests,"Folks, we have a need to report on tests which are disabled using a custom reporter.  Is this something that is easily implementable in 
  
    
      jasmine/lib/jasmine-core/jasmine.js
    
    
        Lines 1374 to 1442
      in
      066162d
    
    
    
    

        
          
               var reporter = new j$.ReportDispatcher( 
        

        
          
                 [ 
        

        
          
                   /** 
        

        
          
                    * `jasmineStarted` is called after all of the specs have been loaded, but just before execution starts. 
        

        
          
                    * @function 
        

        
          
                    * @name Reporter#jasmineStarted 
        

        
          
                    * @param {JasmineStartedInfo} suiteInfo Information about the full Jasmine suite that is being run 
        

        
          
                    * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on. 
        

        
          
                    * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion. 
        

        
          
                    * @see async 
        

        
          
                    */ 
        

        
          
                   'jasmineStarted', 
        

        
          
                   /** 
        

        
          
                    * When the entire suite has finished execution `jasmineDone` is called 
        

        
          
                    * @function 
        

        
          
                    * @name Reporter#jasmineDone 
        

        
          
                    * @param {JasmineDoneInfo} suiteInfo Information about the full Jasmine suite that just finished running. 
        

        
          
                    * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on. 
        

        
          
                    * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion. 
        

        
          
                    * @see async 
        

        
          
                    */ 
        

        
          
                   'jasmineDone', 
        

        
          
                   /** 
        

        
          
                    * `suiteStarted` is invoked when a `describe` starts to run 
        

        
          
                    * @function 
        

        
          
                    * @name Reporter#suiteStarted 
        

        
          
                    * @param {SuiteResult} result Information about the individual {@link describe} being run 
        

        
          
                    * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on. 
        

        
          
                    * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion. 
        

        
          
                    * @see async 
        

        
          
                    */ 
        

        
          
                   'suiteStarted', 
        

        
          
                   /** 
        

        
          
                    * `suiteDone` is invoked when all of the child specs and suites for a given suite have been run 
        

        
          
                    * 
        

        
          
                    * While jasmine doesn't require any specific functions, not defining a `suiteDone` will make it impossible for a reporter to know when a suite has failures in an `afterAll`. 
        

        
          
                    * @function 
        

        
          
                    * @name Reporter#suiteDone 
        

        
          
                    * @param {SuiteResult} result 
        

        
          
                    * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on. 
        

        
          
                    * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion. 
        

        
          
                    * @see async 
        

        
          
                    */ 
        

        
          
                   'suiteDone', 
        

        
          
                   /** 
        

        
          
                    * `specStarted` is invoked when an `it` starts to run (including associated `beforeEach` functions) 
        

        
          
                    * @function 
        

        
          
                    * @name Reporter#specStarted 
        

        
          
                    * @param {SpecResult} result Information about the individual {@link it} being run 
        

        
          
                    * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on. 
        

        
          
                    * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion. 
        

        
          
                    * @see async 
        

        
          
                    */ 
        

        
          
                   'specStarted', 
        

        
          
                   /** 
        

        
          
                    * `specDone` is invoked when an `it` and its associated `beforeEach` and `afterEach` functions have been run. 
        

        
          
                    * 
        

        
          
                    * While jasmine doesn't require any specific functions, not defining a `specDone` will make it impossible for a reporter to know when a spec has failed. 
        

        
          
                    * @function 
        

        
          
                    * @name Reporter#specDone 
        

        
          
                    * @param {SpecResult} result 
        

        
          
                    * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on. 
        

        
          
                    * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion. 
        

        
          
                    * @see async 
        

        
          
                    */ 
        

        
          
                   'specDone' 
        

        
          
                 ], 
        

        
          
                 queueRunnerFactory 
        

        
          
               ); 
        
    
  


i.e. specDisabled and suiteDisabled ?
Thanks!",vasiliyb,NONE,2019-06-27 16:33:30+00:00,False,,,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
1728,Browser error handling loses information.,"The browser onerror handler has multiple arguments:
window.onerror = function(message, source, lineno, colno, error) { ... }
But jasmine seems to defeat the feature by only passing a single argument
QueueRunner.prototype.execute = function() {
    var self = this;
    this.handleFinalError = function(error) {
      self.onException(error);
    };
    this.globalErrors.pushListener(this.handleFinalError);
    this.run(0);
  };
Then only the last handler is used:
    var onerror = function onerror() {
      var handler = handlers[handlers.length - 1];

      if (handler) {
        handler.apply(null, Array.prototype.slice.call(arguments, 0));
      } else {
        throw arguments[0];
      }
    };
How can we get the full stack?",johnjbarton,CONTRIBUTOR,2019-06-27 20:05:24+00:00,False,,,,1,0,,,,,0,0,0,0,[],False,False,False,False,False,False,False,False,False,False,False,False,False,False,False
